/*
 * MC6809 Toolkit
 * Copyright (C) 2023  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
grammar org.bpy.electronics.mc6809.assembler.Assembler  //with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate assembler "http://www.bpy.org/electronics/mc6809/assembler/Assembler"

/*
 * Entry point of an as9 file
 */
Model:
	sourceLines += SourceLine*
;
	
/*
 * Description of an assembler line.
 * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
 */	
SourceLine:
	(
		  (lineContent = BlankLine)
		| (lineContent = CommentLine) 
		| (lineContent = DirectiveLine)
		| (lineContent = InstructionLine)
	) 
;

/*
 * Blanck line is an empty line or a set of space or tabs followed by a end of line
 */
BlankLine:
	{BlankLine} (blankLine = WS)? EndOfLine  
;

/*
 * definition of a comment line
 * A comment line start with a ; following by anything and finish with a end of line 
 */
CommentLine:
	comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine 
;

/*
 * Definition of the list possible instructions
 */
InstructionLine:
	(name = IdentifierValue)? WS 
	(
		instruction = AbxInstruction            |
		instruction = AdcInstruction            |
		instruction = AddInstruction            |
		instruction = AdddInstruction           |
		instruction = AndInstruction            |
		instruction = AndCCInstruction          |
		instruction = AslInstruction			|  
		instruction = AsrInstruction            |
		instruction = BccInstruction			|
		instruction = BcsInstruction  			|
		instruction = BeqInstruction			|
		instruction = BgeInstruction			|
		instruction = BgtInstruction			|
		instruction = BhiInstruction			|
		instruction = BhsInstruction  			|	
		instruction = BitInstruction			|
		instruction = BleInstruction            |
		instruction = BloInstruction			|
		instruction = BlsInstruction			|
		instruction = BltInstruction			|
		instruction = BmiInstruction			|			
		instruction = BneInstruction			|				
		instruction = BplInstruction			|			
		instruction = BraInstruction			|			
		instruction = BrnInstruction			|				
		instruction = BsrInstruction			|			
		instruction = BvcInstruction			|			
		instruction = BvsInstruction			|
		instruction = ClrInstruction			|			
		instruction = CmpInstruction			|			
		instruction = ComInstruction			|			
		instruction = CwaiInstruction			|			
		instruction = DaaInstruction			|
		instruction = DecInstruction			|
		instruction = EorInstruction			|
		instruction = ExgInstruction			|
		instruction = IncInstruction			
	)  
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	WS? EndOfLine	
;

/*
 * INC
 * 
 * Increment
 * Source Form		: INC Q, INCA; INCB 
 * Operation		: M'— M+1
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V -Set if the original operand was 01111111; cleared otherwise.
 * 					  C - Not affected.
 * Description		: Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations. 
 * 					  When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values, 
 * 					  all signed branches are correctly available.
 * Addressing Mode	: Inherent
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
IncInstruction:
    (
	   instruction = ('INCA' | 'INCB')
	)
	|  
	(
	 	instruction = ('INC')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * EXG
 * 
 * Exclusive OR
 * Source Form		: EXG R1,R2
 * Operation		: R1<->R2
 * Condition Codes	: Not affected (unless one of the registers is the condition coderegister).
 * Description		: Exchanges data between two designated registers. Bits 3-0 of the postbyte define one register, 
 *                    while bits 7-4 define the other, as follows: 
 * 									0000 = A:B				1000 = A 			
 * 									0001 =X					1001 = B
 * 									0010 = Y				1010 = COR
 * 									0011= US				1011= DPR
 * 									0100 = SP				1100 = Undefined
 * 									0101 = PC				1101 = Undefined
 * 									0110 = Undefined		1110 = Undefined
 * 									0111= Undefined			1111 = Undefined
 *					 Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
 * Addressing Mode	: Immediate
 */
ExgInstruction:
	instruction = ('EXG' )
	WS reg1=Register ',' reg2=Register	
;

/*
 * EOR
 * 
 * Exclusive OR
 * Source Form		: EORA P; EORB P
 * Operation		: R'— R®M
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result is zero; cleared otherwise.
 *                    V - Always cleared.
 * 					  C - Not affected.
 * Description		: The contents of memory location M is exclusive ORed into an 8-blt register..
 * Addressing Mode	: Immediate
 *                    Extended
 *                    Direct
 *                    Indexed 
 */
EorInstruction:
	instruction = ('EORA' | 'EORB')
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)	
;

/*
 * DEC
 * 
 * Decrement
 * Source Form		: DEC Q, DECA; DECB 
 * Operation		: M'— M-1
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Set if the original operand was 10000000; cleared otherwise.
 * 					  C - Not affected.
 * Description		: Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter
 *                    in multipleprecision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently.
 *                    When operating on twos complement values, all signed branches are available.
 * Addressing Mode	: Inherent
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
DecInstruction:
    (
	   instruction = ('DECA' | 'DECB')
	)
	|  
	(
	 	instruction = ('DEC')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * DAA
 * 
 * Decimal Addition Adjust
 * Source Form		: DAA
 * Operation		: ACCA'— ACCA + OF (MSN):CF(LSN)
 *                    where OF is a Correction Factor, as follows: the CF for each nibble
 *                    (BCD) digit is determined separately, and is either 6 or 0.
 * 
 *                    Least Significant Nibble
 *                    CF(LSN) = 6IFF1)C = 1
 *                                     or2)LSN>9
 * 
 *                    Most Significant Nibble
 *                   CF(MSN) = 6IFF1)C = 1
 *                                     or 2) MSN > 9
 *                                     or 3) MSN > 8 and LSN> 9
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result is zero; cleared otherwise.
 *                    V - Undefined
 * 					  C - Set if a carry is generated or if the carry bit was set before the operation; cleared otherwise.
 * Description		: The sequence of a single-byte add instruction on accumulator A (either ADDA or ADCA) and a following decimal addition adjust instruction results
 *                    in a BCD addition with an appropriate carry bit. Both values to be added must be in proper BCD form (each nibble such that: 0<nibble<9). 
 *                    Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA) 
 *                    immediately prior to the next decimal addition adjust.
 * Addressing Mode	: inherent
 */
DaaInstruction:
	instruction = 'DAA'
;

/*
 * CWAI
 * 
 * Clear CC bits and Wait for Interrupt
 * Source Form		: CWAI #$xx 
 * Operation		: CCR'^CCR A Ml (Possibly clear masks)
 *                    Set E (entire state saved)
 *                    SP'— SP-1,(SP)*-PCL
 *                    SP'— SP-1,(SP)— PCH
 *                    SP'*-SP-1,(SP)— USL
 *                    SP'— SP-1,(SP)— USH
 *                    SP'— SP-1,(SP)*-IYL
 *                    SP'*-SP-1,(SP)— lYH
 *                    SP'— SP-1,(SP)-IXL
 *                    SP'—SP-1,(SP)— IXH
 *                    SP'— SP-1,(SP)-DPR
 *                    SP'-SP-1,(SP)-ACCB
 *                    SP'^SP-1, (SP)— ACCA
 *                    SP'— SP-1,(SP)-CCR
 * Condition Codes	: Affected according to the operation.
 * Description		: This instruction ANDs an immediate byte with the condition code register which may clear the 
 *                    interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then 
 *                    looks for an interrupt. When a non-masked interrupt occurs, no further machine state information 
 *                    need be saved before vectoring to the interrupt handling routine. This instruction replaced the 
 *                    MC6800 CLI WAI sequence, but does not place the buses in a high-impedance state. A FIRQ 
 *                    (fast interrupt request) may enter its interrupt handler with its entire machine state saved. 
 *                    The RTI (return from interrupt) instruction will automatically return the entire machine state 
 *                    after testing the E (entire) bit of the recovered condition code register.
 * Addressing Mode	: Immediate
 */
CwaiInstruction:
 	instruction = ('CWAI')
	WS operand = ( 
		ImmediatOperand  
	)
;

/*
 * COM
 * 
 * Complement
 * Source Form		: COM Q, COMA; COMB 
 * Operation		: M'<— 0 + !M
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result is zero; cleared otherwise.
 *                    V - Always cleared.
 * 					  C - Always set.
 * Description		: Replaces the contents of memory location M or accumulator A or B with its logical complement.
 *                    When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly
 *                    following a COM instruction. When operating on twos complement values, all signed branches are 
 *                    available.
 * Addressing Mode	: Inherent
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
ComInstruction:
	(
    	instruction = ('COMA' | 'COMB')
	)
	|  
	(
	 	instruction = ('COM')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * CMP
 * 
 * Compare Memory from Register
 * Source Form		: CMPA Q, CMPB Q 
 * Operation		: TEMP<-R_M
 * Condition Codes	: H - Undefined.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result is zero; cleared otherwise.
 *                    V - Set if an overflow is generated; cleared otherwise.
 * 					  C - Set if a borrow is generated; cleared otherwise.
 * Description		: Compares the contents of memory location to the contents of the specified register and sets the 
 *                    appropriate condition codes. Neither memory location M nor the specified register is modified. 
 *                    The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
 * Addressing Mode	: Immediate
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
CmpInstruction:
 	instruction = ('CMPA' | 'CMPB')
	WS operand = ( 
		ImmediatOperand      |
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
;

/*
 * CLR
 * 
 * Clear
 * Source Form		: CLR Q, CLRA; CLRB 
 * Operation		: TEMP<-M
 *					: M<—OO16
 * Condition Codes	: H - Not affected.
 * 					  N - Always cleared.
 * 					  Z - Always set.
 *                    V - Always cleared.
 * 					  C - Always cleared.
 * Description		: Accumulator A or B or memory location M is loaded with 00000000.
 * 					  Note that the EA is read during this operation.
 * Addressing Mode	: Inherent
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
ClrInstruction:
	(
    	instruction = ('CLRA' | 'CLRB')
	)
	|  
	(
	 	instruction = ('CLR')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * BVS
 * 
 * Branch on Overflow set
 * Source Form		: BVS dd; LBVS DDDD 
 * Operation		: TEMP-MI
 *                    IFF V = 1 then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the 
 *                    twos complement result was valid. When used after an operation on twos complement binary values, this 
 *                    instruction will branch if there was no overflow.
 * Addressing Mode	: Relative
 */
BvsInstruction:
 	instruction = ('BVS' | 'LBVS')
	WS operand = RelativeMode
;

/*
 * BVC
 * 
 * Branch on Overflow Clear
 * Source Form		: BVC dd; LBVC DDDD 
 * Operation		: TEMP-MI
 *                    IFF V = 0 then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the 
 *                    twos complement result was valid. When used after an operation on twos complement binary values, this 
 *                    instruction will branch if there was no overflow.
 * Addressing Mode	: Relative
 */
BvcInstruction:
 	instruction = ('BVC' | 'LBVC')
	WS operand = RelativeMode
;

/*
 * BSR
 * 
 * Branch to Subroutine
 * Source Form		: BSR dd; LBSR DDDD 
 * Operation		: TEMP-MI
 *                    SP'— SP-1,(SP)— POL
 * 					  SP'-SP-1,(SP)— PCH
 * 					  PC— PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: The program counter is pushed onto the stack. The program counter is then loaded with the sum 
 * 					  of the program counter and the offset.
 * Addressing Mode	: Relative
 */
BsrInstruction:
 	instruction = ('BSR' | 'LBSR')
	WS operand = RelativeMode
;

/*
 * BRN
 * 
 * Branch Never
 * Source Form		: BRN dd; LBRN DDDD 
 * Operation		: TEMP-MI
 * Condition Codes	: Not affected.
 * Description		: Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
 * Addressing Mode	: Relative
 */
BrnInstruction:
 	instruction = ('BRN' | 'LBRN')
	WS operand = RelativeMode
;

/*
 * BRA
 * 
 * Branch always
 * Source Form		: BRA dd; LBRA DDDD 
 * Operation		: TEMP-MI
 *                    PC— PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes an unconditlonai branch.
 * Addressing Mode	: Relative
 */
BraInstruction:
 	instruction = ('BRA' | 'LBRA')
	WS operand = RelativeMode
;

/*
 * BPL
 * 
 * Branch on plus
 * Source Form		: BPL dd; LBPL DDDD 
 * Operation		: TEMP-MI
 *                    IFF N=0 then PC— PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of 
 *                    the twos complement result is positive.
 * Addressing Mode	: Relative
 */
BplInstruction:
 	instruction = ('BPL' | 'LBPL')
	WS operand = RelativeMode
;

/*
 * BNE
 * 
 * Branch not equal
 * Source Form		: BNE dd; LBNE DDDD 
 * Operation		: TEMP-MI
 *                    IFF Z = then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare 
 * 	                  operation on any binary values, this instruction will branch if the register is, or would be, not equal to the 
 *                    memory operand.
 * Addressing Mode	: Relative
 */
BneInstruction:
 	instruction = ('BNE' | 'LBNE')
	WS operand = RelativeMode
;

/*
 * BMI
 * 
 * Branch on Minus
 * Source Form		: BMI dd; LBMI DDDD 
 * Operation		: TEMP-MI
 *                    IFF N = 1 then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the N (negative) bit and causes a branch if set.
 *					  That is, branch if the sign of the twos compiement result is negative.
 * Addressing Mode	: Relative
 */
BmiInstruction:
 	instruction = ('BMI' | 'LBMI')
	WS operand = RelativeMode
;

/*
 * BLT
 * 
 * Branch on Less than Zero
 * Source Form		: BLT dd; LBLT DDDD 
 * Operation		: TEMP-MI
 *                    IFF [NeV]=1 then PC—PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch 
 *                    if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare 
 *                    operation on twos complement binary values, this instruction will branch if the register was less than the memory
 *                    operand.
 * Addressing Mode	: Relative
 */
BltInstruction:
 	instruction = ('BLT' | 'LBLT')
	WS operand = RelativeMode
;

/*
 * BLS
 * 
 * Branch on Lower
 * Source Form		: BLS dd; LBLS DDDD 
 * Operation		: TEMP-MI
 *                    IFF(CvZ) = 1 then PC— PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or 
 *                    compare operation on unsigned binary values, this instruction will branch if the register was lower than or the 
 *                    same as the memory operand.
 * Addressing Mode	: Relative
 */
BlsInstruction:
 	instruction = ('BLS' | 'LBLS')
	WS operand = RelativeMode
;

/*
 * BLO
 * 
 * Branch on Lower
 * Source Form		: BLO dd; LBLO DDDD 
 * Operation		: TEMP-MI
 *                    IFF = 1 then PO'*-PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned 
 *                    binary values, this instruction will branch if the register was lower than the memory operand.
 * Addressing Mode	: Relative
 */
BloInstruction:
 	instruction = ('BLO' | 'LBLO')
	WS operand = RelativeMode
;

/*
 * BLE
 * 
 * Branch on Less than or Equal to Zero
 * Source Form		: BLE dd; LBLE DDDD 
 * Operation		: TEMP-MI
 *                    IFF Z V [N ® V] = 1 then PC- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set. 
 *                    That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract 
 *                    or compare operation on twos complement values, this instruction will branch if the register was less than or equal 
 *                    to the memory operand.
 * Addressing Mode	: Relative
 */
BleInstruction:
 	instruction = ('BLE' | 'LBLE')
	WS operand = RelativeMode
;

/*
 * BIT
 * 
 * Bit Test
 * Source Form		: Bit P
 * Operation		: TEMP— RAM
 * Condition Codes	: H - Undefined
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V -  Always cleared
 * 					  C - Not affected.
 * Description		: Performs the logical AND of the contents of accumulator A or B and the contents of memory location M and modifies the condition
 *                    codes accordingly. The contents of accumulator A or B and memory location M are not affected.
 * Addressing Mode	: Immediate
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
BitInstruction:
	(
		instruction = ('BIT')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * BHS
 * 
 * Branch if Higher or Same
 * Source Form		: BHS dd; LBHS DDDD 
 * Operation		: TEMP— Ml
 *                    IFF C = 0 then PC'^PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the C (carry) bit and causes a branch if it is clear.
 *                    When used after a subtract or compare on unsigned binary values,
 *                    this instruction will branch if the register was higher than or the
 *                    same as the memory operand.
 * Addressing Mode	: Relative
 */
BhsInstruction:
 	instruction = ('BHS' | 'LBHS')
	WS operand = RelativeMode
;

/*
 * BHI
 * 
 * Branch if Higher
 * Source Form		: BHI dd; LBHI DDDD 
 * Operation		: TEMP— Ml
 *                    IFF [0 V Z] = 0 then PC'^PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if the previous operation caused neither a carry nor
 *                    a zero result. When used after a subtract or compare operation on
 *                    unsigned binary values, this instruction will branch if the register
 *                    was higher than the memory operand.
 * Addressing Mode	: Relative
 */
BhiInstruction:
 	instruction = ('BHI' | 'LBHI')
	WS operand = RelativeMode
;

/*
 * BGT
 * 
 * Branch on Greater than or Equal to Zero
 * Source Form		: BGT dd; LBGT DDDD 
 * Operation		: TEMP— Ml
 *                    IFF ZA[N®V] = 0 then PC'^PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if the N (negative) bit and V (overflow) bit are either
 *					  both set or both clear and the Z (zero) bit is clear. In other words,
 * 					  branch if the sign of a valid twos complement result is, or would be,
 * 					  positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the
 * 					  register was greater than the memory operand.
 * Addressing Mode	: Relative
 */
BgtInstruction:
 	instruction = ('BGT' | 'LBGT')
	WS operand = RelativeMode
;

/*
 * BGE
 * 
 * Branch on Greater than or Equal to Zero
 * Source Form		: BGE dd; LBGE DDDD 
 * Operation		: TEMP— Ml
 *                    IFF [N®V] = then PC'^PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Causes a branch if the N (negative) bit and the V (overflow) bit are
 *					  either both set or both clear. That is, branch if the sign of a valid
 *                    twos complement result is, or would be, positive. When used after a
 *                    subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the
 *                    memory operand.
 * Addressing Mode	: Relative
 */
BgeInstruction:
 	instruction = ('BGE' | 'LBGE')
	WS operand = RelativeMode
;

/*
 * BEQ
 * 
 * Branch on Equal
 * Source Form		: BEQ dd; LBEQ DDDD 
 * Operation		: TEMP— Ml
 *                    IFF Z=1  then PC'<- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the Z (zero) bit and causes a branch if it is set.
 *     				  When used after a subtract or compare operation, this Instruction
 * 					  will branch If the compared values, signed or unsigned, were exactly
 * 					  the same.
 * Addressing Mode	: Relative
 */
BeqInstruction:
 	instruction = ('BEQ' | 'LBEQ')
	WS operand = RelativeMode
;

/*
 * BCS
 * 
 * Branch on Carry Set
 * Source Form		: BCS dd; LBCS DDDD 
 * Operation		: TEMP— Ml
 *                    IFF C=A  then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the C (carry) bit and causes a branch If it Is set.
 * Addressing Mode	: Relative
 */
BcsInstruction:
 	instruction = ('BCS' | 'LBCS')
	WS operand = RelativeMode
;

/*
 * BCC
 * 
 * Branch on Carry Clear
 * Source Form		: BCC dd; LBCC DDDD 
 * Operation		: TEMP— Ml
 *                    IFF C = then PC'*- PC + TEMP
 * Condition Codes	: Not affected.
 * Description		: Tests the state of the C (carry) bit and causes a branch If it Is clear.
 * Addressing Mode	: Relative
 */
BccInstruction:
 	instruction = ('BCC' | 'LBCC')
	WS operand = RelativeMode
;

/*
 * ASR
 * 
 * Arithmetic Shift Right
 * Source Form		: ASR Q, ASLA; ASLB 
 * Operation		: 
 * Condition Codes	: H - Undefined
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Not affected
 * 					  C - Loaded with bit seven of the original operand.
 * Description		: Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
 * Addressing Mode	: Inherent
 * 					  Extended
 *                    Direct
 *                    Indexed
 */
AsrInstruction:
    (
    	instruction = ('ASRA' | 'ASRB')
	)
	|  
	(
	 	instruction = ('ASR')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * ASL
 * 
 * Arithmetic Shift Left
 * Source Form		: ASL Q, ASLA; ASLB 
 * Operation		: 
 * Condition Codes	: H - Undefined
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
 * 					  C - Loaded with bit seven of the original operand.
 * Description		: Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is 
 *                    shifted into the C (carry) bit.
 * Addressing Mode	: Inherent
 */
AslInstruction:
    (
	   instruction = ('ASLA' | 'ASLB')
	)
	|  
	(
	 	instruction = ('ASL')
		WS operand = ( 
			DirectOperand  |
			IndexedOperand | 
			ExtendedOperand |
			ExtendedIndirectOperand 
		)
	)   
;

/*
 * ANDCC
 * 
 * Logical AND Immediate Memory into Condition Code Register
 * Source Form		: ANDOG #xx
 * Operation		: R'— R A Ml
 * Condition Codes	: Affected according to the operation.
 * Description		: PPerforms a logical AND between the condition code register and the Immediate byte specified In 
 *                    the instruction and places the result in the condition code register.
 * Addressing Mode	: Immediate
 */
AndCCInstruction:
	instruction = ('ANDCC')
	WS operand = ( 
		ImmediatOperand  
	)
;

/*
 * AND
 * 
 * Logical AND Memory into Register
 * Source Form		: ANDA P; ANDB P
 * Operation		: R'— RAM
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Always cleared.
 * 					  C - Not affected.
 * Description		: Performs the logical AND operation between the contents of an accumulator and the contents
 * 					  of memory location M and the result is stored in the accumulator.
 * Addressing Mode	: Immediate
 *                    Extended
 *                    Direct
 *                    Indexed 
 */
AndInstruction:
	instruction = ('ANDA' | 'ANDB')
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
;

/*
 * ADDD
 * 
 * Add Memory into Register
 * Source Form		: ADDD P
 * Operation		: R'— R + M:M + 1
 * Condition Codes	: H - Not affected.
 * 					  N - Set if the result is negative; cleared otherwise.
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Set if an overflow is generated; cleared otherwise,
 * 					  C - Set if a carry is generated; cleared otherwise.
 * Description		: Adds the 16-bit memory value into the 16-bit accumulator
 * Addressing Mode	: Immediate
 *                    Extended
 *                    Direct
 *                    Indexed 
 */
AdddInstruction:
	instruction = ('ADDD')
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
;

/*
 * ADD
 * 
 * Add Memory into Register
 * Source Form		: ADDA P; ADDB P
 * Operation		: R'— R + M
 * Condition Codes	: H - Set if a half-carry is generated; cleared otherwise,
 * 					  N - Set if the result Is negative; cleared otherwise,
 * 					  Z - Set if the result Is zero; cleared otherwise,
 *                    V - Set if an overflow is generated; cleared otherwise,
 * 					  C - Set if a carry is generated; cleared otherwise.
 * Description		: Adds the memory byte into an 8-bit accumulator.
 * Addressing Mode	: Immediate
 *                    Extended
 *                    Direct
 *                    Indexed 
 */
AddInstruction:
	instruction = ('ADDA' | 'ADDB')
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
;

/*
 * ADC
 * 
 * Add with Carry into Register
 * Source Form		: ADCA P; ADCB P
 * Operation		: R'*-R + M + C
 * Condition Codes	: H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
 * 					  N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
 * 					  Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
 *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
 * 					  C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
 * Description		: Add the 8-bit unsigned value in accumulator B into index register X.
 * Addressing Mode	: Immediate
 *                    Extended
 *                    Direct
 *                    Indexed 
 */
AdcInstruction:
	instruction = ('ADCA' | 'ADCB')
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
;

/*
 * ABX
 * 
 * Add Accumulator B into Index Register X
 * Source Form		: ABX
 * Operation		: IX'— IX + ACCB
 * Condition Codes	: Not affected.
 * Description		: Add the 8-bit unsigned value in accumulator B into index register X.
 * Addressing Mode	: Inherent 
 */
AbxInstruction:
	instruction = 'ABX'
;

/*
 * Extended Indirect
 *
 * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to 
 * two bytes in memory which are used as the effective address.
 * 
 * Example:
 * LDA [$A012] loads A from the address stored at locations $A012 and $A013 
 */
ExtendedIndirectOperand:
	'[' operand=Expression ']'
;

/*
 * Extended
 * 
 * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
 * memory address value.
 * 
 * Example:
 * LDA $1000 load A from memory location 1000 hex  
 */
ExtendedOperand:
	('>'?) operand=Expression
;
//
//IndexedOperand:
//	
//;

/*
 * Direct
 * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
 * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
 * found in the Direct Page register. Thus, the effective address is a concatenation of the
 * Direct Page register as the most significant half and the byte following the opcode as the 
 * least significant half.
 *
 * Example:
 * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register  
 */
DirectOperand:
	'<' operand=Expression
;

/*
 * Immediate
 * In Immediate addressing the byte or bytes following the opcode are the information being
 * addressed. These byte or bytes are specified as part of the instruction.
 *
 * Example:
 * LDA #8 load immediate value (8) into A 
 */
ImmediatOperand:
	'#' operand=Expression 
;

IndexedOperand:
	mode=AutoIncDecMode  | 
	mode=ConstantIndexedMode | 
	mode=AccumulatorMovingMode | 
	mode=RelatifToPCMode |
	mode=ConstantIndexedMovingIndirectMode | 
	mode=AutoIncDecIndirectMode  | 
	mode=AccumulatorMovingIndirectMode |		
	mode=RelatifToPCIndirectMode
;

ConstantIndexedMode:
	deplacement=NumericalValue?
	',' 
	register=('S' | 'U' | 'X' | 'Y')
;

ConstantIndexedMovingIndirectMode:
	'['
	deplacement=NumericalValue? 
	',' 
	register=('S' | 'U' | 'X' | 'Y')
	']'
;

AccumulatorMovingMode:
	deplacement=('A' | 'B' | 'D') 
	','
	register=('S' | 'U' | 'X' | 'Y')
;

AccumulatorMovingIndirectMode:
	'['
	deplacement=('A' | 'B' | 'D') 
	','
	register=('S' | 'U' | 'X' | 'Y')
	']'
;

AutoIncDecMode:
	deplacement=NumericalValue?
	',' 
	((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	 register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
;

AutoIncDecIndirectMode:
	'['
	deplacement=NumericalValue?
	',' 
	((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	 register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	']'
;

RelatifToPCMode:
	deplacement=NumericalValue?
	',' 
	(register='PCR' )
;

RelatifToPCIndirectMode:
	'['
	deplacement=NumericalValue? 
	',' 
	(register='PCR' )
	']'
;

RelativeMode:
	location=IdentifierValue;

/*
 * Definition of the list possible directives
 */
DirectiveLine:
	(name = IdentifierValue)? WS
	(
	 	   directive = EquDirective
		|  directive = OrgDirective
		|  directive = BszDirective
		|  directive = EndDirective
		|  directive = FailDirective
		|  directive = FillDirective
		|  directive = OptDirective
		|  directive = PagDirective
		|  directive = NamDirective
		|  directive = SetDirective
		|  directive = SpcDirective
		|  directive = RegDirective
		|  directive = FcbDirective
		|  directive = FdbDirective
		|  directive = FccDirective
		|  directive = RmbDirective
	)
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	WS? EndOfLine
;

/*
 * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
 * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will 
 * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid 
 * examples follow:
 *
 * LABEL1 FCC 'THIS IS AN FCC STRING'
 * LABEL2 FCC .SO IS THIS.
 * FCC /LABELS ARE NOT REQUIRED./
 * 
 * There is another method of using FCC which is a deviation from the standard Motorola definition of this
 * directive. This allows you to place certain expressions on the same line as the standard FCC delimited 
 * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
 * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter, 
 * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111 
 * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
 * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
 * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
 * inserted along with strings. Some examples follow:
 * 
 * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
 * FCC 'STRING 1',0,'STRING 2'
 * FCC $04,LABEL,/DELIMITED STRING/
 *
 * Note that more than one delimited string may be placed on a line as in the second example.
 */
FccDirective:
	directive = 'FCC'
	(WS string=STRING) 
;

/*
 *  REG
 *
 * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
 * This list is represented by a value and the value is equated to the label supplied. In this respect, 
 * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
 *
 * <label> REG <register list>
 * 
 * As an example, suppose a program has a large number of occurences of the following instructions:
 *
 * PSHS A,B,Y,U,DP
 * PULS A,B,Y,U,DP
 *
 * To make things more convenient and less error prone the REG directive could be used as shown here:
 * 
 * RLIST2 REG A,B,Y,U,DP
 *
 * Now all the pushes and pulls referred to above could be accomplished with the statements:
 * 
 * PSHS #RLIST2
 * PULS #RLIST2
 *
 * Of course, the register list may still be typed out on push and pull instructions or an immediate value
 * (with the desired bit pattern) may be specified.
 */
RegDirective:
	(directive = 'REG')
	(WS options+=Register ( ',' options+=Register)*)? 
;

/*
 *  SPC
 *
 * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
 *  listing. The general form is:
 *  
 * SPC [<space count>[,<keep count>]]
 *
 * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
 * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
 * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
 * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
 *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
 *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing. 
 */
SpcDirective:
	directive = 'SPC' 
	(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
;

/*
 *  TTL or NAM
 *
 * The TTL or NAM directive allows the user to specify a title or name to the program being assembled. 
 * This title is then printed in the header at the top of each output listing page if the page option is 
 * selected. If the page option is not selected, this directive is ignored. The proper form is:
 *
 * TTL <text for the title>
 * or
 * NAM <text for the title>
 * 
 * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer. 
 * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL 
 * or NAM directives in a source program. The latest one encountered will always be the one used for printing 
 * at the top of the following page(s).
 */
NamDirective:
	(directive = 'NAM'|directive = 'TTL') 
	WS (operand=IdentifierValue)
;

/*
 *  PAG
 *
 * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page. 
 * Note that the 'PAG' option must have been previously selected in order for this directive to take effect. 
 * It is possible to assign a new number to the new page by specifying such in the operand field. If no page 
 * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
 *  The PAG operator itself will not appear in the listing unless some sort of error is encountered. 
 * The proper form is:
 *
 * PAG [<expression>]
 *
 * Where the expression is optional. The first page of a listing does not have the header printed on it and 
 * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and  
 * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title, 
 * or subtitle instructions being in the way. 
 */
PagDirective:
	directive = 'PAG' 
	(WS (operand=Expression))?
;

/*
 * OPT
 * 
 *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
 *  These options are generally related to the format of the output listing and object code. The options which
 *  may be set with this command are listed below. There are several options not listed here which may be set
 *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper 
 * form of this instruction is:
 * 
 * OPT <option 1>,<option 2>,...,<option n>
 *
 * Note that any number of options may be given on one line if separated by commas. No label is allowed and no 
 * spaces may be embedded in the option list. The options are all set during pass one only although the 
 * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are 
 * specified, the last one appearing takes precedence. If a particular option is not specified, the default 
 * case for that option takes effect. The default cases are signified below by an asterisk.
 *
 * The allowable options are:
 * 
 * PAG enable page formatting and numbering
 * NOP* disable pagination
 *
 * CON print conditionally skipped code
 * NOC* suppress conditional code printing
 *
 * MAC* print macro calling lines
 * NOM suppress printing of macro calls
 *
 * EXP print macro expansion lines
 * NOE* Suppress macro expansion printing
 *
 * * denotes default option and is not part of option name 
 */
OptDirective:
	directive = 'OPT'
	(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)? 
;

/*
 * FAIL
 * 
 * 
 */
FailDirective:
	directive = 'FAIL' 
;

/*
 * SET
 * 
 * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
 * The difference is that a symbol may be SET several times within the source (to different values) while 
 * a symbol may be Equated only once. 
 * If a symbol is SET to several values within the source, the current value of the symbol will be 
 * the value last SET. The statement form is:
 *
 * <label> SET <expression>
 *
 * The label is strictly required and no code is generated.  
 */
SetDirective:
	directive = 'SET' 
	WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		)
;

/*
 * FILL
 * 
 * FILL allow to initialize a memory area with a value
 * the first value define the value to set, the seconfd value define the number of byte to set
 */
FillDirective:
	directive = 'FILL' 
	(WS value=Expression ',' number=Expression) 
;

/*
 * BSZ
 * 
 * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
 * The operand define the number on byte to reserve
 */
BszDirective:
	directive = ('BSZ'|'ZMB') 
	(WS operand=Expression) 
;


/*
 *  FDB
 *
 * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
 * It is exactly like the FCB directive except that 16 bit quantities are evaluated 
 * and stored in memory for each expression given. 
 * The form of the statement is:
 *
 * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
 * 
 * Again, the label field is optional. 
 */
FdbDirective:
	directive = 'FDB' 
	(WS (operand = ListOfExpression))? 
;


/*
 *  The FCB or Form Constant Byte directive is used to set associated memory bytes 
 * to some value as determined by the operand. 
 * FCB may be used to set any number of bytes as shown below:
 *
 * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
 *
 * Where <expr. x> stands for some expression. 
 * Each expression given (separated by commas) is evaluated to 8 bits 
 * and the resulting quantities are stored in successive memory locations. 
 * The label is optional. 
 */
FcbDirective:
	directive = 'FCB' 
	(WS (operand = ListOfExpression))?	
;

/*
 *  RMB
 * 
 * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
 * The number of bytes specified by the expression in the operand are skipped during assembly. 
 * No code is produced in those memory location and therefore the contents are undefined at run time.
 *  The proper useage is shown here:
 * 
 * [<label>] RMB <expression>
 *
 * The label is optional, and the expression is a 16 bit quantity.
 */
RmbDirective:
	directive = 'RMB' 
	(WS (isRelativeToPC?='*'? operand = Expression))?	
;

/*
 * The END pseudo-op is used to signal the assembler that the end of the source input has occurred. 
 * This terminates whatever pass is currently being executed. No label is allowed and no code is generated. 
 * An expression may be given (as shown below) as the transfer address to be placed in a binary file. 
 * It is optional, and if supplied when no binary file is being produced, will be ignored.
 *
 *  END [<expression>]
 *
 * Note that an end statement is not strictly required, 
 * but is the only means of getting a transfer address appended to a binary output file.  
 */
EndDirective:
	directive = 'END' 
	(WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		))?
;

/*
 *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
 *
 * 		ORG <expression>
 *		
 *	No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed. 
 */
OrgDirective:
	directive = 'ORG' 
	(WS ( 
		(isRelativeToPC?='*'? operand=Expression) |
		(isRelativeToPC?='*' )
		))?
;

/*
 * Description of an EQU directive
 * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment  
 */
EquDirective:
	directive = 'EQU' 
	WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		)
;

ListOfExpression:
	expressions+=Expression (',' expressions+=Expression)*
;

Expression:
		operand = Multiplication;

Multiplication returns Expression:
  	Division ({Multiplication.left=current} operation='*' right=Division)*
;

Division returns Expression:
  	Modulo ({Division.left=current} opretation='/' right=Modulo)*
;

Modulo returns Expression:
	Addition ({Modulo.left=current} opretation='%' right=Addition)*
;

Addition returns Expression:
    Substraction ({Addition.left=current} '+' right=Substraction)*
;

Substraction returns Expression:
    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
;
  
LeftShift returns Expression:
	RightShift ({LeftShift.left=current} '<<' right=RightShift)*
;

RightShift returns Expression:
	And ({RightShift.left=current} '>>' right=And)*
;

And returns Expression:
	Or ({And.left=current} '&&' right=Or)*
;

Or returns Expression:
	Xor ({Or.left=current} '||' right=Xor)*
;

Xor returns Expression:
	Primary ({Xor.left=current} '^' right=Primary)*
;

Primary returns Expression:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
   	|   {Not} '!' value=Primary
  	|  '(' Multiplication ')'
 ;

NumericalValue:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
;

IdentifierValue:
	value = ID
;

StringValue:
	value = STRING
;

DecimalValue:
	sign=('-'|'+')? value = INT
;

HexaDecimalValue:
	value = HEXA
;

OctalValue:
	value = OCTAL
;

BinaryValue:
	value = BINARY
;

CharacterValue:
	value = CHARACTER
;

enum AssemblyOption:
	PAG= 'PAG' |
	NOP= 'NOP' |
	CON= 'CON' |
	NOC= 'NOC' |
	MAC= 'MAC' |
	NOM= 'NOM' |
	EXP= 'EXP' |
	NOE= 'NOE' 
	;

enum Register:
	A = 'A'    |
	B = 'B'	   |
	D = 'D'	   |
	X = 'X'	   |
	Y = 'Y'	   |
	U = 'U'	   |
	S = 'S'	   |
	DP = 'DP'  |
	CC = 'CC'  |
	PC = 'PC'  
;


terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
terminal INT returns ecore::EInt			: ('0'..'9')+;
terminal OCTAL 								: '@'('0'..'7')+;
terminal BINARY 							: '0''b'('0'..'1')+;
terminal CHARACTER							: '\'' ('\u0020'..'\u007F');

EndOfLine: CR | END_OF_FILE;

terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' 
		;		
	
terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
terminal WS         						: (' '|'\t')+;
terminal CR          						: '\r'? '\n';
terminal END_OF_FILE 						: EOF;		
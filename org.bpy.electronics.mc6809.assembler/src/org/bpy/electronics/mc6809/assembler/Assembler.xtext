/*
 * European Scoring Tool For Baseball
 * Copyright (C) 2023  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
grammar org.bpy.electronics.mc6809.assembler.Assembler // with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate assembler "http://www.bpy.org/electronics/mc6809/assembler/Assembler"

/*
 * Entry point of an as9 file
 */
Model:
	sourceLines += SourceLine*
;
	
/*
 * Description of an assembler line.
 * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
 */	
SourceLine:
	(
		  (lineContent = BlankLine)
		| (lineContent = CommentLine) 
		| (lineContent = DirectiveLine)
	) 
;

/*
 * Blanck line is an empty line or a set of space or tabs followed by a end of line
 */
BlankLine:
	{BlankLine} (blankLine = WS)? EndOfLine  
;

/*
 * definition of a comment line
 * A comment line start with a ; following by anything and finish with a end of line 
 */
CommentLine:
	comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine 
;

/*
 * Definition of the list possible directives
 * 	EQU  
 */
DirectiveLine:
	directive = EquDirective
;

/*
 * Description of an EQU directive
 * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment  
 */
EquDirective:
	(name = IdentifierValue)? WS (directive = 'EQU') WS (operand = Operand)? WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? EndOfLine	
;


Operand:
		(operand = Multiplication)
	| 	(operand = StringValue)
;

Multiplication returns Expression:
  	Division ({Multiplication.left=current} operation='*' right=Division)*
;

Division returns Expression:
  	Modulo ({Division.left=current} opretation='/' right=Modulo)*
;

Modulo returns Expression:
	Addition ({Modulo.left=current} opretation='%' right=Addition)*
;

Addition returns Expression:
  Substraction ({Addition.left=current} '+' right=Substraction)*
;

Substraction returns Expression:
  LeftShift ({Substraction.left=current} '-' right=LeftShift)*
;
  
LeftShift returns Expression:
	RigthShift ({LeftShift.left=current} '<<' right=RigthShift)*
;

RigthShift returns Expression:
	Negate ({RigthShift.left=current} '>>' Negate=Primary)*
;

Negate returns Expression:
	And ({Negate.left=current} '~' right=And)*
;

And returns Expression:
	Or ({And.left=current} '&&' right=Or)*
;

Or returns Expression:
	Xor ({Or.left=current} '||' right=Xor)*
;

Xor returns Expression:
	Primary ({Or.left=current} '^' right=Primary)*
;

Primary returns Expression:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
  	|  '(' Multiplication ')'
 ;

IdentifierValue:
	value = ID
;

StringValue:
	value = STRING
;

DecimalValue:
	value = INT
;

HexaDecimalValue:
	value = HEXA
;

OctalValue:
	value = OCTAL
;

BinaryValue:
	value = BINARY
;

CharacterValue:
	value = CHARACTER
;

terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
terminal BINARY 							: '%' ('0'..'1')+;
terminal OCTAL 								: '@' ('0'..'7')+;
terminal CHARACTER							: '\'' ('\u0020'..'\u007F');
terminal INT returns ecore::EInt			: ('0'..'9')+;

EndOfLine: CR | END_OF_FILE;

terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* 
		;		
		
terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
terminal WS         						: (' '|'\t')+;
terminal CR          						: '\r'? '\n';
terminal END_OF_FILE 						: EOF;		
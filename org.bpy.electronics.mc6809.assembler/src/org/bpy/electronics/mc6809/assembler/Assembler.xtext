/*
 * European Scoring Tool For Baseball
 * Copyright (C) 2023  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
grammar org.bpy.electronics.mc6809.assembler.Assembler  //with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate assembler "http://www.bpy.org/electronics/mc6809/assembler/Assembler"

/*
 * Entry point of an as9 file
 */
Model:
	sourceLines += SourceLine*
;
	
/*
 * Description of an assembler line.
 * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
 */	
SourceLine:
	(
		  (lineContent = BlankLine)
		| (lineContent = CommentLine) 
		| (lineContent = DirectiveLine)
		| (lineContent = InstructionLine)
	) 
;

/*
 * Blanck line is an empty line or a set of space or tabs followed by a end of line
 */
BlankLine:
	{BlankLine} (blankLine = WS)? EndOfLine  
;

/*
 * definition of a comment line
 * A comment line start with a ; following by anything and finish with a end of line 
 */
CommentLine:
	comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine 
;

/*
 * Definition of the list possible instructions
 */
InstructionLine:
	instruction = AbxInstruction |
	instruction = AdcInstruction
;

/*
 * ADC
 * 
 * Add with Carry into Register
 * Source Form		: ADCA P; ADCB P
 * Operation		: R'*-R + M + C
 * Condition Codes	: H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
 * 					  N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
 * 					  Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
 *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
 * 					  C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
 * Description		: Add the 8-bit unsigned value in accumulator B into index register X.
 * Addressing Mode	: Inherent 
 */
AdcInstruction:
	(name = IdentifierValue)? WS (instruction = ('ADCA' | 'ADCB'))
	WS operand = ( 
		ImmediatOperand | 
		DirectOperand  |
		IndexedOperand | 
		ExtendedOperand |
		ExtendedIndirectOperand 
	)
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	WS? EndOfLine	
;

/*
 * ABX
 * 
 * Add Accumulator B into Index Register X
 * Source Form		: ABX
 * Operation		: IX'â€” IX + ACCB
 * Condition Codes	: Not affected.
 * Description		: Add the 8-bit unsigned value in accumulator B into index register X.
 * Addressing Mode	: Inherent 
 */
AbxInstruction:
	(name = IdentifierValue)? WS (instruction = 'ABX')
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	WS? EndOfLine	
;

/*
 * Extended Indirect
 *
 * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to 
 * two bytes in memory which are used as the effective address.
 * 
 * Example:
 * LDA [$A012] loads A from the address stored at locations $A012 and $A013 
 */
ExtendedIndirectOperand:
	'[' operand=Expression ']'
;

/*
 * Extended
 * 
 * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
 * memory address value.
 * 
 * Example:
 * LDA $1000 load A from memory location 1000 hex  
 */
ExtendedOperand:
	('>'?) operand=Expression
;
//
//IndexedOperand:
//	
//;

/*
 * Direct
 * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
 * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
 * found in the Direct Page register. Thus, the effective address is a concatenation of the
 * Direct Page register as the most significant half and the byte following the opcode as the 
 * least significant half.
 *
 * Example:
 * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register  
 */
DirectOperand:
	'<' operand=Expression
;

/*
 * Immediate
 * In Immediate addressing the byte or bytes following the opcode are the information being
 * addressed. These byte or bytes are specified as part of the instruction.
 *
 * Example:
 * LDA #8 load immediate value (8) into A 
 */
ImmediatOperand:
	'#' operand=Expression 
;

IndexedOperand:
	mode=AutoIncDecMode  | 
	mode=ConstantIndexedMode | 
	mode=AccumulatorMovingMode | 
	mode=RelatifToPCMode |
	mode=ConstantIndexedMovingIndirectMode | 
	mode=AutoIncDecIndirectMode  | 
	mode=AccumulatorMovingIndirectMode |		
	mode=RelatifToPCIndirectMode
;

ConstantIndexedMode:
	deplacement=NumericalValue?
	',' 
	register=('S' | 'U' | 'X' | 'Y')
;

ConstantIndexedMovingIndirectMode:
	'['
	deplacement=NumericalValue? 
	',' 
	register=('S' | 'U' | 'X' | 'Y')
	']'
;

AccumulatorMovingMode:
	deplacement=('A' | 'B' | 'D') 
	','
	register=('S' | 'U' | 'X' | 'Y')
;

AccumulatorMovingIndirectMode:
	'['
	deplacement=('A' | 'B' | 'D') 
	','
	register=('S' | 'U' | 'X' | 'Y')
	']'
;

AutoIncDecMode:
	deplacement=NumericalValue?
	',' 
	((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	 register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
;

AutoIncDecIndirectMode:
	'['
	deplacement=NumericalValue?
	',' 
	((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	 register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	']'
;

RelatifToPCMode:
	deplacement=NumericalValue?
	',' 
	(register='PCR' )
;

RelatifToPCIndirectMode:
	'['
	deplacement=NumericalValue? 
	',' 
	(register='PCR' )
	']'
;

/*
 * Definition of the list possible directives
 */
DirectiveLine:
	   directive = EquDirective
	|  directive = OrgDirective
	|  directive = BszDirective
	|  directive = EndDirective
	|  directive = FailDirective
	|  directive = FillDirective
	|  directive = OptDirective
	|  directive = PagDirective
	|  directive = NamDirective
	|  directive = SetDirective
	|  directive = SpcDirective
	|  directive = RegDirective
	|  directive = FcbDirective
	|  directive = FdbDirective
	|  directive = FccDirective
	|  directive = RmbDirective
;

/*
 * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
 * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will 
 * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid 
 * examples follow:
 *
 * LABEL1 FCC 'THIS IS AN FCC STRING'
 * LABEL2 FCC .SO IS THIS.
 * FCC /LABELS ARE NOT REQUIRED./
 * 
 * There is another method of using FCC which is a deviation from the standard Motorola definition of this
 * directive. This allows you to place certain expressions on the same line as the standard FCC delimited 
 * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
 * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter, 
 * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111 
 * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
 * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
 * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
 * inserted along with strings. Some examples follow:
 * 
 * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
 * FCC 'STRING 1',0,'STRING 2'
 * FCC $04,LABEL,/DELIMITED STRING/
 *
 * Note that more than one delimited string may be placed on a line as in the second example.
 */
FccDirective:
	(name = IdentifierValue)? WS (directive = 'FCC')
	(WS string=STRING) 
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	WS? EndOfLine	
;

/*
 *  REG
 *
 * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
 * This list is represented by a value and the value is equated to the label supplied. In this respect, 
 * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
 *
 * <label> REG <register list>
 * 
 * As an example, suppose a program has a large number of occurences of the following instructions:
 *
 * PSHS A,B,Y,U,DP
 * PULS A,B,Y,U,DP
 *
 * To make things more convenient and less error prone the REG directive could be used as shown here:
 * 
 * RLIST2 REG A,B,Y,U,DP
 *
 * Now all the pushes and pulls referred to above could be accomplished with the statements:
 * 
 * PSHS #RLIST2
 * PULS #RLIST2
 *
 * Of course, the register list may still be typed out on push and pull instructions or an immediate value
 * (with the desired bit pattern) may be specified.
 */
RegDirective:
	(name = IdentifierValue)? WS (directive = 'REG')
	(WS options+=Register ( ',' options+=Register)*)? 
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	EndOfLine	
;

/*
 *  SPC
 *
 * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
 *  listing. The general form is:
 *  
 * SPC [<space count>[,<keep count>]]
 *
 * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
 * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
 * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
 * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
 *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
 *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing. 
 */
SpcDirective:
	(name = IdentifierValue)? WS (directive = 'SPC') 
	(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))? 
	WS? EndOfLine	
;

/*
 *  TTL or NAM
 *
 * The TTL or NAM directive allows the user to specify a title or name to the program being assembled. 
 * This title is then printed in the header at the top of each output listing page if the page option is 
 * selected. If the page option is not selected, this directive is ignored. The proper form is:
 *
 * TTL <text for the title>
 * or
 * NAM <text for the title>
 * 
 * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer. 
 * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL 
 * or NAM directives in a source program. The latest one encountered will always be the one used for printing 
 * at the top of the following page(s).
 */
NamDirective:
	(name = IdentifierValue)? WS (directive = 'NAM'|directive = 'TTL') 
	WS (operand=IdentifierValue)
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))? 
	EndOfLine	
;

/*
 *  PAG
 *
 * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page. 
 * Note that the 'PAG' option must have been previously selected in order for this directive to take effect. 
 * It is possible to assign a new number to the new page by specifying such in the operand field. If no page 
 * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
 *  The PAG operator itself will not appear in the listing unless some sort of error is encountered. 
 * The proper form is:
 *
 * PAG [<expression>]
 *
 * Where the expression is optional. The first page of a listing does not have the header printed on it and 
 * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and  
 * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title, 
 * or subtitle instructions being in the way. 
 */
PagDirective:
	(name = IdentifierValue)? WS (directive = 'PAG') 
	(WS (operand=Expression)?)?
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))? 
	EndOfLine	
;

/*
 * OPT
 * 
 *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
 *  These options are generally related to the format of the output listing and object code. The options which
 *  may be set with this command are listed below. There are several options not listed here which may be set
 *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper 
 * form of this instruction is:
 * 
 * OPT <option 1>,<option 2>,...,<option n>
 *
 * Note that any number of options may be given on one line if separated by commas. No label is allowed and no 
 * spaces may be embedded in the option list. The options are all set during pass one only although the 
 * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are 
 * specified, the last one appearing takes precedence. If a particular option is not specified, the default 
 * case for that option takes effect. The default cases are signified below by an asterisk.
 *
 * The allowable options are:
 * 
 * PAG enable page formatting and numbering
 * NOP* disable pagination
 *
 * CON print conditionally skipped code
 * NOC* suppress conditional code printing
 *
 * MAC* print macro calling lines
 * NOM suppress printing of macro calls
 *
 * EXP print macro expansion lines
 * NOE* Suppress macro expansion printing
 *
 * * denotes default option and is not part of option name 
 */
OptDirective:
	(name = IdentifierValue)? WS (directive = 'OPT')
	(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)? 
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	EndOfLine	
	
;

/*
 * FAIL
 * 
 * 
 */
FailDirective:
	(name = IdentifierValue)? WS (directive = 'FAIL') 
	(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	EndOfLine	
;

/*
 * SET
 * 
 * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
 * The difference is that a symbol may be SET several times within the source (to different values) while 
 * a symbol may be Equated only once. 
 * If a symbol is SET to several values within the source, the current value of the symbol will be 
 * the value last SET. The statement form is:
 *
 * <label> SET <expression>
 *
 * The label is strictly required and no code is generated.  
 */
SetDirective:
	(name = IdentifierValue)? WS (directive = 'SET') 
	WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		)
	WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? 
	EndOfLine	
;

/*
 * FILL
 * 
 * FILL allow to initialize a memory area with a value
 * the first value define the value to set, the seconfd value define the number of byte to set
 */
FillDirective:
	(name = IdentifierValue)? 
	(WS (directive = 'FILL')) 
	(WS value=Expression ',' number=Expression) 
	(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;

/*
 * BSZ
 * 
 * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
 * The operand define the number on byte to reserve
 */
BszDirective:
	(name = IdentifierValue)? WS (directive = ('BSZ'|'ZMB')) 
	(WS operand=Expression) 
	(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;


/*
 *  FDB
 *
 * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
 * It is exactly like the FCB directive except that 16 bit quantities are evaluated 
 * and stored in memory for each expression given. 
 * The form of the statement is:
 *
 * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
 * 
 * Again, the label field is optional. 
 */
FdbDirective:
	(name = IdentifierValue)? WS (directive = 'FDB') 
	(WS (operand = ListOfExpression))? 
	(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? 
	WS? EndOfLine	
;


/*
 *  The FCB or Form Constant Byte directive is used to set associated memory bytes 
 * to some value as determined by the operand. 
 * FCB may be used to set any number of bytes as shown below:
 *
 * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
 *
 * Where <expr. x> stands for some expression. 
 * Each expression given (separated by commas) is evaluated to 8 bits 
 * and the resulting quantities are stored in successive memory locations. 
 * The label is optional. 
 */
FcbDirective:
	(name = IdentifierValue)? WS (directive = 'FCB') (WS (operand = ListOfExpression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;

/*
 *  RMB
 * 
 * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
 * The number of bytes specified by the expression in the operand are skipped during assembly. 
 * No code is produced in those memory location and therefore the contents are undefined at run time.
 *  The proper useage is shown here:
 * 
 * [<label>] RMB <expression>
 *
 * The label is optional, and the expression is a 16 bit quantity.
 */
RmbDirective:
	(name = IdentifierValue)? WS (directive = 'RMB') (WS (isRelativeToPC?='*'? operand = Expression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;

/*
 * The END pseudo-op is used to signal the assembler that the end of the source input has occurred. 
 * This terminates whatever pass is currently being executed. No label is allowed and no code is generated. 
 * An expression may be given (as shown below) as the transfer address to be placed in a binary file. 
 * It is optional, and if supplied when no binary file is being produced, will be ignored.
 *
 *  END [<expression>]
 *
 * Note that an end statement is not strictly required, 
 * but is the only means of getting a transfer address appended to a binary output file.  
 */
EndDirective:
	(name = IdentifierValue)? WS (directive = 'END') 
	(WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		))?
	(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;

/*
 *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
 *
 * 		ORG <expression>
 *		
 *	No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed. 
 */
OrgDirective:
	(name = IdentifierValue)? WS (directive = 'ORG') 
	(WS ( 
		(isRelativeToPC?='*'? operand=Expression) |
		(isRelativeToPC?='*' )
		))?
	WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? 
	EndOfLine	
;

/*
 * Description of an EQU directive
 * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment  
 */
EquDirective:
	(name = IdentifierValue)? WS (directive = 'EQU') 
	WS ( 
		( isRelativeToPC?='*'? operand=Expression) |
		( isRelativeToPC?='*' )
		)
	WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? 
	EndOfLine	
;

ListOfExpression:
	expressions+=Expression (',' expressions+=Expression)*
;

Expression:
		operand = Multiplication;

Multiplication returns Expression:
  	Division ({Multiplication.left=current} operation='*' right=Division)*
;

Division returns Expression:
  	Modulo ({Division.left=current} opretation='/' right=Modulo)*
;

Modulo returns Expression:
	Addition ({Modulo.left=current} opretation='%' right=Addition)*
;

Addition returns Expression:
    Substraction ({Addition.left=current} '+' right=Substraction)*
;

Substraction returns Expression:
    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
;
  
LeftShift returns Expression:
	RightShift ({LeftShift.left=current} '<<' right=RightShift)*
;

RightShift returns Expression:
	And ({RightShift.left=current} '>>' right=And)*
;

And returns Expression:
	Or ({And.left=current} '&&' right=Or)*
;

Or returns Expression:
	Xor ({Or.left=current} '||' right=Xor)*
;

Xor returns Expression:
	Primary ({Xor.left=current} '^' right=Primary)*
;

Primary returns Expression:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
   	|   {Not} '!' value=Primary
  	|  '(' Multiplication ')'
 ;

NumericalValue:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
;

IdentifierValue:
	value = ID
;

StringValue:
	value = STRING
;

DecimalValue:
	sign=('-'|'+')? value = INT
;

HexaDecimalValue:
	value = HEXA
;

OctalValue:
	value = OCTAL
;

BinaryValue:
	value = BINARY
;

CharacterValue:
	value = CHARACTER
;

enum AssemblyOption:
	PAG= 'PAG' |
	NOP= 'NOP' |
	CON= 'CON' |
	NOC= 'NOC' |
	MAC= 'MAC' |
	NOM= 'NOM' |
	EXP= 'EXP' |
	NOE= 'NOE' 
	;

enum Register:
	A = 'A'    |
	B = 'B'	   |
	D = 'D'	   |
	X = 'X'	   |
	Y = 'Y'	   |
	U = 'U'	   |
	S = 'S'	   |
	DP = 'DP'  |
	CC = 'CC'  |
	PC = 'PC'  
;


terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
terminal INT returns ecore::EInt			: ('0'..'9')+;
terminal OCTAL 								: '@'('0'..'7')+;
terminal BINARY 							: '0''b'('0'..'1')+;
terminal CHARACTER							: '\'' ('\u0020'..'\u007F');

EndOfLine: CR | END_OF_FILE;

terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' 
		;		
	
terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
terminal WS         						: (' '|'\t')+;
terminal CR          						: '\r'? '\n';
terminal END_OF_FILE 						: EOF;		
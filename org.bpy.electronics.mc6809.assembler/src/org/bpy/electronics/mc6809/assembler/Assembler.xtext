/*
 * European Scoring Tool For Baseball
 * Copyright (C) 2023  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
grammar org.bpy.electronics.mc6809.assembler.Assembler // with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate assembler "http://www.bpy.org/electronics/mc6809/assembler/Assembler"

/*
 * Entry point of an as9 file
 */
Model:
	sourceLines += SourceLine*
;
	
/*
 * Description of an assembler line.
 * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
 */	
SourceLine:
	(
		  (lineContent = BlankLine)
		| (lineContent = CommentLine) 
		| (lineContent = DirectiveLine)
	) 
;

/*
 * Blanck line is an empty line or a set of space or tabs followed by a end of line
 */
BlankLine:
	{BlankLine} (blankLine = WS)? EndOfLine  
;

/*
 * definition of a comment line
 * A comment line start with a ; following by anything and finish with a end of line 
 */
CommentLine:
	comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine 
;

/*
 * Definition of the list possible directives
 * 	EQU  
 */
DirectiveLine:
	   directive = EquDirective
	|  directive = OrgDirective
	|  directive = EndDirective
;

/*
 * The END pseudo-op is used to signal the assembler that the end of the source input has occurred. 
 * This terminates whatever pass is currently being executed. No label is allowed and no code is generated. 
 * An expression may be given (as shown below) as the transfer address to be placed in a binary file. 
 * It is optional, and if supplied when no binary file is being produced, will be ignored.
 *
 *  END [<expression>]
 *
 * Note that an end statement is not strictly required, 
 * but is the only means of getting a transfer address appended to a binary output file.  
 */
EndDirective:
	(name = IdentifierValue)? WS (directive = 'END') (WS (operand = Expression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine	
;

/*
 *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
 *
 * 		ORG <expression>
 *		
 *	No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed. 
 */
OrgDirective:
	(name = IdentifierValue)? WS (directive = 'ORG') (WS (operand = Expression))? (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))? WS? EndOfLine		
;

/*
 * Description of an EQU directive
 * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment  
 */
EquDirective:
	(name = IdentifierValue)? WS (directive = 'EQU') WS (operand = Expression)? WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? EndOfLine	
;


Expression:
		operand = Multiplication;

Multiplication returns Expression:
  	Division ({Multiplication.left=current} operation='*' right=Division)*
;

Division returns Expression:
  	Modulo ({Division.left=current} opretation='/' right=Modulo)*
;

Modulo returns Expression:
	Addition ({Modulo.left=current} opretation='%' right=Addition)*
;

Addition returns Expression:
    Substraction ({Addition.left=current} '+' right=Substraction)*
;

Substraction returns Expression:
    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
;
  
LeftShift returns Expression:
	RightShift ({LeftShift.left=current} '<<' right=RightShift)*
;

RightShift returns Expression:
	And ({RightShift.left=current} '>>' right=And)*
;

And returns Expression:
	Or ({And.left=current} '&&' right=Or)*
;

Or returns Expression:
	Xor ({Or.left=current} '||' right=Xor)*
;

Xor returns Expression:
	Primary ({Xor.left=current} '^' right=Primary)*
;

Primary returns Expression:
   	 	value=DecimalValue
  	|	value=HexaDecimalValue
  	|	value=OctalValue
  	|   value=BinaryValue
  	|   value=CharacterValue
   	|	value=IdentifierValue
   	|   {Not} '!' value=Primary
  	|  '(' Multiplication ')'
 ;

IdentifierValue:
	value = ID
;

StringValue:
	value = STRING
;

DecimalValue:
	isNegative?='-'? value = INT
;

HexaDecimalValue:
	value = HEXA
;

OctalValue:
	value = OCTAL
;

BinaryValue:
	value = BINARY
;

CharacterValue:
	value = CHARACTER
;

terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
terminal INT returns ecore::EInt			: ('0'..'9')+;
terminal OCTAL 								: '@'('0'..'7')+;
terminal BINARY 							: '0''b'('0'..'1')+;
terminal CHARACTER							: '\'' ('\u0020'..'\u007F');

EndOfLine: CR | END_OF_FILE;

terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* 
		;		
	
terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
terminal WS         						: (' '|'\t')+;
terminal CR          						: '\r'? '\n';
terminal END_OF_FILE 						: EOF;		
/*
 * generated by Xtext 2.28.0
 */
package org.bpy.electronics.mc6809.assembler.formatting2

import com.google.inject.Inject
import org.bpy.electronics.mc6809.assembler.assembler.Model
import org.bpy.electronics.mc6809.assembler.assembler.SourceLine
import org.bpy.electronics.mc6809.assembler.services.AssemblerGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.bpy.electronics.mc6809.assembler.assembler.CommentLine
import org.bpy.electronics.mc6809.assembler.assembler.AssemblerPackage
import org.bpy.electronics.mc6809.preferences.core.PreferenceManager
import com.google.common.base.Strings
import org.eclipse.xtext.formatting2.IHiddenRegionFormatting
import org.eclipse.xtext.formatting2.internal.HiddenRegionFormatting
import org.bpy.electronics.mc6809.assembler.assembler.LabelLine
import org.bpy.electronics.mc6809.assembler.assembler.Label
import org.bpy.electronics.mc6809.assembler.assembler.InstructionLine

class AssemblerFormatter extends AbstractFormatter2 {
	
	@Inject extension AssemblerGrammarAccess
	
	PreferenceManager preferenceManager
	
	String tabPolicy
	
	int tabSize
	
	int instructionPosition
	
	int operandPosition
	
	int commentPosition

	def dispatch void format(Model model, extension IFormattableDocument document) {
		
		preferenceManager = PreferenceManager.instance
		tabPolicy = preferenceManager.getStringPreferenceValue(PreferenceManager::TAB_POLICY)
		tabSize = preferenceManager.getIntPreferenceValue(PreferenceManager::TAB_SIZE)
		instructionPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::INSTRUCTION_POSITION)
		operandPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::OPERAND_POSITION)
		commentPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::COMMENT_POSITION)

		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (sourceLine : model.sourceLines) {
			sourceLine.format
		}
	}

	def dispatch void format(SourceLine sourceLine, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		sourceLine.lineContent.format
	}
	
	def dispatch void format(CommentLine commentLine, extension IFormattableDocument document) {
		
		if (commentLine.startingSpace !== null) {

			if (PreferenceManager::SPACE_ONLY == tabPolicy) {
				val fmt = document.formatter.createHiddenRegionFormatting => [ it.space = " " ]
				val replacer = commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__STARTING_SPACE).createWhitespaceReplacer(fmt)
				document.addReplacer(replacer)

				val strPosition = Strings.repeat(' ', commentPosition-1)
				commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__COMMENT).prepend[space = strPosition]
			
			} else if (PreferenceManager::TAB_ONLY == tabPolicy) {
				
			} else {
				
			}
		}	
	}
	
	def dispatch void format(LabelLine labelLine, extension IFormattableDocument document) {
		if (labelLine.comment !== null) {
			
			if (PreferenceManager::SPACE_ONLY == tabPolicy) {
				var wsSpace=0
				if (labelLine.ws1 !== null) {
					val fmt = document.formatter.createHiddenRegionFormatting => [ it.space = " " ]
					val replacer = labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__WS1).createWhitespaceReplacer(fmt)
					document.addReplacer(replacer)
					wsSpace=1
				}

				var labelLength = labelLine.label.name.value.length + wsSpace
				if (labelLine.label.point) {
					labelLength++
				}
				val strPosition = Strings.repeat(' ', commentPosition-labelLength-1)
				labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__COMMENT).prepend[space = strPosition]
			
			} else if (PreferenceManager::TAB_ONLY == tabPolicy) {
				
			} else {
				
			}
		}
	}

	def dispatch void format(InstructionLine instructionLine, extension IFormattableDocument document) {
		if (PreferenceManager::SPACE_ONLY == tabPolicy) {
			var wsSpace=0
			if (instructionLine.ws1 !== null) {
					val fmt = document.formatter.createHiddenRegionFormatting => [ it.space = " " ]
					val replacer = instructionLine.regionFor.feature(AssemblerPackage.Literals.INSTRUCTION_LINE__WS1).createWhitespaceReplacer(fmt)
					document.addReplacer(replacer)
					wsSpace=1
			}
			if (instructionLine.ws2 !== null) {
					val fmt = document.formatter.createHiddenRegionFormatting => [ it.space = " " ]
					val replacer = instructionLine.regionFor.feature(AssemblerPackage.Literals.INSTRUCTION_LINE__WS2).createWhitespaceReplacer(fmt)
					document.addReplacer(replacer)
					wsSpace++
			}

			var labelLength = instructionLine.label.name.value.length + wsSpace
			if (instructionLine.label.point) {
					labelLength++
			}

		}
	}
	// TODO: implement for InstructionLine, TstInstruction, SubdInstruction, SubInstruction, StInstruction, SbcInstruction, RorInstruction, RolInstruction, PuluInstruction, PulsInstruction, PshuInstruction, PshsInstruction, OrCCInstruction, OrInstruction, NegInstruction, LsrInstruction, LslInstruction, LeaInstruction, LdInstruction, JsrInstruction, JmpInstruction, IncInstruction, EorInstruction, DecInstruction, CwaiInstruction, ComInstruction, CmpInstruction, ClrInstruction, BvsInstruction, BvcInstruction, BsrInstruction, BrnInstruction, BraInstruction, BplInstruction, BneInstruction, BmiInstruction, BltInstruction, BlsInstruction, BloInstruction, BleInstruction, BitInstruction, BhsInstruction, BhiInstruction, BgtInstruction, BgeInstruction, BeqInstruction, BcsInstruction, BccInstruction, AsrInstruction, AslInstruction, AndCCInstruction, AndInstruction, AdddInstruction, AddInstruction, AdcInstruction, ExtendedIndirectOperand, ExtendedOperand, DirectOperand, ImmediatOperand, IndexedOperand, ConstantIndexedMode, ConstantIndexedMovingIndirectMode, RelatifToPCMode, RelatifToPCIndirectMode, RelativeMode, DirectiveLine, SetDPDirective, SpcDirective, NamDirective, PagDirective, SetDirective, FillDirective, BszDirective, FdbDirective, FcbDirective, RmbDirective, EndDirective, OrgDirective, EquDirective, ListOfExpression, CommaExpression, Expression, Multiplication, Division, Modulo, Addition, Substraction, LeftShift, RightShift, And, Or, Xor, Not, NumericalValue
}

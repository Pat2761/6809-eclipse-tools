/*
 * generated by Xtext 2.28.0
 */
package org.bpy.electronics.mc6809.assembler.formatting2

import com.google.inject.Inject
import org.bpy.electronics.mc6809.assembler.assembler.Model
import org.bpy.electronics.mc6809.assembler.assembler.SourceLine
import org.bpy.electronics.mc6809.assembler.services.AssemblerGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.bpy.electronics.mc6809.assembler.assembler.CommentLine
import org.bpy.electronics.mc6809.assembler.assembler.AssemblerPackage
import org.bpy.electronics.mc6809.preferences.core.PreferenceManager
import com.google.common.base.Strings
import org.bpy.electronics.mc6809.assembler.assembler.LabelLine
import org.bpy.electronics.mc6809.assembler.assembler.InstructionLine

class AssemblerFormatter extends AbstractFormatter2 {

	/** Reference on grammar acces */
	@Inject extension AssemblerGrammarAccess

	/** Reference on the preference manager */
	PreferenceManager preferenceManager

	/** Current value of the tab policy */
	String tabPolicy

	/** Current value of the tab size */
	int tabSize

	/** Current column value of the instruction */
	int instructionPosition

	/** Current column value of the operand */
	int operandPosition

	/** Current column value of the comment */
	int commentPosition

	/**
	 * Allow to initialize the formatter.
	 * read formatter preference
	 * call formatter for all children of the model 
	 * 
	 */
	def dispatch void format(Model model, extension IFormattableDocument document) {

		preferenceManager = PreferenceManager.instance
		tabPolicy = preferenceManager.getStringPreferenceValue(PreferenceManager::TAB_POLICY)
		tabSize = preferenceManager.getIntPreferenceValue(PreferenceManager::TAB_SIZE)
		instructionPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::INSTRUCTION_POSITION)
		operandPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::OPERAND_POSITION)
		commentPosition = preferenceManager.getIntPreferenceValue(PreferenceManager::COMMENT_POSITION)

		for (sourceLine : model.sourceLines) {
			sourceLine.format
		}
	}

	/** 
	 * Call the formatter for a source line
	 */
	def dispatch void format(SourceLine sourceLine, extension IFormattableDocument document) {
		sourceLine.lineContent.format
	}

	/** 
	 * Call the formatter for a line which start with space and contains only a comment
	 */
	def dispatch void format(CommentLine commentLine, extension IFormattableDocument document) {
		if (commentLine.startingSpace !== null) {

			if (PreferenceManager::SPACE_ONLY == tabPolicy) {
				commentLine.formatSpaceOnly(document)
				
			} else if (PreferenceManager::TAB_ONLY == tabPolicy) {
				commentLine.formatTabOnly(document)

			} else {
				commentLine.formatMixed(document)

			}
		}
	}

	/**
	 * Format a comment line when the tab policy is Space only
	 */
	def private void formatSpaceOnly(CommentLine commentLine, extension IFormattableDocument document) {
		val fmt = document.formatter.createHiddenRegionFormatting => [it.space = " "]
		val replacer = commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__STARTING_SPACE).
			createWhitespaceReplacer(fmt)
		document.addReplacer(replacer)

		val strPosition = Strings.repeat(' ', commentPosition - 1)
		commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__COMMENT).prepend [
			space = strPosition
		]
	}

	/**
	 * Format a comment line when the tab policy is Tab only
	 */
	def private void formatTabOnly(CommentLine commentLine, extension IFormattableDocument document) {
		val nbTabs = commentPosition/tabSize  

		val fmt = document.formatter.createHiddenRegionFormatting => [it.space = "\t"]
		val replacer = commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__STARTING_SPACE).
			createWhitespaceReplacer(fmt)
		document.addReplacer(replacer)

		val strPosition = Strings.repeat('\t', nbTabs - 1)
		commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__COMMENT).prepend [
			space = strPosition
		]
	}

	/**
	 * Format a comment line when the tab policy is a mixed of space and tab
	 */
	def private void formatMixed(CommentLine commentLine, extension IFormattableDocument document) {
		val nbTabs = commentPosition/tabSize  
		val nbSpaces = commentPosition - (tabSize*nbTabs);

		val fmt = document.formatter.createHiddenRegionFormatting => [it.space = "\t"]
		val replacer = commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__STARTING_SPACE).
			createWhitespaceReplacer(fmt)
		document.addReplacer(replacer)

		var strPosition = Strings.repeat('\t', nbTabs - 1)
		if (nbSpaces !== 0) {
			strPosition += Strings.repeat(' ', nbSpaces) 
		}
		
		val spaces = strPosition
		commentLine.regionFor.feature(AssemblerPackage.Literals.COMMENT_LINE__COMMENT).prepend [
			space = spaces
		]
	}

	/** 
	 * Call the formatter for a line which start with a label and contains only comments
	 */
	def dispatch void format(LabelLine labelLine, extension IFormattableDocument document) {
		if (labelLine.comment !== null) {

			if (PreferenceManager::SPACE_ONLY == tabPolicy) {
				labelLine.formatSpaceOnly(document)

			} else if (PreferenceManager::TAB_ONLY == tabPolicy) {
				labelLine.formatTabOnly(document)

			} else {
				labelLine.formatMixed(document)
			}
		}
	}

	def private void formatMixed(LabelLine labelLine, extension IFormattableDocument document) {
	}

	def private void formatTabOnly(LabelLine labelLine, extension IFormattableDocument document) {
		var wsSpace = 0
		if (labelLine.ws1 !== null) {
			val fmt = document.formatter.createHiddenRegionFormatting => [it.space = " "]
			val replacer = labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__WS1).
				createWhitespaceReplacer(fmt)
			document.addReplacer(replacer)
			wsSpace = 1
		}

		var labelLength = labelLine.label.name.value.length + wsSpace
		if (labelLine.label.point) {
			labelLength++
		}
		val strPosition = Strings.repeat(' ', commentPosition - labelLength - 1)
		labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__COMMENT).prepend[space = strPosition]
	}

	def private void formatSpaceOnly(LabelLine labelLine, extension IFormattableDocument document) {
		var wsSpace = 0
		if (labelLine.ws1 !== null) {
			val fmt = document.formatter.createHiddenRegionFormatting => [it.space = " "]
			val replacer = labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__WS1).
				createWhitespaceReplacer(fmt)
			document.addReplacer(replacer)
			wsSpace = 1
		}

		var labelLength = labelLine.label.name.value.length + wsSpace
		if (labelLine.label.point) {
			labelLength++
		}
		val strPosition = Strings.repeat(' ', commentPosition - labelLength - 1)
		labelLine.regionFor.feature(AssemblerPackage.Literals.LABEL_LINE__COMMENT).prepend[space = strPosition]
	}

	def dispatch void format(InstructionLine instructionLine, extension IFormattableDocument document) {
		if (PreferenceManager::SPACE_ONLY == tabPolicy) {
			var wsSpace = 0
			if (instructionLine.ws1 !== null) {
				val fmt = document.formatter.createHiddenRegionFormatting => [it.space = " "]
				val replacer = instructionLine.regionFor.feature(AssemblerPackage.Literals.INSTRUCTION_LINE__WS1).
					createWhitespaceReplacer(fmt)
				document.addReplacer(replacer)
				wsSpace = 1
			}
			if (instructionLine.ws2 !== null) {
				val fmt = document.formatter.createHiddenRegionFormatting => [it.space = " "]
				val replacer = instructionLine.regionFor.feature(AssemblerPackage.Literals.INSTRUCTION_LINE__WS2).
					createWhitespaceReplacer(fmt)
				document.addReplacer(replacer)
				wsSpace++
			}

			var labelLength = instructionLine.label.name.value.length + wsSpace
			if (instructionLine.label.point) {
				labelLength++
			}

		}
	}
// TODO: implement for InstructionLine, TstInstruction, SubdInstruction, SubInstruction, StInstruction, SbcInstruction, RorInstruction, RolInstruction, PuluInstruction, PulsInstruction, PshuInstruction, PshsInstruction, OrCCInstruction, OrInstruction, NegInstruction, LsrInstruction, LslInstruction, LeaInstruction, LdInstruction, JsrInstruction, JmpInstruction, IncInstruction, EorInstruction, DecInstruction, CwaiInstruction, ComInstruction, CmpInstruction, ClrInstruction, BvsInstruction, BvcInstruction, BsrInstruction, BrnInstruction, BraInstruction, BplInstruction, BneInstruction, BmiInstruction, BltInstruction, BlsInstruction, BloInstruction, BleInstruction, BitInstruction, BhsInstruction, BhiInstruction, BgtInstruction, BgeInstruction, BeqInstruction, BcsInstruction, BccInstruction, AsrInstruction, AslInstruction, AndCCInstruction, AndInstruction, AdddInstruction, AddInstruction, AdcInstruction, ExtendedIndirectOperand, ExtendedOperand, DirectOperand, ImmediatOperand, IndexedOperand, ConstantIndexedMode, ConstantIndexedMovingIndirectMode, RelatifToPCMode, RelatifToPCIndirectMode, RelativeMode, DirectiveLine, SetDPDirective, SpcDirective, NamDirective, PagDirective, SetDirective, FillDirective, BszDirective, FdbDirective, FcbDirective, RmbDirective, EndDirective, OrgDirective, EquDirective, ListOfExpression, CommaExpression, Expression, Multiplication, Division, Modulo, Addition, Substraction, LeftShift, RightShift, And, Or, Xor, Not, NumericalValue
}

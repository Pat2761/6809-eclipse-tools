/*
 * generated by Xtext 2.29.0
 */
package org.bpy.electronics.mc6809.assembler.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class AssemblerGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Model");
		private final Assignment cSourceLinesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSourceLinesSourceLineParserRuleCall_0 = (RuleCall)cSourceLinesAssignment.eContents().get(0);
		
		///*
		// * Entry point of an as9 file
		// */
		//Model:
		//    sourceLines += SourceLine*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sourceLines += SourceLine*
		public Assignment getSourceLinesAssignment() { return cSourceLinesAssignment; }
		
		//SourceLine
		public RuleCall getSourceLinesSourceLineParserRuleCall_0() { return cSourceLinesSourceLineParserRuleCall_0; }
	}
	public class SourceLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SourceLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLineContentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cLineContentBlankLineParserRuleCall_0_0 = (RuleCall)cLineContentAssignment_0.eContents().get(0);
		private final Assignment cLineContentAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLineContentCommentLineParserRuleCall_1_0 = (RuleCall)cLineContentAssignment_1.eContents().get(0);
		private final Assignment cLineContentAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cLineContentDirectiveLineParserRuleCall_2_0 = (RuleCall)cLineContentAssignment_2.eContents().get(0);
		private final Assignment cLineContentAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cLineContentInstructionLineParserRuleCall_3_0 = (RuleCall)cLineContentAssignment_3.eContents().get(0);
		
		///*
		// * Description of an assembler line.
		// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
		// */
		//SourceLine:
		//    (
		//          (lineContent = BlankLine)
		//        | (lineContent = CommentLine)
		//        | (lineContent = DirectiveLine)
		//        | (lineContent = InstructionLine)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//      (lineContent = BlankLine)
		//    | (lineContent = CommentLine)
		//    | (lineContent = DirectiveLine)
		//    | (lineContent = InstructionLine)
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(lineContent = BlankLine)
		public Assignment getLineContentAssignment_0() { return cLineContentAssignment_0; }
		
		//BlankLine
		public RuleCall getLineContentBlankLineParserRuleCall_0_0() { return cLineContentBlankLineParserRuleCall_0_0; }
		
		//(lineContent = CommentLine)
		public Assignment getLineContentAssignment_1() { return cLineContentAssignment_1; }
		
		//CommentLine
		public RuleCall getLineContentCommentLineParserRuleCall_1_0() { return cLineContentCommentLineParserRuleCall_1_0; }
		
		//(lineContent = DirectiveLine)
		public Assignment getLineContentAssignment_2() { return cLineContentAssignment_2; }
		
		//DirectiveLine
		public RuleCall getLineContentDirectiveLineParserRuleCall_2_0() { return cLineContentDirectiveLineParserRuleCall_2_0; }
		
		//(lineContent = InstructionLine)
		public Assignment getLineContentAssignment_3() { return cLineContentAssignment_3; }
		
		//InstructionLine
		public RuleCall getLineContentInstructionLineParserRuleCall_3_0() { return cLineContentInstructionLineParserRuleCall_3_0; }
	}
	public class BlankLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BlankLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlankLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBlankLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlankLineWSTerminalRuleCall_1_0 = (RuleCall)cBlankLineAssignment_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		///*
		// * Blanck line is an empty line or a set of space or tabs followed by a end of line
		// */
		//BlankLine:
		//    {BlankLine} (blankLine = WS)? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{BlankLine} (blankLine = WS)? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//{BlankLine}
		public Action getBlankLineAction_0() { return cBlankLineAction_0; }
		
		//(blankLine = WS)?
		public Assignment getBlankLineAssignment_1() { return cBlankLineAssignment_1; }
		
		//WS
		public RuleCall getBlankLineWSTerminalRuleCall_1_0() { return cBlankLineWSTerminalRuleCall_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_2() { return cEndOfLineParserRuleCall_2; }
	}
	public class CommentLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CommentLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStartingSpaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStartingSpaceWSTerminalRuleCall_1_0 = (RuleCall)cStartingSpaceAssignment_1.eContents().get(0);
		private final Assignment cCommentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_2_0 = (RuleCall)cCommentAssignment_2.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		///*
		// * definition of a comment line
		// * A comment line start with a ; following by anything and finish with a end of line
		// */
		//CommentLine:
		//    {CommentLine}
		//    startingSpace = WS? comment=ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{CommentLine}
		//startingSpace = WS? comment=ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		public Group getGroup() { return cGroup; }
		
		//{CommentLine}
		public Action getCommentLineAction_0() { return cCommentLineAction_0; }
		
		//startingSpace = WS?
		public Assignment getStartingSpaceAssignment_1() { return cStartingSpaceAssignment_1; }
		
		//WS
		public RuleCall getStartingSpaceWSTerminalRuleCall_1_0() { return cStartingSpaceWSTerminalRuleCall_1_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_2() { return cCommentAssignment_2; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_2_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_2_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_3() { return cEndOfLineParserRuleCall_3; }
	}
	public class InstructionLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.InstructionLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cInstructionAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cInstructionAbxInstructionParserRuleCall_2_0_0 = (RuleCall)cInstructionAssignment_2_0.eContents().get(0);
		private final Assignment cInstructionAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cInstructionAdcInstructionParserRuleCall_2_1_0 = (RuleCall)cInstructionAssignment_2_1.eContents().get(0);
		private final Assignment cInstructionAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cInstructionAddInstructionParserRuleCall_2_2_0 = (RuleCall)cInstructionAssignment_2_2.eContents().get(0);
		private final Assignment cInstructionAssignment_2_3 = (Assignment)cAlternatives_2.eContents().get(3);
		private final RuleCall cInstructionAdddInstructionParserRuleCall_2_3_0 = (RuleCall)cInstructionAssignment_2_3.eContents().get(0);
		private final Assignment cInstructionAssignment_2_4 = (Assignment)cAlternatives_2.eContents().get(4);
		private final RuleCall cInstructionAndInstructionParserRuleCall_2_4_0 = (RuleCall)cInstructionAssignment_2_4.eContents().get(0);
		private final Assignment cInstructionAssignment_2_5 = (Assignment)cAlternatives_2.eContents().get(5);
		private final RuleCall cInstructionAndCCInstructionParserRuleCall_2_5_0 = (RuleCall)cInstructionAssignment_2_5.eContents().get(0);
		private final Assignment cInstructionAssignment_2_6 = (Assignment)cAlternatives_2.eContents().get(6);
		private final RuleCall cInstructionAslInstructionParserRuleCall_2_6_0 = (RuleCall)cInstructionAssignment_2_6.eContents().get(0);
		private final Assignment cInstructionAssignment_2_7 = (Assignment)cAlternatives_2.eContents().get(7);
		private final RuleCall cInstructionAsrInstructionParserRuleCall_2_7_0 = (RuleCall)cInstructionAssignment_2_7.eContents().get(0);
		private final Assignment cInstructionAssignment_2_8 = (Assignment)cAlternatives_2.eContents().get(8);
		private final RuleCall cInstructionBccInstructionParserRuleCall_2_8_0 = (RuleCall)cInstructionAssignment_2_8.eContents().get(0);
		private final Assignment cInstructionAssignment_2_9 = (Assignment)cAlternatives_2.eContents().get(9);
		private final RuleCall cInstructionBcsInstructionParserRuleCall_2_9_0 = (RuleCall)cInstructionAssignment_2_9.eContents().get(0);
		private final Assignment cInstructionAssignment_2_10 = (Assignment)cAlternatives_2.eContents().get(10);
		private final RuleCall cInstructionBeqInstructionParserRuleCall_2_10_0 = (RuleCall)cInstructionAssignment_2_10.eContents().get(0);
		private final Assignment cInstructionAssignment_2_11 = (Assignment)cAlternatives_2.eContents().get(11);
		private final RuleCall cInstructionBgeInstructionParserRuleCall_2_11_0 = (RuleCall)cInstructionAssignment_2_11.eContents().get(0);
		private final Assignment cInstructionAssignment_2_12 = (Assignment)cAlternatives_2.eContents().get(12);
		private final RuleCall cInstructionBgtInstructionParserRuleCall_2_12_0 = (RuleCall)cInstructionAssignment_2_12.eContents().get(0);
		private final Assignment cInstructionAssignment_2_13 = (Assignment)cAlternatives_2.eContents().get(13);
		private final RuleCall cInstructionBhiInstructionParserRuleCall_2_13_0 = (RuleCall)cInstructionAssignment_2_13.eContents().get(0);
		private final Assignment cInstructionAssignment_2_14 = (Assignment)cAlternatives_2.eContents().get(14);
		private final RuleCall cInstructionBhsInstructionParserRuleCall_2_14_0 = (RuleCall)cInstructionAssignment_2_14.eContents().get(0);
		private final Assignment cInstructionAssignment_2_15 = (Assignment)cAlternatives_2.eContents().get(15);
		private final RuleCall cInstructionBitInstructionParserRuleCall_2_15_0 = (RuleCall)cInstructionAssignment_2_15.eContents().get(0);
		private final Assignment cInstructionAssignment_2_16 = (Assignment)cAlternatives_2.eContents().get(16);
		private final RuleCall cInstructionBleInstructionParserRuleCall_2_16_0 = (RuleCall)cInstructionAssignment_2_16.eContents().get(0);
		private final Assignment cInstructionAssignment_2_17 = (Assignment)cAlternatives_2.eContents().get(17);
		private final RuleCall cInstructionBloInstructionParserRuleCall_2_17_0 = (RuleCall)cInstructionAssignment_2_17.eContents().get(0);
		private final Assignment cInstructionAssignment_2_18 = (Assignment)cAlternatives_2.eContents().get(18);
		private final RuleCall cInstructionBlsInstructionParserRuleCall_2_18_0 = (RuleCall)cInstructionAssignment_2_18.eContents().get(0);
		private final Assignment cInstructionAssignment_2_19 = (Assignment)cAlternatives_2.eContents().get(19);
		private final RuleCall cInstructionBltInstructionParserRuleCall_2_19_0 = (RuleCall)cInstructionAssignment_2_19.eContents().get(0);
		private final Assignment cInstructionAssignment_2_20 = (Assignment)cAlternatives_2.eContents().get(20);
		private final RuleCall cInstructionBmiInstructionParserRuleCall_2_20_0 = (RuleCall)cInstructionAssignment_2_20.eContents().get(0);
		private final Assignment cInstructionAssignment_2_21 = (Assignment)cAlternatives_2.eContents().get(21);
		private final RuleCall cInstructionBneInstructionParserRuleCall_2_21_0 = (RuleCall)cInstructionAssignment_2_21.eContents().get(0);
		private final Assignment cInstructionAssignment_2_22 = (Assignment)cAlternatives_2.eContents().get(22);
		private final RuleCall cInstructionBplInstructionParserRuleCall_2_22_0 = (RuleCall)cInstructionAssignment_2_22.eContents().get(0);
		private final Assignment cInstructionAssignment_2_23 = (Assignment)cAlternatives_2.eContents().get(23);
		private final RuleCall cInstructionBraInstructionParserRuleCall_2_23_0 = (RuleCall)cInstructionAssignment_2_23.eContents().get(0);
		private final Assignment cInstructionAssignment_2_24 = (Assignment)cAlternatives_2.eContents().get(24);
		private final RuleCall cInstructionBrnInstructionParserRuleCall_2_24_0 = (RuleCall)cInstructionAssignment_2_24.eContents().get(0);
		private final Assignment cInstructionAssignment_2_25 = (Assignment)cAlternatives_2.eContents().get(25);
		private final RuleCall cInstructionBsrInstructionParserRuleCall_2_25_0 = (RuleCall)cInstructionAssignment_2_25.eContents().get(0);
		private final Assignment cInstructionAssignment_2_26 = (Assignment)cAlternatives_2.eContents().get(26);
		private final RuleCall cInstructionBvcInstructionParserRuleCall_2_26_0 = (RuleCall)cInstructionAssignment_2_26.eContents().get(0);
		private final Assignment cInstructionAssignment_2_27 = (Assignment)cAlternatives_2.eContents().get(27);
		private final RuleCall cInstructionBvsInstructionParserRuleCall_2_27_0 = (RuleCall)cInstructionAssignment_2_27.eContents().get(0);
		private final Assignment cInstructionAssignment_2_28 = (Assignment)cAlternatives_2.eContents().get(28);
		private final RuleCall cInstructionClrInstructionParserRuleCall_2_28_0 = (RuleCall)cInstructionAssignment_2_28.eContents().get(0);
		private final Assignment cInstructionAssignment_2_29 = (Assignment)cAlternatives_2.eContents().get(29);
		private final RuleCall cInstructionCmpInstructionParserRuleCall_2_29_0 = (RuleCall)cInstructionAssignment_2_29.eContents().get(0);
		private final Assignment cInstructionAssignment_2_30 = (Assignment)cAlternatives_2.eContents().get(30);
		private final RuleCall cInstructionComInstructionParserRuleCall_2_30_0 = (RuleCall)cInstructionAssignment_2_30.eContents().get(0);
		private final Assignment cInstructionAssignment_2_31 = (Assignment)cAlternatives_2.eContents().get(31);
		private final RuleCall cInstructionCwaiInstructionParserRuleCall_2_31_0 = (RuleCall)cInstructionAssignment_2_31.eContents().get(0);
		private final Assignment cInstructionAssignment_2_32 = (Assignment)cAlternatives_2.eContents().get(32);
		private final RuleCall cInstructionDaaInstructionParserRuleCall_2_32_0 = (RuleCall)cInstructionAssignment_2_32.eContents().get(0);
		private final Assignment cInstructionAssignment_2_33 = (Assignment)cAlternatives_2.eContents().get(33);
		private final RuleCall cInstructionDecInstructionParserRuleCall_2_33_0 = (RuleCall)cInstructionAssignment_2_33.eContents().get(0);
		private final Assignment cInstructionAssignment_2_34 = (Assignment)cAlternatives_2.eContents().get(34);
		private final RuleCall cInstructionEorInstructionParserRuleCall_2_34_0 = (RuleCall)cInstructionAssignment_2_34.eContents().get(0);
		private final Assignment cInstructionAssignment_2_35 = (Assignment)cAlternatives_2.eContents().get(35);
		private final RuleCall cInstructionExgInstructionParserRuleCall_2_35_0 = (RuleCall)cInstructionAssignment_2_35.eContents().get(0);
		private final Assignment cInstructionAssignment_2_36 = (Assignment)cAlternatives_2.eContents().get(36);
		private final RuleCall cInstructionIncInstructionParserRuleCall_2_36_0 = (RuleCall)cInstructionAssignment_2_36.eContents().get(0);
		private final Assignment cInstructionAssignment_2_37 = (Assignment)cAlternatives_2.eContents().get(37);
		private final RuleCall cInstructionJmpInstructionParserRuleCall_2_37_0 = (RuleCall)cInstructionAssignment_2_37.eContents().get(0);
		private final Assignment cInstructionAssignment_2_38 = (Assignment)cAlternatives_2.eContents().get(38);
		private final RuleCall cInstructionJsrInstructionParserRuleCall_2_38_0 = (RuleCall)cInstructionAssignment_2_38.eContents().get(0);
		private final Assignment cInstructionAssignment_2_39 = (Assignment)cAlternatives_2.eContents().get(39);
		private final RuleCall cInstructionLd8InstructionParserRuleCall_2_39_0 = (RuleCall)cInstructionAssignment_2_39.eContents().get(0);
		private final Assignment cInstructionAssignment_2_40 = (Assignment)cAlternatives_2.eContents().get(40);
		private final RuleCall cInstructionLd16InstructionParserRuleCall_2_40_0 = (RuleCall)cInstructionAssignment_2_40.eContents().get(0);
		private final Assignment cInstructionAssignment_2_41 = (Assignment)cAlternatives_2.eContents().get(41);
		private final RuleCall cInstructionLeaInstructionParserRuleCall_2_41_0 = (RuleCall)cInstructionAssignment_2_41.eContents().get(0);
		private final Assignment cInstructionAssignment_2_42 = (Assignment)cAlternatives_2.eContents().get(42);
		private final RuleCall cInstructionLslInstructionParserRuleCall_2_42_0 = (RuleCall)cInstructionAssignment_2_42.eContents().get(0);
		private final Assignment cInstructionAssignment_2_43 = (Assignment)cAlternatives_2.eContents().get(43);
		private final RuleCall cInstructionLsrInstructionParserRuleCall_2_43_0 = (RuleCall)cInstructionAssignment_2_43.eContents().get(0);
		private final Assignment cInstructionAssignment_2_44 = (Assignment)cAlternatives_2.eContents().get(44);
		private final RuleCall cInstructionMulInstructionParserRuleCall_2_44_0 = (RuleCall)cInstructionAssignment_2_44.eContents().get(0);
		private final Assignment cInstructionAssignment_2_45 = (Assignment)cAlternatives_2.eContents().get(45);
		private final RuleCall cInstructionNegInstructionParserRuleCall_2_45_0 = (RuleCall)cInstructionAssignment_2_45.eContents().get(0);
		private final Assignment cInstructionAssignment_2_46 = (Assignment)cAlternatives_2.eContents().get(46);
		private final RuleCall cInstructionNopInstructionParserRuleCall_2_46_0 = (RuleCall)cInstructionAssignment_2_46.eContents().get(0);
		private final Assignment cInstructionAssignment_2_47 = (Assignment)cAlternatives_2.eContents().get(47);
		private final RuleCall cInstructionOrInstructionParserRuleCall_2_47_0 = (RuleCall)cInstructionAssignment_2_47.eContents().get(0);
		private final Assignment cInstructionAssignment_2_48 = (Assignment)cAlternatives_2.eContents().get(48);
		private final RuleCall cInstructionOrccInstructionParserRuleCall_2_48_0 = (RuleCall)cInstructionAssignment_2_48.eContents().get(0);
		private final Assignment cInstructionAssignment_2_49 = (Assignment)cAlternatives_2.eContents().get(49);
		private final RuleCall cInstructionPshsInstructionParserRuleCall_2_49_0 = (RuleCall)cInstructionAssignment_2_49.eContents().get(0);
		private final Assignment cInstructionAssignment_2_50 = (Assignment)cAlternatives_2.eContents().get(50);
		private final RuleCall cInstructionPshuInstructionParserRuleCall_2_50_0 = (RuleCall)cInstructionAssignment_2_50.eContents().get(0);
		private final Assignment cInstructionAssignment_2_51 = (Assignment)cAlternatives_2.eContents().get(51);
		private final RuleCall cInstructionPulsInstructionParserRuleCall_2_51_0 = (RuleCall)cInstructionAssignment_2_51.eContents().get(0);
		private final Assignment cInstructionAssignment_2_52 = (Assignment)cAlternatives_2.eContents().get(52);
		private final RuleCall cInstructionPuluInstructionParserRuleCall_2_52_0 = (RuleCall)cInstructionAssignment_2_52.eContents().get(0);
		private final Assignment cInstructionAssignment_2_53 = (Assignment)cAlternatives_2.eContents().get(53);
		private final RuleCall cInstructionRolInstructionParserRuleCall_2_53_0 = (RuleCall)cInstructionAssignment_2_53.eContents().get(0);
		private final Assignment cInstructionAssignment_2_54 = (Assignment)cAlternatives_2.eContents().get(54);
		private final RuleCall cInstructionRorInstructionParserRuleCall_2_54_0 = (RuleCall)cInstructionAssignment_2_54.eContents().get(0);
		private final Assignment cInstructionAssignment_2_55 = (Assignment)cAlternatives_2.eContents().get(55);
		private final RuleCall cInstructionRtiInstructionParserRuleCall_2_55_0 = (RuleCall)cInstructionAssignment_2_55.eContents().get(0);
		private final Assignment cInstructionAssignment_2_56 = (Assignment)cAlternatives_2.eContents().get(56);
		private final RuleCall cInstructionRtsInstructionParserRuleCall_2_56_0 = (RuleCall)cInstructionAssignment_2_56.eContents().get(0);
		private final Assignment cInstructionAssignment_2_57 = (Assignment)cAlternatives_2.eContents().get(57);
		private final RuleCall cInstructionSbcInstructionParserRuleCall_2_57_0 = (RuleCall)cInstructionAssignment_2_57.eContents().get(0);
		private final Assignment cInstructionAssignment_2_58 = (Assignment)cAlternatives_2.eContents().get(58);
		private final RuleCall cInstructionSexInstructionParserRuleCall_2_58_0 = (RuleCall)cInstructionAssignment_2_58.eContents().get(0);
		private final Assignment cInstructionAssignment_2_59 = (Assignment)cAlternatives_2.eContents().get(59);
		private final RuleCall cInstructionSt8InstructionParserRuleCall_2_59_0 = (RuleCall)cInstructionAssignment_2_59.eContents().get(0);
		private final Assignment cInstructionAssignment_2_60 = (Assignment)cAlternatives_2.eContents().get(60);
		private final RuleCall cInstructionSt16InstructionParserRuleCall_2_60_0 = (RuleCall)cInstructionAssignment_2_60.eContents().get(0);
		private final Assignment cInstructionAssignment_2_61 = (Assignment)cAlternatives_2.eContents().get(61);
		private final RuleCall cInstructionSubInstructionParserRuleCall_2_61_0 = (RuleCall)cInstructionAssignment_2_61.eContents().get(0);
		private final Assignment cInstructionAssignment_2_62 = (Assignment)cAlternatives_2.eContents().get(62);
		private final RuleCall cInstructionSubdInstructionParserRuleCall_2_62_0 = (RuleCall)cInstructionAssignment_2_62.eContents().get(0);
		private final Assignment cInstructionAssignment_2_63 = (Assignment)cAlternatives_2.eContents().get(63);
		private final RuleCall cInstructionSwiInstructionParserRuleCall_2_63_0 = (RuleCall)cInstructionAssignment_2_63.eContents().get(0);
		private final Assignment cInstructionAssignment_2_64 = (Assignment)cAlternatives_2.eContents().get(64);
		private final RuleCall cInstructionSwi2InstructionParserRuleCall_2_64_0 = (RuleCall)cInstructionAssignment_2_64.eContents().get(0);
		private final Assignment cInstructionAssignment_2_65 = (Assignment)cAlternatives_2.eContents().get(65);
		private final RuleCall cInstructionSwi3InstructionParserRuleCall_2_65_0 = (RuleCall)cInstructionAssignment_2_65.eContents().get(0);
		private final Assignment cInstructionAssignment_2_66 = (Assignment)cAlternatives_2.eContents().get(66);
		private final RuleCall cInstructionSyncInstructionParserRuleCall_2_66_0 = (RuleCall)cInstructionAssignment_2_66.eContents().get(0);
		private final Assignment cInstructionAssignment_2_67 = (Assignment)cAlternatives_2.eContents().get(67);
		private final RuleCall cInstructionTfrInstructionParserRuleCall_2_67_0 = (RuleCall)cInstructionAssignment_2_67.eContents().get(0);
		private final Assignment cInstructionAssignment_2_68 = (Assignment)cAlternatives_2.eContents().get(68);
		private final RuleCall cInstructionTstInstructionParserRuleCall_2_68_0 = (RuleCall)cInstructionAssignment_2_68.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * Definition of the list possible instructions
		// */
		//InstructionLine:
		//    (name = IdentifierValue)? WS
		//    (
		//        instruction = AbxInstruction            |
		//        instruction = AdcInstruction            |
		//        instruction = AddInstruction            |
		//        instruction = AdddInstruction           |
		//        instruction = AndInstruction            |
		//        instruction = AndCCInstruction          |
		//        instruction = AslInstruction            |
		//        instruction = AsrInstruction            |
		//        instruction = BccInstruction            |
		//        instruction = BcsInstruction              |
		//        instruction = BeqInstruction            |
		//        instruction = BgeInstruction            |
		//        instruction = BgtInstruction            |
		//        instruction = BhiInstruction            |
		//        instruction = BhsInstruction              |
		//        instruction = BitInstruction            |
		//        instruction = BleInstruction            |
		//        instruction = BloInstruction            |
		//        instruction = BlsInstruction            |
		//        instruction = BltInstruction            |
		//        instruction = BmiInstruction            |
		//        instruction = BneInstruction            |
		//        instruction = BplInstruction            |
		//        instruction = BraInstruction            |
		//        instruction = BrnInstruction            |
		//        instruction = BsrInstruction            |
		//        instruction = BvcInstruction            |
		//        instruction = BvsInstruction            |
		//        instruction = ClrInstruction            |
		//        instruction = CmpInstruction            |
		//        instruction = ComInstruction            |
		//        instruction = CwaiInstruction            |
		//        instruction = DaaInstruction            |
		//        instruction = DecInstruction            |
		//        instruction = EorInstruction            |
		//        instruction = ExgInstruction            |
		//        instruction = IncInstruction            |
		//        instruction = JmpInstruction            |
		//        instruction = JsrInstruction            |
		//        instruction = Ld8Instruction            |
		//        instruction = Ld16Instruction            |
		//        instruction = LeaInstruction            |
		//        instruction = LslInstruction            |
		//        instruction = LsrInstruction            |
		//        instruction = MulInstruction            |
		//        instruction = NegInstruction            |
		//        instruction = NopInstruction            |
		//        instruction = OrInstruction                |
		//        instruction = OrccInstruction            |
		//        instruction = PshsInstruction            |
		//        instruction = PshuInstruction            |
		//        instruction = PulsInstruction            |
		//        instruction = PuluInstruction            |
		//        instruction = RolInstruction            |
		//        instruction = RorInstruction            |
		//        instruction = RtiInstruction            |
		//        instruction = RtsInstruction            |
		//        instruction = SbcInstruction            |
		//        instruction = SexInstruction            |
		//        instruction = St8Instruction            |
		//        instruction = St16Instruction            |
		//        instruction = SubInstruction            |
		//        instruction = SubdInstruction            |
		//        instruction = SwiInstruction            |
		//        instruction = Swi2Instruction            |
		//        instruction = Swi3Instruction            |
		//        instruction = SyncInstruction            |
		//        instruction = TfrInstruction            |
		//        instruction = TstInstruction
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS
		//(
		//    instruction = AbxInstruction            |
		//    instruction = AdcInstruction            |
		//    instruction = AddInstruction            |
		//    instruction = AdddInstruction           |
		//    instruction = AndInstruction            |
		//    instruction = AndCCInstruction          |
		//    instruction = AslInstruction            |
		//    instruction = AsrInstruction            |
		//    instruction = BccInstruction            |
		//    instruction = BcsInstruction              |
		//    instruction = BeqInstruction            |
		//    instruction = BgeInstruction            |
		//    instruction = BgtInstruction            |
		//    instruction = BhiInstruction            |
		//    instruction = BhsInstruction              |
		//    instruction = BitInstruction            |
		//    instruction = BleInstruction            |
		//    instruction = BloInstruction            |
		//    instruction = BlsInstruction            |
		//    instruction = BltInstruction            |
		//    instruction = BmiInstruction            |
		//    instruction = BneInstruction            |
		//    instruction = BplInstruction            |
		//    instruction = BraInstruction            |
		//    instruction = BrnInstruction            |
		//    instruction = BsrInstruction            |
		//    instruction = BvcInstruction            |
		//    instruction = BvsInstruction            |
		//    instruction = ClrInstruction            |
		//    instruction = CmpInstruction            |
		//    instruction = ComInstruction            |
		//    instruction = CwaiInstruction            |
		//    instruction = DaaInstruction            |
		//    instruction = DecInstruction            |
		//    instruction = EorInstruction            |
		//    instruction = ExgInstruction            |
		//    instruction = IncInstruction            |
		//    instruction = JmpInstruction            |
		//    instruction = JsrInstruction            |
		//    instruction = Ld8Instruction            |
		//    instruction = Ld16Instruction            |
		//    instruction = LeaInstruction            |
		//    instruction = LslInstruction            |
		//    instruction = LsrInstruction            |
		//    instruction = MulInstruction            |
		//    instruction = NegInstruction            |
		//    instruction = NopInstruction            |
		//    instruction = OrInstruction                |
		//    instruction = OrccInstruction            |
		//    instruction = PshsInstruction            |
		//    instruction = PshuInstruction            |
		//    instruction = PulsInstruction            |
		//    instruction = PuluInstruction            |
		//    instruction = RolInstruction            |
		//    instruction = RorInstruction            |
		//    instruction = RtiInstruction            |
		//    instruction = RtsInstruction            |
		//    instruction = SbcInstruction            |
		//    instruction = SexInstruction            |
		//    instruction = St8Instruction            |
		//    instruction = St16Instruction            |
		//    instruction = SubInstruction            |
		//    instruction = SubdInstruction            |
		//    instruction = SwiInstruction            |
		//    instruction = Swi2Instruction            |
		//    instruction = Swi3Instruction            |
		//    instruction = SyncInstruction            |
		//    instruction = TfrInstruction            |
		//    instruction = TstInstruction
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//    instruction = AbxInstruction            |
		//    instruction = AdcInstruction            |
		//    instruction = AddInstruction            |
		//    instruction = AdddInstruction           |
		//    instruction = AndInstruction            |
		//    instruction = AndCCInstruction          |
		//    instruction = AslInstruction            |
		//    instruction = AsrInstruction            |
		//    instruction = BccInstruction            |
		//    instruction = BcsInstruction              |
		//    instruction = BeqInstruction            |
		//    instruction = BgeInstruction            |
		//    instruction = BgtInstruction            |
		//    instruction = BhiInstruction            |
		//    instruction = BhsInstruction              |
		//    instruction = BitInstruction            |
		//    instruction = BleInstruction            |
		//    instruction = BloInstruction            |
		//    instruction = BlsInstruction            |
		//    instruction = BltInstruction            |
		//    instruction = BmiInstruction            |
		//    instruction = BneInstruction            |
		//    instruction = BplInstruction            |
		//    instruction = BraInstruction            |
		//    instruction = BrnInstruction            |
		//    instruction = BsrInstruction            |
		//    instruction = BvcInstruction            |
		//    instruction = BvsInstruction            |
		//    instruction = ClrInstruction            |
		//    instruction = CmpInstruction            |
		//    instruction = ComInstruction            |
		//    instruction = CwaiInstruction            |
		//    instruction = DaaInstruction            |
		//    instruction = DecInstruction            |
		//    instruction = EorInstruction            |
		//    instruction = ExgInstruction            |
		//    instruction = IncInstruction            |
		//    instruction = JmpInstruction            |
		//    instruction = JsrInstruction            |
		//    instruction = Ld8Instruction            |
		//    instruction = Ld16Instruction            |
		//    instruction = LeaInstruction            |
		//    instruction = LslInstruction            |
		//    instruction = LsrInstruction            |
		//    instruction = MulInstruction            |
		//    instruction = NegInstruction            |
		//    instruction = NopInstruction            |
		//    instruction = OrInstruction                |
		//    instruction = OrccInstruction            |
		//    instruction = PshsInstruction            |
		//    instruction = PshuInstruction            |
		//    instruction = PulsInstruction            |
		//    instruction = PuluInstruction            |
		//    instruction = RolInstruction            |
		//    instruction = RorInstruction            |
		//    instruction = RtiInstruction            |
		//    instruction = RtsInstruction            |
		//    instruction = SbcInstruction            |
		//    instruction = SexInstruction            |
		//    instruction = St8Instruction            |
		//    instruction = St16Instruction            |
		//    instruction = SubInstruction            |
		//    instruction = SubdInstruction            |
		//    instruction = SwiInstruction            |
		//    instruction = Swi2Instruction            |
		//    instruction = Swi3Instruction            |
		//    instruction = SyncInstruction            |
		//    instruction = TfrInstruction            |
		//    instruction = TstInstruction
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//instruction = AbxInstruction
		public Assignment getInstructionAssignment_2_0() { return cInstructionAssignment_2_0; }
		
		//AbxInstruction
		public RuleCall getInstructionAbxInstructionParserRuleCall_2_0_0() { return cInstructionAbxInstructionParserRuleCall_2_0_0; }
		
		//instruction = AdcInstruction
		public Assignment getInstructionAssignment_2_1() { return cInstructionAssignment_2_1; }
		
		//AdcInstruction
		public RuleCall getInstructionAdcInstructionParserRuleCall_2_1_0() { return cInstructionAdcInstructionParserRuleCall_2_1_0; }
		
		//instruction = AddInstruction
		public Assignment getInstructionAssignment_2_2() { return cInstructionAssignment_2_2; }
		
		//AddInstruction
		public RuleCall getInstructionAddInstructionParserRuleCall_2_2_0() { return cInstructionAddInstructionParserRuleCall_2_2_0; }
		
		//instruction = AdddInstruction
		public Assignment getInstructionAssignment_2_3() { return cInstructionAssignment_2_3; }
		
		//AdddInstruction
		public RuleCall getInstructionAdddInstructionParserRuleCall_2_3_0() { return cInstructionAdddInstructionParserRuleCall_2_3_0; }
		
		//instruction = AndInstruction
		public Assignment getInstructionAssignment_2_4() { return cInstructionAssignment_2_4; }
		
		//AndInstruction
		public RuleCall getInstructionAndInstructionParserRuleCall_2_4_0() { return cInstructionAndInstructionParserRuleCall_2_4_0; }
		
		//instruction = AndCCInstruction
		public Assignment getInstructionAssignment_2_5() { return cInstructionAssignment_2_5; }
		
		//AndCCInstruction
		public RuleCall getInstructionAndCCInstructionParserRuleCall_2_5_0() { return cInstructionAndCCInstructionParserRuleCall_2_5_0; }
		
		//instruction = AslInstruction
		public Assignment getInstructionAssignment_2_6() { return cInstructionAssignment_2_6; }
		
		//AslInstruction
		public RuleCall getInstructionAslInstructionParserRuleCall_2_6_0() { return cInstructionAslInstructionParserRuleCall_2_6_0; }
		
		//instruction = AsrInstruction
		public Assignment getInstructionAssignment_2_7() { return cInstructionAssignment_2_7; }
		
		//AsrInstruction
		public RuleCall getInstructionAsrInstructionParserRuleCall_2_7_0() { return cInstructionAsrInstructionParserRuleCall_2_7_0; }
		
		//instruction = BccInstruction
		public Assignment getInstructionAssignment_2_8() { return cInstructionAssignment_2_8; }
		
		//BccInstruction
		public RuleCall getInstructionBccInstructionParserRuleCall_2_8_0() { return cInstructionBccInstructionParserRuleCall_2_8_0; }
		
		//instruction = BcsInstruction
		public Assignment getInstructionAssignment_2_9() { return cInstructionAssignment_2_9; }
		
		//BcsInstruction
		public RuleCall getInstructionBcsInstructionParserRuleCall_2_9_0() { return cInstructionBcsInstructionParserRuleCall_2_9_0; }
		
		//instruction = BeqInstruction
		public Assignment getInstructionAssignment_2_10() { return cInstructionAssignment_2_10; }
		
		//BeqInstruction
		public RuleCall getInstructionBeqInstructionParserRuleCall_2_10_0() { return cInstructionBeqInstructionParserRuleCall_2_10_0; }
		
		//instruction = BgeInstruction
		public Assignment getInstructionAssignment_2_11() { return cInstructionAssignment_2_11; }
		
		//BgeInstruction
		public RuleCall getInstructionBgeInstructionParserRuleCall_2_11_0() { return cInstructionBgeInstructionParserRuleCall_2_11_0; }
		
		//instruction = BgtInstruction
		public Assignment getInstructionAssignment_2_12() { return cInstructionAssignment_2_12; }
		
		//BgtInstruction
		public RuleCall getInstructionBgtInstructionParserRuleCall_2_12_0() { return cInstructionBgtInstructionParserRuleCall_2_12_0; }
		
		//instruction = BhiInstruction
		public Assignment getInstructionAssignment_2_13() { return cInstructionAssignment_2_13; }
		
		//BhiInstruction
		public RuleCall getInstructionBhiInstructionParserRuleCall_2_13_0() { return cInstructionBhiInstructionParserRuleCall_2_13_0; }
		
		//instruction = BhsInstruction
		public Assignment getInstructionAssignment_2_14() { return cInstructionAssignment_2_14; }
		
		//BhsInstruction
		public RuleCall getInstructionBhsInstructionParserRuleCall_2_14_0() { return cInstructionBhsInstructionParserRuleCall_2_14_0; }
		
		//instruction = BitInstruction
		public Assignment getInstructionAssignment_2_15() { return cInstructionAssignment_2_15; }
		
		//BitInstruction
		public RuleCall getInstructionBitInstructionParserRuleCall_2_15_0() { return cInstructionBitInstructionParserRuleCall_2_15_0; }
		
		//instruction = BleInstruction
		public Assignment getInstructionAssignment_2_16() { return cInstructionAssignment_2_16; }
		
		//BleInstruction
		public RuleCall getInstructionBleInstructionParserRuleCall_2_16_0() { return cInstructionBleInstructionParserRuleCall_2_16_0; }
		
		//instruction = BloInstruction
		public Assignment getInstructionAssignment_2_17() { return cInstructionAssignment_2_17; }
		
		//BloInstruction
		public RuleCall getInstructionBloInstructionParserRuleCall_2_17_0() { return cInstructionBloInstructionParserRuleCall_2_17_0; }
		
		//instruction = BlsInstruction
		public Assignment getInstructionAssignment_2_18() { return cInstructionAssignment_2_18; }
		
		//BlsInstruction
		public RuleCall getInstructionBlsInstructionParserRuleCall_2_18_0() { return cInstructionBlsInstructionParserRuleCall_2_18_0; }
		
		//instruction = BltInstruction
		public Assignment getInstructionAssignment_2_19() { return cInstructionAssignment_2_19; }
		
		//BltInstruction
		public RuleCall getInstructionBltInstructionParserRuleCall_2_19_0() { return cInstructionBltInstructionParserRuleCall_2_19_0; }
		
		//instruction = BmiInstruction
		public Assignment getInstructionAssignment_2_20() { return cInstructionAssignment_2_20; }
		
		//BmiInstruction
		public RuleCall getInstructionBmiInstructionParserRuleCall_2_20_0() { return cInstructionBmiInstructionParserRuleCall_2_20_0; }
		
		//instruction = BneInstruction
		public Assignment getInstructionAssignment_2_21() { return cInstructionAssignment_2_21; }
		
		//BneInstruction
		public RuleCall getInstructionBneInstructionParserRuleCall_2_21_0() { return cInstructionBneInstructionParserRuleCall_2_21_0; }
		
		//instruction = BplInstruction
		public Assignment getInstructionAssignment_2_22() { return cInstructionAssignment_2_22; }
		
		//BplInstruction
		public RuleCall getInstructionBplInstructionParserRuleCall_2_22_0() { return cInstructionBplInstructionParserRuleCall_2_22_0; }
		
		//instruction = BraInstruction
		public Assignment getInstructionAssignment_2_23() { return cInstructionAssignment_2_23; }
		
		//BraInstruction
		public RuleCall getInstructionBraInstructionParserRuleCall_2_23_0() { return cInstructionBraInstructionParserRuleCall_2_23_0; }
		
		//instruction = BrnInstruction
		public Assignment getInstructionAssignment_2_24() { return cInstructionAssignment_2_24; }
		
		//BrnInstruction
		public RuleCall getInstructionBrnInstructionParserRuleCall_2_24_0() { return cInstructionBrnInstructionParserRuleCall_2_24_0; }
		
		//instruction = BsrInstruction
		public Assignment getInstructionAssignment_2_25() { return cInstructionAssignment_2_25; }
		
		//BsrInstruction
		public RuleCall getInstructionBsrInstructionParserRuleCall_2_25_0() { return cInstructionBsrInstructionParserRuleCall_2_25_0; }
		
		//instruction = BvcInstruction
		public Assignment getInstructionAssignment_2_26() { return cInstructionAssignment_2_26; }
		
		//BvcInstruction
		public RuleCall getInstructionBvcInstructionParserRuleCall_2_26_0() { return cInstructionBvcInstructionParserRuleCall_2_26_0; }
		
		//instruction = BvsInstruction
		public Assignment getInstructionAssignment_2_27() { return cInstructionAssignment_2_27; }
		
		//BvsInstruction
		public RuleCall getInstructionBvsInstructionParserRuleCall_2_27_0() { return cInstructionBvsInstructionParserRuleCall_2_27_0; }
		
		//instruction = ClrInstruction
		public Assignment getInstructionAssignment_2_28() { return cInstructionAssignment_2_28; }
		
		//ClrInstruction
		public RuleCall getInstructionClrInstructionParserRuleCall_2_28_0() { return cInstructionClrInstructionParserRuleCall_2_28_0; }
		
		//instruction = CmpInstruction
		public Assignment getInstructionAssignment_2_29() { return cInstructionAssignment_2_29; }
		
		//CmpInstruction
		public RuleCall getInstructionCmpInstructionParserRuleCall_2_29_0() { return cInstructionCmpInstructionParserRuleCall_2_29_0; }
		
		//instruction = ComInstruction
		public Assignment getInstructionAssignment_2_30() { return cInstructionAssignment_2_30; }
		
		//ComInstruction
		public RuleCall getInstructionComInstructionParserRuleCall_2_30_0() { return cInstructionComInstructionParserRuleCall_2_30_0; }
		
		//instruction = CwaiInstruction
		public Assignment getInstructionAssignment_2_31() { return cInstructionAssignment_2_31; }
		
		//CwaiInstruction
		public RuleCall getInstructionCwaiInstructionParserRuleCall_2_31_0() { return cInstructionCwaiInstructionParserRuleCall_2_31_0; }
		
		//instruction = DaaInstruction
		public Assignment getInstructionAssignment_2_32() { return cInstructionAssignment_2_32; }
		
		//DaaInstruction
		public RuleCall getInstructionDaaInstructionParserRuleCall_2_32_0() { return cInstructionDaaInstructionParserRuleCall_2_32_0; }
		
		//instruction = DecInstruction
		public Assignment getInstructionAssignment_2_33() { return cInstructionAssignment_2_33; }
		
		//DecInstruction
		public RuleCall getInstructionDecInstructionParserRuleCall_2_33_0() { return cInstructionDecInstructionParserRuleCall_2_33_0; }
		
		//instruction = EorInstruction
		public Assignment getInstructionAssignment_2_34() { return cInstructionAssignment_2_34; }
		
		//EorInstruction
		public RuleCall getInstructionEorInstructionParserRuleCall_2_34_0() { return cInstructionEorInstructionParserRuleCall_2_34_0; }
		
		//instruction = ExgInstruction
		public Assignment getInstructionAssignment_2_35() { return cInstructionAssignment_2_35; }
		
		//ExgInstruction
		public RuleCall getInstructionExgInstructionParserRuleCall_2_35_0() { return cInstructionExgInstructionParserRuleCall_2_35_0; }
		
		//instruction = IncInstruction
		public Assignment getInstructionAssignment_2_36() { return cInstructionAssignment_2_36; }
		
		//IncInstruction
		public RuleCall getInstructionIncInstructionParserRuleCall_2_36_0() { return cInstructionIncInstructionParserRuleCall_2_36_0; }
		
		//instruction = JmpInstruction
		public Assignment getInstructionAssignment_2_37() { return cInstructionAssignment_2_37; }
		
		//JmpInstruction
		public RuleCall getInstructionJmpInstructionParserRuleCall_2_37_0() { return cInstructionJmpInstructionParserRuleCall_2_37_0; }
		
		//instruction = JsrInstruction
		public Assignment getInstructionAssignment_2_38() { return cInstructionAssignment_2_38; }
		
		//JsrInstruction
		public RuleCall getInstructionJsrInstructionParserRuleCall_2_38_0() { return cInstructionJsrInstructionParserRuleCall_2_38_0; }
		
		//instruction = Ld8Instruction
		public Assignment getInstructionAssignment_2_39() { return cInstructionAssignment_2_39; }
		
		//Ld8Instruction
		public RuleCall getInstructionLd8InstructionParserRuleCall_2_39_0() { return cInstructionLd8InstructionParserRuleCall_2_39_0; }
		
		//instruction = Ld16Instruction
		public Assignment getInstructionAssignment_2_40() { return cInstructionAssignment_2_40; }
		
		//Ld16Instruction
		public RuleCall getInstructionLd16InstructionParserRuleCall_2_40_0() { return cInstructionLd16InstructionParserRuleCall_2_40_0; }
		
		//instruction = LeaInstruction
		public Assignment getInstructionAssignment_2_41() { return cInstructionAssignment_2_41; }
		
		//LeaInstruction
		public RuleCall getInstructionLeaInstructionParserRuleCall_2_41_0() { return cInstructionLeaInstructionParserRuleCall_2_41_0; }
		
		//instruction = LslInstruction
		public Assignment getInstructionAssignment_2_42() { return cInstructionAssignment_2_42; }
		
		//LslInstruction
		public RuleCall getInstructionLslInstructionParserRuleCall_2_42_0() { return cInstructionLslInstructionParserRuleCall_2_42_0; }
		
		//instruction = LsrInstruction
		public Assignment getInstructionAssignment_2_43() { return cInstructionAssignment_2_43; }
		
		//LsrInstruction
		public RuleCall getInstructionLsrInstructionParserRuleCall_2_43_0() { return cInstructionLsrInstructionParserRuleCall_2_43_0; }
		
		//instruction = MulInstruction
		public Assignment getInstructionAssignment_2_44() { return cInstructionAssignment_2_44; }
		
		//MulInstruction
		public RuleCall getInstructionMulInstructionParserRuleCall_2_44_0() { return cInstructionMulInstructionParserRuleCall_2_44_0; }
		
		//instruction = NegInstruction
		public Assignment getInstructionAssignment_2_45() { return cInstructionAssignment_2_45; }
		
		//NegInstruction
		public RuleCall getInstructionNegInstructionParserRuleCall_2_45_0() { return cInstructionNegInstructionParserRuleCall_2_45_0; }
		
		//instruction = NopInstruction
		public Assignment getInstructionAssignment_2_46() { return cInstructionAssignment_2_46; }
		
		//NopInstruction
		public RuleCall getInstructionNopInstructionParserRuleCall_2_46_0() { return cInstructionNopInstructionParserRuleCall_2_46_0; }
		
		//instruction = OrInstruction
		public Assignment getInstructionAssignment_2_47() { return cInstructionAssignment_2_47; }
		
		//OrInstruction
		public RuleCall getInstructionOrInstructionParserRuleCall_2_47_0() { return cInstructionOrInstructionParserRuleCall_2_47_0; }
		
		//instruction = OrccInstruction
		public Assignment getInstructionAssignment_2_48() { return cInstructionAssignment_2_48; }
		
		//OrccInstruction
		public RuleCall getInstructionOrccInstructionParserRuleCall_2_48_0() { return cInstructionOrccInstructionParserRuleCall_2_48_0; }
		
		//instruction = PshsInstruction
		public Assignment getInstructionAssignment_2_49() { return cInstructionAssignment_2_49; }
		
		//PshsInstruction
		public RuleCall getInstructionPshsInstructionParserRuleCall_2_49_0() { return cInstructionPshsInstructionParserRuleCall_2_49_0; }
		
		//instruction = PshuInstruction
		public Assignment getInstructionAssignment_2_50() { return cInstructionAssignment_2_50; }
		
		//PshuInstruction
		public RuleCall getInstructionPshuInstructionParserRuleCall_2_50_0() { return cInstructionPshuInstructionParserRuleCall_2_50_0; }
		
		//instruction = PulsInstruction
		public Assignment getInstructionAssignment_2_51() { return cInstructionAssignment_2_51; }
		
		//PulsInstruction
		public RuleCall getInstructionPulsInstructionParserRuleCall_2_51_0() { return cInstructionPulsInstructionParserRuleCall_2_51_0; }
		
		//instruction = PuluInstruction
		public Assignment getInstructionAssignment_2_52() { return cInstructionAssignment_2_52; }
		
		//PuluInstruction
		public RuleCall getInstructionPuluInstructionParserRuleCall_2_52_0() { return cInstructionPuluInstructionParserRuleCall_2_52_0; }
		
		//instruction = RolInstruction
		public Assignment getInstructionAssignment_2_53() { return cInstructionAssignment_2_53; }
		
		//RolInstruction
		public RuleCall getInstructionRolInstructionParserRuleCall_2_53_0() { return cInstructionRolInstructionParserRuleCall_2_53_0; }
		
		//instruction = RorInstruction
		public Assignment getInstructionAssignment_2_54() { return cInstructionAssignment_2_54; }
		
		//RorInstruction
		public RuleCall getInstructionRorInstructionParserRuleCall_2_54_0() { return cInstructionRorInstructionParserRuleCall_2_54_0; }
		
		//instruction = RtiInstruction
		public Assignment getInstructionAssignment_2_55() { return cInstructionAssignment_2_55; }
		
		//RtiInstruction
		public RuleCall getInstructionRtiInstructionParserRuleCall_2_55_0() { return cInstructionRtiInstructionParserRuleCall_2_55_0; }
		
		//instruction = RtsInstruction
		public Assignment getInstructionAssignment_2_56() { return cInstructionAssignment_2_56; }
		
		//RtsInstruction
		public RuleCall getInstructionRtsInstructionParserRuleCall_2_56_0() { return cInstructionRtsInstructionParserRuleCall_2_56_0; }
		
		//instruction = SbcInstruction
		public Assignment getInstructionAssignment_2_57() { return cInstructionAssignment_2_57; }
		
		//SbcInstruction
		public RuleCall getInstructionSbcInstructionParserRuleCall_2_57_0() { return cInstructionSbcInstructionParserRuleCall_2_57_0; }
		
		//instruction = SexInstruction
		public Assignment getInstructionAssignment_2_58() { return cInstructionAssignment_2_58; }
		
		//SexInstruction
		public RuleCall getInstructionSexInstructionParserRuleCall_2_58_0() { return cInstructionSexInstructionParserRuleCall_2_58_0; }
		
		//instruction = St8Instruction
		public Assignment getInstructionAssignment_2_59() { return cInstructionAssignment_2_59; }
		
		//St8Instruction
		public RuleCall getInstructionSt8InstructionParserRuleCall_2_59_0() { return cInstructionSt8InstructionParserRuleCall_2_59_0; }
		
		//instruction = St16Instruction
		public Assignment getInstructionAssignment_2_60() { return cInstructionAssignment_2_60; }
		
		//St16Instruction
		public RuleCall getInstructionSt16InstructionParserRuleCall_2_60_0() { return cInstructionSt16InstructionParserRuleCall_2_60_0; }
		
		//instruction = SubInstruction
		public Assignment getInstructionAssignment_2_61() { return cInstructionAssignment_2_61; }
		
		//SubInstruction
		public RuleCall getInstructionSubInstructionParserRuleCall_2_61_0() { return cInstructionSubInstructionParserRuleCall_2_61_0; }
		
		//instruction = SubdInstruction
		public Assignment getInstructionAssignment_2_62() { return cInstructionAssignment_2_62; }
		
		//SubdInstruction
		public RuleCall getInstructionSubdInstructionParserRuleCall_2_62_0() { return cInstructionSubdInstructionParserRuleCall_2_62_0; }
		
		//instruction = SwiInstruction
		public Assignment getInstructionAssignment_2_63() { return cInstructionAssignment_2_63; }
		
		//SwiInstruction
		public RuleCall getInstructionSwiInstructionParserRuleCall_2_63_0() { return cInstructionSwiInstructionParserRuleCall_2_63_0; }
		
		//instruction = Swi2Instruction
		public Assignment getInstructionAssignment_2_64() { return cInstructionAssignment_2_64; }
		
		//Swi2Instruction
		public RuleCall getInstructionSwi2InstructionParserRuleCall_2_64_0() { return cInstructionSwi2InstructionParserRuleCall_2_64_0; }
		
		//instruction = Swi3Instruction
		public Assignment getInstructionAssignment_2_65() { return cInstructionAssignment_2_65; }
		
		//Swi3Instruction
		public RuleCall getInstructionSwi3InstructionParserRuleCall_2_65_0() { return cInstructionSwi3InstructionParserRuleCall_2_65_0; }
		
		//instruction = SyncInstruction
		public Assignment getInstructionAssignment_2_66() { return cInstructionAssignment_2_66; }
		
		//SyncInstruction
		public RuleCall getInstructionSyncInstructionParserRuleCall_2_66_0() { return cInstructionSyncInstructionParserRuleCall_2_66_0; }
		
		//instruction = TfrInstruction
		public Assignment getInstructionAssignment_2_67() { return cInstructionAssignment_2_67; }
		
		//TfrInstruction
		public RuleCall getInstructionTfrInstructionParserRuleCall_2_67_0() { return cInstructionTfrInstructionParserRuleCall_2_67_0; }
		
		//instruction = TstInstruction
		public Assignment getInstructionAssignment_2_68() { return cInstructionAssignment_2_68; }
		
		//TstInstruction
		public RuleCall getInstructionTstInstructionParserRuleCall_2_68_0() { return cInstructionTstInstructionParserRuleCall_2_68_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class TstInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.TstInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionTSTAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionTSTBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionTSTKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * TST
		// *
		// * Test
		// * Source Form        : TST Q, TSTA; TSTB
		// * Operation        : TEMP< M-0
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Set the N (negative) and Z (zero) bits according to the contents of memory location M, and clear the V (overflow) bit. The TST instruction provides
		// *                    only minimum information when testing unsigned values; since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be
		// *                    used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//TstInstruction:
		//    (
		//       instruction = ('TSTA' | 'TSTB')
		//    )
		//    |
		//    (
		//         instruction = ('TST')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('TSTA' | 'TSTB')
		//)
		//|
		//(
		//     instruction = ('TST')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('TSTA' | 'TSTB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('TSTA' | 'TSTB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'TSTA'
		public Keyword getInstructionTSTAKeyword_0_0_0() { return cInstructionTSTAKeyword_0_0_0; }
		
		//'TSTB'
		public Keyword getInstructionTSTBKeyword_0_0_1() { return cInstructionTSTBKeyword_0_0_1; }
		
		//(
		//     instruction = ('TST')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('TST')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('TST')
		public Keyword getInstructionTSTKeyword_1_0_0() { return cInstructionTSTKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class TfrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.TfrInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionTFRKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cReg1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReg1RegisterEnumRuleCall_2_0 = (RuleCall)cReg1Assignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cReg2Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cReg2RegisterEnumRuleCall_4_0 = (RuleCall)cReg2Assignment_4.eContents().get(0);
		
		///*
		// * TFR
		// *
		// * Transfer Register to Register
		// * Source Form        : TFR R1,R2
		// * Operation        : R1->R2
		// * Condition Codes    :Not affected unless R2 is the condition code register.
		// * Description        : Exchanges data between two designated registers. Bits 3-0 of the postbyte define one register,
		// *                    while bits 7-4 define the other, as follows:
		// *                                     0000 = A:B                1000 = A
		// *                                     0001 =X                    1001 = B
		// *                                     0010 = Y                1010 = COR
		// *                                     0011= US                1011= DPR
		// *                                     0100 = SP                1100 = Undefined
		// *                                     0101 = PC                1101 = Undefined
		// *                                     0110 = Undefined        1110 = Undefined
		// *                                     0111= Undefined            1111 = Undefined
		// *                      Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
		// * Addressing Mode    : Immediate
		// */
		//TfrInstruction:
		//    instruction = ('TFR' )
		//    WS reg1=Register ',' reg2=Register
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('TFR' )
		//WS reg1=Register ',' reg2=Register
		public Group getGroup() { return cGroup; }
		
		//instruction = ('TFR' )
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('TFR' )
		public Keyword getInstructionTFRKeyword_0_0() { return cInstructionTFRKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//reg1=Register
		public Assignment getReg1Assignment_2() { return cReg1Assignment_2; }
		
		//Register
		public RuleCall getReg1RegisterEnumRuleCall_2_0() { return cReg1RegisterEnumRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//reg2=Register
		public Assignment getReg2Assignment_4() { return cReg2Assignment_4; }
		
		//Register
		public RuleCall getReg2RegisterEnumRuleCall_4_0() { return cReg2RegisterEnumRuleCall_4_0; }
	}
	public class SyncInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SyncInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionSYNCKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * SYNC
		// *
		// * Synchronize to External Event
		// * Source Form        : SYNC
		// * Operation        : Synchronize to External Event
		// * Condition Codes    : Not affected.
		// * Description        : When a SYNC instruction is excuted, tlie processor enters a synchronizing state, stops processing instructions, and waits for an interrupt.
		// *                       When an interrupt occurs, the synchronizing state is cleared and processing continues. If the interrupt is enabled, and it lasts three cycles
		// *                    or more, the processor will perform the interrupt routine. If the interrupt is masked or is shorter than three cycles, the processor simply
		// *                    continues to the next instruction. While in the synchronizing state, the address and data buses are in the high impedance state.
		// * Addressing Mode    : Inherent
		// */
		//SyncInstruction:
		//    instruction = 'SYNC'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SYNC'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'SYNC'
		public Keyword getInstructionSYNCKeyword_0() { return cInstructionSYNCKeyword_0; }
	}
	public class Swi3InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Swi3Instruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionSWI3Keyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * SWI3
		// *
		// * Software Interrupt 3
		// * Source Form        : SWI3
		// * Operation        : Set E (entire state will be saved)
		// *                       SP'-SP-1,(SP)-PCL
		// *                    SP'^SP-1,(SP) PCH
		// *                    SP'SP-1,(SP)*-USL
		// *                    SP' SP-1,(SP)*-USH
		// *                    SP'-SP-1,(SP) lYL
		// *                    SP'*-SP-1,(SP) lYH
		// *                    SP'-SP-1,(SP)-IXL
		// *                    SP'SP-1,(SP) IXH
		// *                    SP'SP-1,(SP)^DPR
		// *                    SP' SP-1,(SP)*-ACCB
		// *                    SP' SP-1,(SP) ACCA
		// *                    SP'SP-1,(SP) OCR
		// *                    Set I, F (mask interrupts)
		// *                    PC'-(FFF2):(FFF3)
		// * Condition Codes    : Not affected.
		// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
		// *                    is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged software.
		// *                    This interrupt does not mask (disable) the norma! and fast interrupts.
		// * Addressing Mode    : Inherent
		// */
		//Swi3Instruction:
		//    instruction = 'SWI3'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SWI3'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'SWI3'
		public Keyword getInstructionSWI3Keyword_0() { return cInstructionSWI3Keyword_0; }
	}
	public class Swi2InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Swi2Instruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionSWI2Keyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * SWI2
		// *
		// * Software Interrupt 2
		// * Source Form        : SWI2
		// * Operation        : Set E (entire state will be saved)
		// *                       SP'-SP-1,(SP)-PCL
		// *                    SP'^SP-1,(SP) PCH
		// *                    SP'SP-1,(SP)*-USL
		// *                    SP' SP-1,(SP)*-USH
		// *                    SP'-SP-1,(SP) lYL
		// *                    SP'*-SP-1,(SP) lYH
		// *                    SP'-SP-1,(SP)-IXL
		// *                    SP'SP-1,(SP) IXH
		// *                    SP'SP-1,(SP)^DPR
		// *                    SP' SP-1,(SP)*-ACCB
		// *                    SP' SP-1,(SP) ACCA
		// *                    SP'SP-1,(SP) OCR
		// *                    Set I, F (mask interrupts)
		// *                    PC'-(FFF4):(FFF5)
		// * Condition Codes    : Not affected.
		// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
		// *                    is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged software.
		// *                    This interrupt does not mask (disable) the norma! and fast interrupts.
		// * Addressing Mode    : Inherent
		// */
		//Swi2Instruction:
		//    instruction = 'SWI2'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SWI2'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'SWI2'
		public Keyword getInstructionSWI2Keyword_0() { return cInstructionSWI2Keyword_0; }
	}
	public class SwiInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SwiInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionSWIKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * SWI
		// *
		// * Software Interrupt
		// * Source Form        : SWI
		// * Operation        : Set E (entire state will be saved)
		// *                       SP'-SP-1,(SP)-PCL
		// *                    SP'^SP-1,(SP) PCH
		// *                    SP'SP-1,(SP)*-USL
		// *                    SP' SP-1,(SP)*-USH
		// *                    SP'-SP-1,(SP) lYL
		// *                    SP'*-SP-1,(SP) lYH
		// *                    SP'-SP-1,(SP)-IXL
		// *                    SP'SP-1,(SP) IXH
		// *                    SP'SP-1,(SP)^DPR
		// *                    SP' SP-1,(SP)*-ACCB
		// *                    SP' SP-1,(SP) ACCA
		// *                    SP'SP-1,(SP) OCR
		// *                    Set I, F (mask interrupts)
		// *                    PC'*-(FFFA):(FFFB)
		// * Condition Codes    : Not affected.
		// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
		// *                    is transferred through the software Interrupt vector. Both the normal and fast interrupts are masked (disabled).
		// * Addressing Mode    : Inherent
		// */
		//SwiInstruction:
		//    instruction = 'SWI'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SWI'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'SWI'
		public Keyword getInstructionSWIKeyword_0() { return cInstructionSWIKeyword_0; }
	}
	public class SubdInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SubdInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionSUBDKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * SUBD
		// *
		// * Subtract Memory from Register
		// * Source Form        : SUBD P
		// * Operation        : R'*-R - M:M+1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Set if the overflow is generated; cleared otherwise.
		// *                       C - Set if a borrow is generated; cleared otherwise.
		// * Description        : Subtracts the value in memory location M:M + 1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow
		// *                       and is set to the inverse of the resulting binary carry.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//SubdInstruction:
		//    instruction = 'SUBD'
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SUBD'
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = 'SUBD'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'SUBD'
		public Keyword getInstructionSUBDKeyword_0_0() { return cInstructionSUBDKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class SubInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SubInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionSUBAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionSUBBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * SUB
		// *
		// * ASubtract Memory from Register
		// * Source Form        : SUBA P; SUBB P;
		// * Operation        : R'*-R - M
		// * Condition Codes    : H - Undefined.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Set if the result is zero; cleared otherwise.
		// *                       C - Set if a borrow is generated; cleared otherwise.
		// * Description        : Subtracts the value in memory location M:M + 1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow
		// *                    and is set to the inverse of the resulting binary carry.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//SubInstruction:
		//    instruction = ('SUBA' | 'SUBB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('SUBA' | 'SUBB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('SUBA' | 'SUBB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('SUBA' | 'SUBB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'SUBA'
		public Keyword getInstructionSUBAKeyword_0_0_0() { return cInstructionSUBAKeyword_0_0_0; }
		
		//'SUBB'
		public Keyword getInstructionSUBBKeyword_0_0_1() { return cInstructionSUBBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class St16InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.St16Instruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionSTDKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionSTXKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Keyword cInstructionSTYKeyword_0_0_2 = (Keyword)cInstructionAlternatives_0_0.eContents().get(2);
		private final Keyword cInstructionSTSKeyword_0_0_3 = (Keyword)cInstructionAlternatives_0_0.eContents().get(3);
		private final Keyword cInstructionSTUKeyword_0_0_4 = (Keyword)cInstructionAlternatives_0_0.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		
		///*
		// * ST (16 bits)
		// *
		// * store Register into Memory
		// * Source Form        : STD P, STX P, STY P, STS P, STU P
		// * Operation        : M:%+1 <- R
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Writes the contents of a 16-bit register into two consecutive memory locations.
		// * Addressing Mode    : Extended
		// *                    Direct
		// *                    Indexed
		// */
		//St16Instruction:
		//     instruction = ('STD' | 'STX' | 'STY' | 'STS' | 'STU')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('STD' | 'STX' | 'STY' | 'STS' | 'STU')
		//WS operand = (
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('STD' | 'STX' | 'STY' | 'STS' | 'STU')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('STD' | 'STX' | 'STY' | 'STS' | 'STU')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'STD'
		public Keyword getInstructionSTDKeyword_0_0_0() { return cInstructionSTDKeyword_0_0_0; }
		
		//'STX'
		public Keyword getInstructionSTXKeyword_0_0_1() { return cInstructionSTXKeyword_0_0_1; }
		
		//'STY'
		public Keyword getInstructionSTYKeyword_0_0_2() { return cInstructionSTYKeyword_0_0_2; }
		
		//'STS'
		public Keyword getInstructionSTSKeyword_0_0_3() { return cInstructionSTSKeyword_0_0_3; }
		
		//'STU'
		public Keyword getInstructionSTUKeyword_0_0_4() { return cInstructionSTUKeyword_0_0_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_0() { return cOperandDirectOperandParserRuleCall_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_3; }
	}
	public class St8InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.St8Instruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionSTAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionSTBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		
		///*
		// * ST (8 bits)
		// *
		// * store Register into Memory
		// * Source Form        : STA P, STB P
		// * Operation        : M <- R
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Writes the contents of an 8-bit register into a memory location.
		// * Addressing Mode    : Extended
		// *                    Direct
		// *                    Indexed
		// */
		//St8Instruction:
		//     instruction = ('STA' | 'STB')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('STA' | 'STB')
		//WS operand = (
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('STA' | 'STB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('STA' | 'STB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'STA'
		public Keyword getInstructionSTAKeyword_0_0_0() { return cInstructionSTAKeyword_0_0_0; }
		
		//'STB'
		public Keyword getInstructionSTBKeyword_0_0_1() { return cInstructionSTBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_0() { return cOperandDirectOperandParserRuleCall_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_3; }
	}
	public class SexInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SexInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionSEXKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * SEX
		// *
		// * Sign Extended
		// * Source Form        : SEX
		// * Operation        : If bit seven of ACCB is set then ACCA'-^FF16
		// *                      else ACCA'-^OO16
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected.
		// *                       C - Not affected.
		// * Description        : This instruction transforms a twos complement 8-bit value in accumulator B into a twos complement 16-bit value in the D accumulator.
		// * Addressing Mode    : Inherent
		// */
		//SexInstruction:
		//    instruction = 'SEX'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'SEX'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'SEX'
		public Keyword getInstructionSEXKeyword_0() { return cInstructionSEXKeyword_0; }
	}
	public class SbcInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SbcInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionSBCAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionSBCBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * SBC
		// *
		// * Subtract with Borrow
		// * Source Form        : SBCA P, SBCB P
		// * Operation        : R <- R-M-C
		// * Condition Codes    : H - Undefined.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if an overflow is generated; cleared otherwise.
		// *                       C - Set if a borrow is generated; cleared otherwise.
		// * Description        : Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and
		// *                    places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
		// * Addressing Mode    : Immediate
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//SbcInstruction:
		//     instruction = ('SBCA' | 'SBCB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('SBCA' | 'SBCB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('SBCA' | 'SBCB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('SBCA' | 'SBCB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'SBCA'
		public Keyword getInstructionSBCAKeyword_0_0_0() { return cInstructionSBCAKeyword_0_0_0; }
		
		//'SBCB'
		public Keyword getInstructionSBCBKeyword_0_0_1() { return cInstructionSBCBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class RtsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RtsInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionRTSKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * RTS
		// *
		// * Return from Subroutine
		// * Source Form        : RTS
		// * Operation        : PCH'(SP), SP'*-SP + 1
		//                      PCL'*-(SP), SP'-SP+1
		// * Condition Codes    : Not affected.
		// * Description        : Program control is returned from the subroutine to the calling program. The return address is pulled from the stack.
		// * Addressing Mode    : Inherent
		// */
		//RtsInstruction:
		//    instruction = 'RTS'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'RTS'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'RTS'
		public Keyword getInstructionRTSKeyword_0() { return cInstructionRTSKeyword_0; }
	}
	public class RtiInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RtiInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionRTIKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * RTI
		// *
		// * Return from Interrupt
		// * Source Form        : RTI
		// * Operation        : OCR' (SP),SP'SP + 1, then
		// *                        IFF COR bit E is set, then:     ACCA'-(SP), SP'*-SP + 1
		// *                                                        ACCB'*-(SP), SP'-SP + 1
		// *                                                        DPR' -(SP), SP'-SP + 1
		// *                                                        IXH' (SP), SP'*-SP + 1
		// *                                                        IXL' (SP), SP' SP + 1
		// *                                                        lYH' (SP), SP'*-SP + 1
		// *                                                        lYL' -(SP), SP' SP + 1
		// *                                                        USH' (SP), SP' SP + 1
		// *                                                        USL' *-(SP), SP'*-SP + 1
		// *                                                        PCH' ^(SP), SP' SP + 1
		// *                                                         PCL' *-(SP), SP'*-SP + 1
		// *                        IFF CCR bit E is clear, then:     PCH' ^(SP), SP' SP + 1
		// *                                                        PCL' *-(SP), SP' SP + 1
		// * Condition Codes    : Recovered from the stack
		// * Description        : The saved machine state is recovered from the hardware stack and control is returned to the Interrupted program. If the recovered E (entire) bit is clear,
		// *                    it indicates that only a subset of the machine state was saved (return address and condition codes) and only that subset is recovered.
		// * Addressing Mode    : Inherent
		// */
		//RtiInstruction:
		//    instruction = 'RTI'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'RTI'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'RTI'
		public Keyword getInstructionRTIKeyword_0() { return cInstructionRTIKeyword_0; }
	}
	public class RorInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RorInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionRORAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionRORBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionRORKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * ROR
		// *
		// * Rotate Right
		// * Source Form        : ROR Q, RORA; RORB
		// * Operation        :
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected.
		// *                       C - Loaded with bit zero of the previous operand.
		// * Description        : Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//RorInstruction:
		//    (
		//       instruction = ('RORA' | 'RORB')
		//    )
		//    |
		//    (
		//         instruction = ('ROR')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('RORA' | 'RORB')
		//)
		//|
		//(
		//     instruction = ('ROR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('RORA' | 'RORB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('RORA' | 'RORB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'RORA'
		public Keyword getInstructionRORAKeyword_0_0_0() { return cInstructionRORAKeyword_0_0_0; }
		
		//'RORB'
		public Keyword getInstructionRORBKeyword_0_0_1() { return cInstructionRORBKeyword_0_0_1; }
		
		//(
		//     instruction = ('ROR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('ROR')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('ROR')
		public Keyword getInstructionRORKeyword_1_0_0() { return cInstructionRORKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class RolInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RolInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionROLAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionROLBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionROLKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * ROL
		// *
		// * Rotate Left
		// * Source Form        : ROL Q, ROLA; ROLB
		// * Operation        :
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Rotates all bits of the operand one place left through the (carry) bit. This is a 9-bit rotation.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//RolInstruction:
		//    (
		//       instruction = ('ROLA' | 'ROLB')
		//    )
		//    |
		//    (
		//         instruction = ('ROL')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('ROLA' | 'ROLB')
		//)
		//|
		//(
		//     instruction = ('ROL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('ROLA' | 'ROLB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ROLA' | 'ROLB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ROLA'
		public Keyword getInstructionROLAKeyword_0_0_0() { return cInstructionROLAKeyword_0_0_0; }
		
		//'ROLB'
		public Keyword getInstructionROLBKeyword_0_0_1() { return cInstructionROLBKeyword_0_0_1; }
		
		//(
		//     instruction = ('ROL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('ROL')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('ROL')
		public Keyword getInstructionROLKeyword_1_0_0() { return cInstructionROLKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class PuluInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PuluInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionPULUKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegistersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_0_0 = (RuleCall)cRegistersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cRegistersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_1_1_0 = (RuleCall)cRegistersAssignment_2_1_1_1.eContents().get(0);
		
		///*
		// * PULu
		// *
		// * Pull Registers from the User Stack
		// * Source Form        : PULU register list
		//                      PULU #LABEL
		// * Operation        :
		// * Condition Codes    : May be pulled from stack; not affected otherwise.
		// * Description        : All, some, or none of the processor registers are pulled from the user stack (with the exception of the user stack pointer itself).
		// * Addressing Mode    : Immediate
		// */
		//PuluInstruction:
		//    instruction = 'PULU'
		//    WS
		//    (
		//           (operand = ImmediatOperand)
		//        |  ( registers+=Register (',' registers+=Register)*)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'PULU'
		//WS
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = 'PULU'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'PULU'
		public Keyword getInstructionPULUKeyword_0_0() { return cInstructionPULUKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(operand = ImmediatOperand)
		public Assignment getOperandAssignment_2_0() { return cOperandAssignment_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//( registers+=Register (',' registers+=Register)*)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_0() { return cRegistersAssignment_2_1_0; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_0_0() { return cRegistersRegisterEnumRuleCall_2_1_0_0; }
		
		//(',' registers+=Register)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_1_1() { return cRegistersAssignment_2_1_1_1; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_1_1_0() { return cRegistersRegisterEnumRuleCall_2_1_1_1_0; }
	}
	public class PulsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PulsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionPULSKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegistersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_0_0 = (RuleCall)cRegistersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cRegistersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_1_1_0 = (RuleCall)cRegistersAssignment_2_1_1_1.eContents().get(0);
		
		///*
		// * PULS
		// *
		// * Pull Registers from the Hardware Stack
		// * Source Form        : PULS register list
		//                      PULS #LABEL
		// * Operation        :
		// * Condition Codes    : May be pulled from stack; not affected otherwise.
		// * Description        : All, some, or none of the processor registers are pulled from the hardware stack (with the exception of the hardware stack pointer itself).
		// * Addressing Mode    : Immediate
		// */
		//PulsInstruction:
		//    instruction = 'PULS'
		//    WS
		//    (
		//           (operand = ImmediatOperand)
		//        |  ( registers+=Register (',' registers+=Register)*)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'PULS'
		//WS
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = 'PULS'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'PULS'
		public Keyword getInstructionPULSKeyword_0_0() { return cInstructionPULSKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(operand = ImmediatOperand)
		public Assignment getOperandAssignment_2_0() { return cOperandAssignment_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//( registers+=Register (',' registers+=Register)*)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_0() { return cRegistersAssignment_2_1_0; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_0_0() { return cRegistersRegisterEnumRuleCall_2_1_0_0; }
		
		//(',' registers+=Register)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_1_1() { return cRegistersAssignment_2_1_1_1; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_1_1_0() { return cRegistersRegisterEnumRuleCall_2_1_1_1_0; }
	}
	public class PshuInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PshuInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionPSHUKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegistersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_0_0 = (RuleCall)cRegistersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cRegistersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_1_1_0 = (RuleCall)cRegistersAssignment_2_1_1_1.eContents().get(0);
		
		///*
		// * PSHU
		// *
		// * Push Registers on the user Stack
		// * Source Form        : PSHU register list
		//                      PSHU #LABEL
		// * Operation        :
		// * Condition Codes    : not effected
		// * Description        : All, some, or none of the processor registers are pushed onto the user stack (with the exception of the user stack pointer itself).
		// * Addressing Mode    : Immediate
		// */
		//PshuInstruction:
		//    instruction = 'PSHU'
		//    WS
		//    (
		//           (operand = ImmediatOperand)
		//        |  ( registers+=Register (',' registers+=Register)*)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'PSHU'
		//WS
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = 'PSHU'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'PSHU'
		public Keyword getInstructionPSHUKeyword_0_0() { return cInstructionPSHUKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(operand = ImmediatOperand)
		public Assignment getOperandAssignment_2_0() { return cOperandAssignment_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//( registers+=Register (',' registers+=Register)*)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_0() { return cRegistersAssignment_2_1_0; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_0_0() { return cRegistersRegisterEnumRuleCall_2_1_0_0; }
		
		//(',' registers+=Register)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_1_1() { return cRegistersAssignment_2_1_1_1; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_1_1_0() { return cRegistersRegisterEnumRuleCall_2_1_1_1_0; }
	}
	public class PshsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PshsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionPSHSKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegistersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_0_0 = (RuleCall)cRegistersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cRegistersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cRegistersRegisterEnumRuleCall_2_1_1_1_0 = (RuleCall)cRegistersAssignment_2_1_1_1.eContents().get(0);
		
		///*
		// * PSHS
		// *
		// * Push Registers on the Hardware Stack
		// * Source Form        : PSHS register list
		//                      PSHS #LABEL
		// * Operation        :
		// * Condition Codes    : not effected
		// * Description        : All, some, or none of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself).
		// * Addressing Mode    : Immediate
		// */
		//PshsInstruction:
		//    instruction = 'PSHS'
		//    WS
		//    (
		//           (operand = ImmediatOperand)
		//        |  ( registers+=Register (',' registers+=Register)*)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'PSHS'
		//WS
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = 'PSHS'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'PSHS'
		public Keyword getInstructionPSHSKeyword_0_0() { return cInstructionPSHSKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       (operand = ImmediatOperand)
		//    |  ( registers+=Register (',' registers+=Register)*)
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(operand = ImmediatOperand)
		public Assignment getOperandAssignment_2_0() { return cOperandAssignment_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//( registers+=Register (',' registers+=Register)*)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_0() { return cRegistersAssignment_2_1_0; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_0_0() { return cRegistersRegisterEnumRuleCall_2_1_0_0; }
		
		//(',' registers+=Register)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//registers+=Register
		public Assignment getRegistersAssignment_2_1_1_1() { return cRegistersAssignment_2_1_1_1; }
		
		//Register
		public RuleCall getRegistersRegisterEnumRuleCall_2_1_1_1_0() { return cRegistersRegisterEnumRuleCall_2_1_1_1_0; }
	}
	public class OrccInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OrccInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionORCCKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * ORCC
		// *
		// * Inclusive OR Memory Immediate Into Condition Code Register
		// * Source Form        : ORCC #XX
		// * Operation        : R' RvMi
		// * Condition Codes    : Affected according to the operation.
		// * Description        : Performs an inclusive OR operation between the contents of the condition code registers and the immediate value, and the result is
		// *                    piaced in the condition code register. This instruction may be used to set interrupt maslcs (disable interrupts) or any other bit(s).
		// * Addressing Mode    : Immediate
		// */
		//OrccInstruction:
		//    instruction = 'ORCC'
		//    WS operand = ImmediatOperand
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'ORCC'
		//WS operand = ImmediatOperand
		public Group getGroup() { return cGroup; }
		
		//instruction = 'ORCC'
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//'ORCC'
		public Keyword getInstructionORCCKeyword_0_0() { return cInstructionORCCKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = ImmediatOperand
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0() { return cOperandImmediatOperandParserRuleCall_2_0; }
	}
	public class OrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OrInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionORAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionORBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * OR
		// *
		// * Inclusive OR Memory into Register
		// * Source Form        : ORA P; ORB P
		// * Operation        : R' RvM
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Performs an inclusive OR operation between the contents of accumulator A or B and the contents of memory location M and the result is
		// *                       stored in accumulator A or B.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//OrInstruction:
		//    instruction = ('ORA' | 'ORB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ORA' | 'ORB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ORA' | 'ORB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ORA' | 'ORB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ORA'
		public Keyword getInstructionORAKeyword_0_0_0() { return cInstructionORAKeyword_0_0_0; }
		
		//'ORB'
		public Keyword getInstructionORBKeyword_0_0_1() { return cInstructionORBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class NopInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NopInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionNOPKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * NOP
		// *
		// * No operation
		// * Source Form        : NOP
		// * Operation        : Not affected.
		// * Condition Codes    : Not affected.
		// * Description        : This instruction causes only the program counter to be incremented. No other registers
		// *                    or memory locations are affected.
		// * Addressing Mode    : Inherent
		// *
		// */
		//NopInstruction:
		//    instruction = 'NOP'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'NOP'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'NOP'
		public Keyword getInstructionNOPKeyword_0() { return cInstructionNOPKeyword_0; }
	}
	public class NegInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NegInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionNEGAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionNEGBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionNEGKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		
		///*
		// * NEG
		// *
		// * Negate
		// * Source Form        : NEG Q, NEGA; NEGB
		// * Operation        : M'0-M
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Set if the original operand was 10000000.
		// *                       C - Set if a borrow is generated; cleared otherwise.
		// * Description        : Replaces the operand with its twos complement. The (carry) bit represents a borrow and is
		// *                    set to the inverse of the resulting binary carry. Note that 80i6 is replaced by itself and
		// *                    only in this case is the  V (overflow) bit set. The value OOie is also replaced by itself,
		// *                    and only in this case is the C (carry) bit cleared.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *
		// */
		//NegInstruction:
		//    (
		//       instruction = ('NEGA' | 'NEGB')
		//    )
		//    |
		//    (
		//         instruction = ('NEG')
		//        WS operand = (
		//            DirectOperand  |
		//            ExtendedOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('NEGA' | 'NEGB')
		//)
		//|
		//(
		//     instruction = ('NEG')
		//    WS operand = (
		//        DirectOperand  |
		//        ExtendedOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('NEGA' | 'NEGB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('NEGA' | 'NEGB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'NEGA'
		public Keyword getInstructionNEGAKeyword_0_0_0() { return cInstructionNEGAKeyword_0_0_0; }
		
		//'NEGB'
		public Keyword getInstructionNEGBKeyword_0_0_1() { return cInstructionNEGBKeyword_0_0_1; }
		
		//(
		//     instruction = ('NEG')
		//    WS operand = (
		//        DirectOperand  |
		//        ExtendedOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('NEG')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('NEG')
		public Keyword getInstructionNEGKeyword_1_0_0() { return cInstructionNEGKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           ExtendedOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           ExtendedOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_1() { return cOperandExtendedOperandParserRuleCall_1_2_0_1; }
	}
	public class MulInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.MulInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionMULKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * Mul
		// *
		// * Multiply
		// * Source Form        : MUL
		// * Operation        : ACCA':ACCB'<ACCA x ACCB
		// * Condition Codes    : H - Not affected.
		// *                       N - Not affected.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected.
		// *                       C - Set if ACOB bit 7 of result is set; cleared otherwise.
		// * Description        : Multiply the unsigned binary numbers in the accumulators and place the result In both accumulators
		// *                    (ACCA contains the most significant byte of the result). Unsigned multiply allows multiple precision
		// *                    operations.
		// * Addressing Mode    : Inherent
		// */
		//MulInstruction:
		//    instruction = 'MUL'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'MUL'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'MUL'
		public Keyword getInstructionMULKeyword_0() { return cInstructionMULKeyword_0; }
	}
	public class LsrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LsrInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionLSRAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLSRBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionLSRKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * LSR
		// *
		// * Logical Shift Right
		// * Source Form        : LSR Q, LSRA; LSRB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Always cleared.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected.
		// *                       C - Loaded with bit zero of the original operand.
		// * Description        : Performs a logical shift right on the operand. Shifts a zero into bit seven and bit
		// *                    zero into the C (carry) bit.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//LsrInstruction:
		//    (
		//       instruction = ('LSRA' | 'LSRB')
		//    )
		//    |
		//    (
		//         instruction = ('LSR')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('LSRA' | 'LSRB')
		//)
		//|
		//(
		//     instruction = ('LSR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('LSRA' | 'LSRB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('LSRA' | 'LSRB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'LSRA'
		public Keyword getInstructionLSRAKeyword_0_0_0() { return cInstructionLSRAKeyword_0_0_0; }
		
		//'LSRB'
		public Keyword getInstructionLSRBKeyword_0_0_1() { return cInstructionLSRBKeyword_0_0_1; }
		
		//(
		//     instruction = ('LSR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('LSR')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('LSR')
		public Keyword getInstructionLSRKeyword_1_0_0() { return cInstructionLSRKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class LslInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LslInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionLSLAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLSLBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionLSLKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * LSL
		// *
		// * Logical Shift Left
		// * Source Form        : LSL Q, LSLA; LSLB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Shifts all bits of accumulator A or B or memory location M one place to the left.
		// *                    Bit zero is loaded with a zero. Bit seven of accumulator A or B or memory location M
		// *                    is shifted into the (carry) bit.
		// * Addressing Mode    : Inherent
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//LslInstruction:
		//    (
		//       instruction = ('LSLA' | 'LSLB')
		//    )
		//    |
		//    (
		//         instruction = ('LSL')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('LSLA' | 'LSLB')
		//)
		//|
		//(
		//     instruction = ('LSL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('LSLA' | 'LSLB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('LSLA' | 'LSLB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'LSLA'
		public Keyword getInstructionLSLAKeyword_0_0_0() { return cInstructionLSLAKeyword_0_0_0; }
		
		//'LSLB'
		public Keyword getInstructionLSLBKeyword_0_0_1() { return cInstructionLSLBKeyword_0_0_1; }
		
		//(
		//     instruction = ('LSL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('LSL')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('LSL')
		public Keyword getInstructionLSLKeyword_1_0_0() { return cInstructionLSLKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class LeaInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LeaInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionLEAXKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLEAYKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Keyword cInstructionLEASKeyword_0_0_2 = (Keyword)cInstructionAlternatives_0_0.eContents().get(2);
		private final Keyword cInstructionLEAUKeyword_0_0_3 = (Keyword)cInstructionAlternatives_0_0.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * LEA
		// *
		// * Load Effective Address
		// * Source Form        : LEAX, LEAY, LEAS, LEAU
		// * Operation        : R <- EA
		// * Condition Codes    : H - Not affected.
		// *                       N - Not affected.
		// *                       Z -  LEAX, LEAY: Set if the result is zero; cleared otherwise
		// *                         LEAS, LEAU: Not affected.
		// *                    V - Not affected.
		// *                       C - Not affected.
		// * Description        : Calculates the effective address from the indexed addressing and places the address in an
		// *                    indexable register. LEAX and LEAY affect the Z (zero) bit to allow use of these registers
		// *                    as counters and for MC6800 INX/DEX compatibility. LEAU and LEAS do not affect the Z bit to
		// *                    allow cleaning up the stack while returning the Z bit as a parameter to a calling routine,
		// *                    and also for MC6800 INS/DES compatibility.
		// * Addressing Mode    : Indexed
		// */
		//LeaInstruction:
		//     instruction = ('LEAX' | 'LEAY' | 'LEAS' | 'LEAU' )
		//    WS operand = IndexedOperand
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('LEAX' | 'LEAY' | 'LEAS' | 'LEAU' )
		//WS operand = IndexedOperand
		public Group getGroup() { return cGroup; }
		
		//instruction = ('LEAX' | 'LEAY' | 'LEAS' | 'LEAU' )
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('LEAX' | 'LEAY' | 'LEAS' | 'LEAU' )
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'LEAX'
		public Keyword getInstructionLEAXKeyword_0_0_0() { return cInstructionLEAXKeyword_0_0_0; }
		
		//'LEAY'
		public Keyword getInstructionLEAYKeyword_0_0_1() { return cInstructionLEAYKeyword_0_0_1; }
		
		//'LEAS'
		public Keyword getInstructionLEASKeyword_0_0_2() { return cInstructionLEASKeyword_0_0_2; }
		
		//'LEAU'
		public Keyword getInstructionLEAUKeyword_0_0_3() { return cInstructionLEAUKeyword_0_0_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = IndexedOperand
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0() { return cOperandIndexedOperandParserRuleCall_2_0; }
	}
	public class Ld16InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Ld16Instruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionLDDKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLDXKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Keyword cInstructionLDYKeyword_0_0_2 = (Keyword)cInstructionAlternatives_0_0.eContents().get(2);
		private final Keyword cInstructionLDSKeyword_0_0_3 = (Keyword)cInstructionAlternatives_0_0.eContents().get(3);
		private final Keyword cInstructionLDUKeyword_0_0_4 = (Keyword)cInstructionAlternatives_0_0.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * LD (16 bits)
		// *
		// * Load Register from Memory
		// * Source Form        : LDA P, LDB P
		// * Operation        : R <- M:M+1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Loads the contents of memory location M:M+1 into the designated 16 bits register.
		// * Addressing Mode    : Immediate
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//Ld16Instruction:
		//     instruction = ('LDD' | 'LDX' | 'LDY' | 'LDS' | 'LDU')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('LDD' | 'LDX' | 'LDY' | 'LDS' | 'LDU')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('LDD' | 'LDX' | 'LDY' | 'LDS' | 'LDU')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('LDD' | 'LDX' | 'LDY' | 'LDS' | 'LDU')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'LDD'
		public Keyword getInstructionLDDKeyword_0_0_0() { return cInstructionLDDKeyword_0_0_0; }
		
		//'LDX'
		public Keyword getInstructionLDXKeyword_0_0_1() { return cInstructionLDXKeyword_0_0_1; }
		
		//'LDY'
		public Keyword getInstructionLDYKeyword_0_0_2() { return cInstructionLDYKeyword_0_0_2; }
		
		//'LDS'
		public Keyword getInstructionLDSKeyword_0_0_3() { return cInstructionLDSKeyword_0_0_3; }
		
		//'LDU'
		public Keyword getInstructionLDUKeyword_0_0_4() { return cInstructionLDUKeyword_0_0_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class Ld8InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Ld8Instruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionLDAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLDBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * LD (8 bits)
		// *
		// * Load Register from Memory
		// * Source Form        : LDA P, LDB P
		// * Operation        : R <- M
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Loads the contents of memory location M into the designated register.
		// * Addressing Mode    : Immediate
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//Ld8Instruction:
		//     instruction = ('LDA' | 'LDB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('LDA' | 'LDB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('LDA' | 'LDB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('LDA' | 'LDB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'LDA'
		public Keyword getInstructionLDAKeyword_0_0_0() { return cInstructionLDAKeyword_0_0_0; }
		
		//'LDB'
		public Keyword getInstructionLDBKeyword_0_0_1() { return cInstructionLDBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class JsrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.JsrInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionJSRKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		
		///*
		// * JSR
		// *
		// * Jump to Subroutine
		// * Source Form        : JSR EA
		// * Operation        : SP' SP-1,(SP)*-PCL
		// *                    SP' SP-1,(SP)*-PCH
		// *                    PC EA
		// * Condition Codes    : Not affected.
		// * Description        : Program control is transferred to the effective address after storing the return address on the
		// *                    hardware stack. A RTS Instruction should be the last executed instruction of the subroutine.
		// * Addressing Mode    : Extended
		// *                    Direct
		// *                    Indexed
		// */
		//JsrInstruction:
		//     instruction = ('JSR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('JSR')
		//WS operand = (
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('JSR')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('JSR')
		public Keyword getInstructionJSRKeyword_0_0() { return cInstructionJSRKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_0() { return cOperandDirectOperandParserRuleCall_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_3; }
	}
	public class JmpInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.JmpInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionJMPKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		
		///*
		// * JMP
		// *
		// * Jump
		// * Source Form        : JMP EA
		// * Operation        : PC'*-EA
		// * Condition Codes    : Not affected.
		// * Description        : Program control is transferred to the effective address.
		// * Addressing Mode    : Extended
		// *                    Direct
		// *                    Indexed
		// */
		//JmpInstruction:
		//     instruction = ('JMP')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('JMP')
		//WS operand = (
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('JMP')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('JMP')
		public Keyword getInstructionJMPKeyword_0_0() { return cInstructionJMPKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_0() { return cOperandDirectOperandParserRuleCall_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_3; }
	}
	public class IncInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IncInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionINCAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionINCBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionINCKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * INC
		// *
		// * Increment
		// * Source Form        : INC Q, INCA; INCB
		// * Operation        : M' M+1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V -Set if the original operand was 01111111; cleared otherwise.
		// *                       C - Not affected.
		// * Description        : Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations.
		// *                       When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values,
		// *                       all signed branches are correctly available.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//IncInstruction:
		//    (
		//       instruction = ('INCA' | 'INCB')
		//    )
		//    |
		//    (
		//         instruction = ('INC')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('INCA' | 'INCB')
		//)
		//|
		//(
		//     instruction = ('INC')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('INCA' | 'INCB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('INCA' | 'INCB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'INCA'
		public Keyword getInstructionINCAKeyword_0_0_0() { return cInstructionINCAKeyword_0_0_0; }
		
		//'INCB'
		public Keyword getInstructionINCBKeyword_0_0_1() { return cInstructionINCBKeyword_0_0_1; }
		
		//(
		//     instruction = ('INC')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('INC')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('INC')
		public Keyword getInstructionINCKeyword_1_0_0() { return cInstructionINCKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class ExgInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ExgInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionEXGKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cReg1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReg1RegisterEnumRuleCall_2_0 = (RuleCall)cReg1Assignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cReg2Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cReg2RegisterEnumRuleCall_4_0 = (RuleCall)cReg2Assignment_4.eContents().get(0);
		
		///*
		// * EXG
		// *
		// * Exclusive OR
		// * Source Form        : EXG R1,R2
		// * Operation        : R1<->R2
		// * Condition Codes    : Not affected (unless one of the registers is the condition coderegister).
		// * Description        : Exchanges data between two designated registers. Bits 3-0 of the postbyte define one register,
		// *                    while bits 7-4 define the other, as follows:
		// *                                     0000 = A:B                1000 = A
		// *                                     0001 =X                    1001 = B
		// *                                     0010 = Y                1010 = COR
		// *                                     0011= US                1011= DPR
		// *                                     0100 = SP                1100 = Undefined
		// *                                     0101 = PC                1101 = Undefined
		// *                                     0110 = Undefined        1110 = Undefined
		// *                                     0111= Undefined            1111 = Undefined
		// *                     Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
		// * Addressing Mode    : Immediate
		// */
		//ExgInstruction:
		//    instruction = ('EXG' )
		//    WS reg1=Register ',' reg2=Register
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('EXG' )
		//WS reg1=Register ',' reg2=Register
		public Group getGroup() { return cGroup; }
		
		//instruction = ('EXG' )
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('EXG' )
		public Keyword getInstructionEXGKeyword_0_0() { return cInstructionEXGKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//reg1=Register
		public Assignment getReg1Assignment_2() { return cReg1Assignment_2; }
		
		//Register
		public RuleCall getReg1RegisterEnumRuleCall_2_0() { return cReg1RegisterEnumRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//reg2=Register
		public Assignment getReg2Assignment_4() { return cReg2Assignment_4; }
		
		//Register
		public RuleCall getReg2RegisterEnumRuleCall_4_0() { return cReg2RegisterEnumRuleCall_4_0; }
	}
	public class EorInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EorInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionEORAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionEORBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * EOR
		// *
		// * Exclusive OR
		// * Source Form        : EORA P; EORB P
		// * Operation        : R' RM
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : The contents of memory location M is exclusive ORed into an 8-blt register..
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//EorInstruction:
		//    instruction = ('EORA' | 'EORB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('EORA' | 'EORB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('EORA' | 'EORB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('EORA' | 'EORB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'EORA'
		public Keyword getInstructionEORAKeyword_0_0_0() { return cInstructionEORAKeyword_0_0_0; }
		
		//'EORB'
		public Keyword getInstructionEORBKeyword_0_0_1() { return cInstructionEORBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class DecInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DecInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionDECAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionDECBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionDECKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * DEC
		// *
		// * Decrement
		// * Source Form        : DEC Q, DECA; DECB
		// * Operation        : M' M-1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if the original operand was 10000000; cleared otherwise.
		// *                       C - Not affected.
		// * Description        : Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter
		// *                    in multipleprecision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently.
		// *                    When operating on twos complement values, all signed branches are available.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//DecInstruction:
		//    (
		//       instruction = ('DECA' | 'DECB')
		//    )
		//    |
		//    (
		//         instruction = ('DEC')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('DECA' | 'DECB')
		//)
		//|
		//(
		//     instruction = ('DEC')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('DECA' | 'DECB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('DECA' | 'DECB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'DECA'
		public Keyword getInstructionDECAKeyword_0_0_0() { return cInstructionDECAKeyword_0_0_0; }
		
		//'DECB'
		public Keyword getInstructionDECBKeyword_0_0_1() { return cInstructionDECBKeyword_0_0_1; }
		
		//(
		//     instruction = ('DEC')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('DEC')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('DEC')
		public Keyword getInstructionDECKeyword_1_0_0() { return cInstructionDECKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class DaaInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DaaInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionDAAKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * DAA
		// *
		// * Decimal Addition Adjust
		// * Source Form        : DAA
		// * Operation        : ACCA' ACCA + OF (MSN):CF(LSN)
		// *                    where OF is a Correction Factor, as follows: the CF for each nibble
		// *                    (BCD) digit is determined separately, and is either 6 or 0.
		// *
		// *                    Least Significant Nibble
		// *                    CF(LSN) = 6IFF1)C = 1
		// *                                     or2)LSN>9
		// *
		// *                    Most Significant Nibble
		// *                   CF(MSN) = 6IFF1)C = 1
		// *                                     or 2) MSN > 9
		// *                                     or 3) MSN > 8 and LSN> 9
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Undefined
		// *                       C - Set if a carry is generated or if the carry bit was set before the operation; cleared otherwise.
		// * Description        : The sequence of a single-byte add instruction on accumulator A (either ADDA or ADCA) and a following decimal addition adjust instruction results
		// *                    in a BCD addition with an appropriate carry bit. Both values to be added must be in proper BCD form (each nibble such that: 0<nibble<9).
		// *                    Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA)
		// *                    immediately prior to the next decimal addition adjust.
		// * Addressing Mode    : inherent
		// */
		//DaaInstruction:
		//    instruction = 'DAA'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'DAA'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'DAA'
		public Keyword getInstructionDAAKeyword_0() { return cInstructionDAAKeyword_0; }
	}
	public class CwaiInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CwaiInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionCWAIKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * CWAI
		// *
		// * Clear CC bits and Wait for Interrupt
		// * Source Form        : CWAI #$xx
		// * Operation        : CCR'^CCR A Ml (Possibly clear masks)
		// *                    Set E (entire state saved)
		// *                    SP' SP-1,(SP)*-PCL
		// *                    SP' SP-1,(SP) PCH
		// *                    SP'*-SP-1,(SP) USL
		// *                    SP' SP-1,(SP) USH
		// *                    SP' SP-1,(SP)*-IYL
		// *                    SP'*-SP-1,(SP) lYH
		// *                    SP' SP-1,(SP)-IXL
		// *                    SP'SP-1,(SP) IXH
		// *                    SP' SP-1,(SP)-DPR
		// *                    SP'-SP-1,(SP)-ACCB
		// *                    SP'^SP-1, (SP) ACCA
		// *                    SP' SP-1,(SP)-CCR
		// * Condition Codes    : Affected according to the operation.
		// * Description        : This instruction ANDs an immediate byte with the condition code register which may clear the
		// *                    interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then
		// *                    looks for an interrupt. When a non-masked interrupt occurs, no further machine state information
		// *                    need be saved before vectoring to the interrupt handling routine. This instruction replaced the
		// *                    MC6800 CLI WAI sequence, but does not place the buses in a high-impedance state. A FIRQ
		// *                    (fast interrupt request) may enter its interrupt handler with its entire machine state saved.
		// *                    The RTI (return from interrupt) instruction will automatically return the entire machine state
		// *                    after testing the E (entire) bit of the recovered condition code register.
		// * Addressing Mode    : Immediate
		// */
		//CwaiInstruction:
		//     instruction = ('CWAI')
		//    WS operand = (
		//        ImmediatOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('CWAI')
		//WS operand = (
		//    ImmediatOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('CWAI')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('CWAI')
		public Keyword getInstructionCWAIKeyword_0_0() { return cInstructionCWAIKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand
		//   )
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0() { return cOperandImmediatOperandParserRuleCall_2_0; }
	}
	public class ComInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ComInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionCOMAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionCOMBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionCOMKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * COM
		// *
		// * Complement
		// * Source Form        : COM Q, COMA; COMB
		// * Operation        : M'< 0 + !M
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Always cleared.
		// *                       C - Always set.
		// * Description        : Replaces the contents of memory location M or accumulator A or B with its logical complement.
		// *                    When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly
		// *                    following a COM instruction. When operating on twos complement values, all signed branches are
		// *                    available.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//ComInstruction:
		//    (
		//        instruction = ('COMA' | 'COMB')
		//    )
		//    |
		//    (
		//         instruction = ('COM')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//    instruction = ('COMA' | 'COMB')
		//)
		//|
		//(
		//     instruction = ('COM')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//    instruction = ('COMA' | 'COMB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('COMA' | 'COMB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'COMA'
		public Keyword getInstructionCOMAKeyword_0_0_0() { return cInstructionCOMAKeyword_0_0_0; }
		
		//'COMB'
		public Keyword getInstructionCOMBKeyword_0_0_1() { return cInstructionCOMBKeyword_0_0_1; }
		
		//(
		//     instruction = ('COM')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('COM')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('COM')
		public Keyword getInstructionCOMKeyword_1_0_0() { return cInstructionCOMKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class CmpInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CmpInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionCMPAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionCMPBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * CMP
		// *
		// * Compare Memory from Register
		// * Source Form        : CMPA Q, CMPB Q
		// * Operation        : TEMP<-R_M
		// * Condition Codes    : H - Undefined.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result is zero; cleared otherwise.
		// *                    V - Set if an overflow is generated; cleared otherwise.
		// *                       C - Set if a borrow is generated; cleared otherwise.
		// * Description        : Compares the contents of memory location to the contents of the specified register and sets the
		// *                    appropriate condition codes. Neither memory location M nor the specified register is modified.
		// *                    The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
		// * Addressing Mode    : Immediate
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//CmpInstruction:
		//     instruction = ('CMPA' | 'CMPB')
		//    WS operand = (
		//        ImmediatOperand      |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('CMPA' | 'CMPB')
		//WS operand = (
		//    ImmediatOperand      |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('CMPA' | 'CMPB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('CMPA' | 'CMPB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'CMPA'
		public Keyword getInstructionCMPAKeyword_0_0_0() { return cInstructionCMPAKeyword_0_0_0; }
		
		//'CMPB'
		public Keyword getInstructionCMPBKeyword_0_0_1() { return cInstructionCMPBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand      |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand      |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class ClrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ClrInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionCLRAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionCLRBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionCLRKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * CLR
		// *
		// * Clear
		// * Source Form        : CLR Q, CLRA; CLRB
		// * Operation        : TEMP<-M
		// *                    : M<OO16
		// * Condition Codes    : H - Not affected.
		// *                       N - Always cleared.
		// *                       Z - Always set.
		// *                    V - Always cleared.
		// *                       C - Always cleared.
		// * Description        : Accumulator A or B or memory location M is loaded with 00000000.
		// *                       Note that the EA is read during this operation.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//ClrInstruction:
		//    (
		//        instruction = ('CLRA' | 'CLRB')
		//    )
		//    |
		//    (
		//         instruction = ('CLR')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//    instruction = ('CLRA' | 'CLRB')
		//)
		//|
		//(
		//     instruction = ('CLR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//    instruction = ('CLRA' | 'CLRB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('CLRA' | 'CLRB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'CLRA'
		public Keyword getInstructionCLRAKeyword_0_0_0() { return cInstructionCLRAKeyword_0_0_0; }
		
		//'CLRB'
		public Keyword getInstructionCLRBKeyword_0_0_1() { return cInstructionCLRBKeyword_0_0_1; }
		
		//(
		//     instruction = ('CLR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('CLR')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('CLR')
		public Keyword getInstructionCLRKeyword_1_0_0() { return cInstructionCLRKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class BvsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BvsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBVSKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBVSKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BVS
		// *
		// * Branch on Overflow set
		// * Source Form        : BVS dd; LBVS DDDD
		// * Operation        : TEMP-MI
		// *                    IFF V = 1 then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the
		// *                    twos complement result was valid. When used after an operation on twos complement binary values, this
		// *                    instruction will branch if there was no overflow.
		// * Addressing Mode    : Relative
		// */
		//BvsInstruction:
		//     instruction = ('BVS' | 'LBVS')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BVS' | 'LBVS')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BVS' | 'LBVS')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BVS' | 'LBVS')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BVS'
		public Keyword getInstructionBVSKeyword_0_0_0() { return cInstructionBVSKeyword_0_0_0; }
		
		//'LBVS'
		public Keyword getInstructionLBVSKeyword_0_0_1() { return cInstructionLBVSKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BvcInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BvcInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBVCKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBVCKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BVC
		// *
		// * Branch on Overflow Clear
		// * Source Form        : BVC dd; LBVC DDDD
		// * Operation        : TEMP-MI
		// *                    IFF V = 0 then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the
		// *                    twos complement result was valid. When used after an operation on twos complement binary values, this
		// *                    instruction will branch if there was no overflow.
		// * Addressing Mode    : Relative
		// */
		//BvcInstruction:
		//     instruction = ('BVC' | 'LBVC')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BVC' | 'LBVC')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BVC' | 'LBVC')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BVC' | 'LBVC')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BVC'
		public Keyword getInstructionBVCKeyword_0_0_0() { return cInstructionBVCKeyword_0_0_0; }
		
		//'LBVC'
		public Keyword getInstructionLBVCKeyword_0_0_1() { return cInstructionLBVCKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BsrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BsrInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBSRKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBSRKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BSR
		// *
		// * Branch to Subroutine
		// * Source Form        : BSR dd; LBSR DDDD
		// * Operation        : TEMP-MI
		// *                    SP' SP-1,(SP) POL
		// *                       SP'-SP-1,(SP) PCH
		// *                       PC PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : The program counter is pushed onto the stack. The program counter is then loaded with the sum
		// *                       of the program counter and the offset.
		// * Addressing Mode    : Relative
		// */
		//BsrInstruction:
		//     instruction = ('BSR' | 'LBSR')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BSR' | 'LBSR')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BSR' | 'LBSR')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BSR' | 'LBSR')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BSR'
		public Keyword getInstructionBSRKeyword_0_0_0() { return cInstructionBSRKeyword_0_0_0; }
		
		//'LBSR'
		public Keyword getInstructionLBSRKeyword_0_0_1() { return cInstructionLBSRKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BrnInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BrnInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBRNKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBRNKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BRN
		// *
		// * Branch Never
		// * Source Form        : BRN dd; LBRN DDDD
		// * Operation        : TEMP-MI
		// * Condition Codes    : Not affected.
		// * Description        : Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
		// * Addressing Mode    : Relative
		// */
		//BrnInstruction:
		//     instruction = ('BRN' | 'LBRN')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BRN' | 'LBRN')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BRN' | 'LBRN')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BRN' | 'LBRN')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BRN'
		public Keyword getInstructionBRNKeyword_0_0_0() { return cInstructionBRNKeyword_0_0_0; }
		
		//'LBRN'
		public Keyword getInstructionLBRNKeyword_0_0_1() { return cInstructionLBRNKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BraInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BraInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBRAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBRAKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BRA
		// *
		// * Branch always
		// * Source Form        : BRA dd; LBRA DDDD
		// * Operation        : TEMP-MI
		// *                    PC PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes an unconditlonai branch.
		// * Addressing Mode    : Relative
		// */
		//BraInstruction:
		//     instruction = ('BRA' | 'LBRA')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BRA' | 'LBRA')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BRA' | 'LBRA')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BRA' | 'LBRA')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BRA'
		public Keyword getInstructionBRAKeyword_0_0_0() { return cInstructionBRAKeyword_0_0_0; }
		
		//'LBRA'
		public Keyword getInstructionLBRAKeyword_0_0_1() { return cInstructionLBRAKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BplInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BplInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBPLKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBPLKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BPL
		// *
		// * Branch on plus
		// * Source Form        : BPL dd; LBPL DDDD
		// * Operation        : TEMP-MI
		// *                    IFF N=0 then PC PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of
		// *                    the twos complement result is positive.
		// * Addressing Mode    : Relative
		// */
		//BplInstruction:
		//     instruction = ('BPL' | 'LBPL')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BPL' | 'LBPL')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BPL' | 'LBPL')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BPL' | 'LBPL')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BPL'
		public Keyword getInstructionBPLKeyword_0_0_0() { return cInstructionBPLKeyword_0_0_0; }
		
		//'LBPL'
		public Keyword getInstructionLBPLKeyword_0_0_1() { return cInstructionLBPLKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BneInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BneInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBNEKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBNEKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BNE
		// *
		// * Branch not equal
		// * Source Form        : BNE dd; LBNE DDDD
		// * Operation        : TEMP-MI
		// *                    IFF Z = then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare
		// *                       operation on any binary values, this instruction will branch if the register is, or would be, not equal to the
		// *                    memory operand.
		// * Addressing Mode    : Relative
		// */
		//BneInstruction:
		//     instruction = ('BNE' | 'LBNE')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BNE' | 'LBNE')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BNE' | 'LBNE')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BNE' | 'LBNE')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BNE'
		public Keyword getInstructionBNEKeyword_0_0_0() { return cInstructionBNEKeyword_0_0_0; }
		
		//'LBNE'
		public Keyword getInstructionLBNEKeyword_0_0_1() { return cInstructionLBNEKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BmiInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BmiInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBMIKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBMIKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BMI
		// *
		// * Branch on Minus
		// * Source Form        : BMI dd; LBMI DDDD
		// * Operation        : TEMP-MI
		// *                    IFF N = 1 then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the N (negative) bit and causes a branch if set.
		// *                      That is, branch if the sign of the twos compiement result is negative.
		// * Addressing Mode    : Relative
		// */
		//BmiInstruction:
		//     instruction = ('BMI' | 'LBMI')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BMI' | 'LBMI')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BMI' | 'LBMI')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BMI' | 'LBMI')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BMI'
		public Keyword getInstructionBMIKeyword_0_0_0() { return cInstructionBMIKeyword_0_0_0; }
		
		//'LBMI'
		public Keyword getInstructionLBMIKeyword_0_0_1() { return cInstructionLBMIKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BltInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BltInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBLTKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBLTKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BLT
		// *
		// * Branch on Less than Zero
		// * Source Form        : BLT dd; LBLT DDDD
		// * Operation        : TEMP-MI
		// *                    IFF [NeV]=1 then PCPC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch
		// *                    if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare
		// *                    operation on twos complement binary values, this instruction will branch if the register was less than the memory
		// *                    operand.
		// * Addressing Mode    : Relative
		// */
		//BltInstruction:
		//     instruction = ('BLT' | 'LBLT')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BLT' | 'LBLT')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BLT' | 'LBLT')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BLT' | 'LBLT')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BLT'
		public Keyword getInstructionBLTKeyword_0_0_0() { return cInstructionBLTKeyword_0_0_0; }
		
		//'LBLT'
		public Keyword getInstructionLBLTKeyword_0_0_1() { return cInstructionLBLTKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BlsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BlsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBLSKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBLSKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BLS
		// *
		// * Branch on Lower
		// * Source Form        : BLS dd; LBLS DDDD
		// * Operation        : TEMP-MI
		// *                    IFF(CvZ) = 1 then PC PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or
		// *                    compare operation on unsigned binary values, this instruction will branch if the register was lower than or the
		// *                    same as the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BlsInstruction:
		//     instruction = ('BLS' | 'LBLS')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BLS' | 'LBLS')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BLS' | 'LBLS')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BLS' | 'LBLS')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BLS'
		public Keyword getInstructionBLSKeyword_0_0_0() { return cInstructionBLSKeyword_0_0_0; }
		
		//'LBLS'
		public Keyword getInstructionLBLSKeyword_0_0_1() { return cInstructionLBLSKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BloInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BloInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBLOKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBLOKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BLO
		// *
		// * Branch on Lower
		// * Source Form        : BLO dd; LBLO DDDD
		// * Operation        : TEMP-MI
		// *                    IFF = 1 then PO'*-PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned
		// *                    binary values, this instruction will branch if the register was lower than the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BloInstruction:
		//     instruction = ('BLO' | 'LBLO')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BLO' | 'LBLO')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BLO' | 'LBLO')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BLO' | 'LBLO')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BLO'
		public Keyword getInstructionBLOKeyword_0_0_0() { return cInstructionBLOKeyword_0_0_0; }
		
		//'LBLO'
		public Keyword getInstructionLBLOKeyword_0_0_1() { return cInstructionLBLOKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BleInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BleInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBLEKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBLEKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BLE
		// *
		// * Branch on Less than or Equal to Zero
		// * Source Form        : BLE dd; LBLE DDDD
		// * Operation        : TEMP-MI
		// *                    IFF Z V [N  V] = 1 then PC- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set.
		// *                    That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract
		// *                    or compare operation on twos complement values, this instruction will branch if the register was less than or equal
		// *                    to the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BleInstruction:
		//     instruction = ('BLE' | 'LBLE')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BLE' | 'LBLE')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BLE' | 'LBLE')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BLE' | 'LBLE')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BLE'
		public Keyword getInstructionBLEKeyword_0_0_0() { return cInstructionBLEKeyword_0_0_0; }
		
		//'LBLE'
		public Keyword getInstructionLBLEKeyword_0_0_1() { return cInstructionLBLEKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BitInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BitInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBITAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionBITBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * BIT
		// *
		// * Bit Test
		// * Source Form        : Bit P
		// * Operation        : TEMP RAM
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V -  Always cleared
		// *                       C - Not affected.
		// * Description        : Performs the logical AND of the contents of accumulator A or B and the contents of memory location M and modifies the condition
		// *                    codes accordingly. The contents of accumulator A or B and memory location M are not affected.
		// * Addressing Mode    : Immediate
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//BitInstruction:
		//    instruction = ('BITA' | 'BITB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('BITA' | 'BITB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BITA' | 'BITB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BITA' | 'BITB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BITA'
		public Keyword getInstructionBITAKeyword_0_0_0() { return cInstructionBITAKeyword_0_0_0; }
		
		//'BITB'
		public Keyword getInstructionBITBKeyword_0_0_1() { return cInstructionBITBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class BhsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BhsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBHSKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBHSKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BHS
		// *
		// * Branch if Higher or Same
		// * Source Form        : BHS dd; LBHS DDDD
		// * Operation        : TEMP Ml
		// *                    IFF C = 0 then PC'^PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the C (carry) bit and causes a branch if it is clear.
		// *                    When used after a subtract or compare on unsigned binary values,
		// *                    this instruction will branch if the register was higher than or the
		// *                    same as the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BhsInstruction:
		//     instruction = ('BHS' | 'LBHS')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BHS' | 'LBHS')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BHS' | 'LBHS')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BHS' | 'LBHS')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BHS'
		public Keyword getInstructionBHSKeyword_0_0_0() { return cInstructionBHSKeyword_0_0_0; }
		
		//'LBHS'
		public Keyword getInstructionLBHSKeyword_0_0_1() { return cInstructionLBHSKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BhiInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BhiInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBHIKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBHIKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BHI
		// *
		// * Branch if Higher
		// * Source Form        : BHI dd; LBHI DDDD
		// * Operation        : TEMP Ml
		// *                    IFF [0 V Z] = 0 then PC'^PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if the previous operation caused neither a carry nor
		// *                    a zero result. When used after a subtract or compare operation on
		// *                    unsigned binary values, this instruction will branch if the register
		// *                    was higher than the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BhiInstruction:
		//     instruction = ('BHI' | 'LBHI')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BHI' | 'LBHI')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BHI' | 'LBHI')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BHI' | 'LBHI')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BHI'
		public Keyword getInstructionBHIKeyword_0_0_0() { return cInstructionBHIKeyword_0_0_0; }
		
		//'LBHI'
		public Keyword getInstructionLBHIKeyword_0_0_1() { return cInstructionLBHIKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BgtInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BgtInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBGTKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBGTKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BGT
		// *
		// * Branch on Greater than or Equal to Zero
		// * Source Form        : BGT dd; LBGT DDDD
		// * Operation        : TEMP Ml
		// *                    IFF ZA[NV] = 0 then PC'^PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if the N (negative) bit and V (overflow) bit are either
		// *                      both set or both clear and the Z (zero) bit is clear. In other words,
		// *                       branch if the sign of a valid twos complement result is, or would be,
		// *                       positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the
		// *                       register was greater than the memory operand.
		// * Addressing Mode    : Relative
		// */
		//BgtInstruction:
		//     instruction = ('BGT' | 'LBGT')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BGT' | 'LBGT')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BGT' | 'LBGT')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BGT' | 'LBGT')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BGT'
		public Keyword getInstructionBGTKeyword_0_0_0() { return cInstructionBGTKeyword_0_0_0; }
		
		//'LBGT'
		public Keyword getInstructionLBGTKeyword_0_0_1() { return cInstructionLBGTKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BgeInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BgeInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBGEKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBGEKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BGE
		// *
		// * Branch on Greater than or Equal to Zero
		// * Source Form        : BGE dd; LBGE DDDD
		// * Operation        : TEMP Ml
		// *                    IFF [NV] = then PC'^PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Causes a branch if the N (negative) bit and the V (overflow) bit are
		// *                      either both set or both clear. That is, branch if the sign of a valid
		// *                    twos complement result is, or would be, positive. When used after a
		// *                    subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the
		// *                    memory operand.
		// * Addressing Mode    : Relative
		// */
		//BgeInstruction:
		//     instruction = ('BGE' | 'LBGE')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BGE' | 'LBGE')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BGE' | 'LBGE')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BGE' | 'LBGE')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BGE'
		public Keyword getInstructionBGEKeyword_0_0_0() { return cInstructionBGEKeyword_0_0_0; }
		
		//'LBGE'
		public Keyword getInstructionLBGEKeyword_0_0_1() { return cInstructionLBGEKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BeqInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BeqInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBEQKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBEQKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BEQ
		// *
		// * Branch on Equal
		// * Source Form        : BEQ dd; LBEQ DDDD
		// * Operation        : TEMP Ml
		// *                    IFF Z=1  then PC'<- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the Z (zero) bit and causes a branch if it is set.
		// *                       When used after a subtract or compare operation, this Instruction
		// *                       will branch If the compared values, signed or unsigned, were exactly
		// *                       the same.
		// * Addressing Mode    : Relative
		// */
		//BeqInstruction:
		//     instruction = ('BEQ' | 'LBEQ')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BEQ' | 'LBEQ')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BEQ' | 'LBEQ')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BEQ' | 'LBEQ')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BEQ'
		public Keyword getInstructionBEQKeyword_0_0_0() { return cInstructionBEQKeyword_0_0_0; }
		
		//'LBEQ'
		public Keyword getInstructionLBEQKeyword_0_0_1() { return cInstructionLBEQKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BcsInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BcsInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBCSKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBCSKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BCS
		// *
		// * Branch on Carry Set
		// * Source Form        : BCS dd; LBCS DDDD
		// * Operation        : TEMP Ml
		// *                    IFF C=A  then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the C (carry) bit and causes a branch If it Is set.
		// * Addressing Mode    : Relative
		// */
		//BcsInstruction:
		//     instruction = ('BCS' | 'LBCS')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BCS' | 'LBCS')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BCS' | 'LBCS')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BCS' | 'LBCS')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BCS'
		public Keyword getInstructionBCSKeyword_0_0_0() { return cInstructionBCSKeyword_0_0_0; }
		
		//'LBCS'
		public Keyword getInstructionLBCSKeyword_0_0_1() { return cInstructionLBCSKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class BccInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BccInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionBCCKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionLBCCKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandRelativeModeParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * BCC
		// *
		// * Branch on Carry Clear
		// * Source Form        : BCC dd; LBCC DDDD
		// * Operation        : TEMP Ml
		// *                    IFF C = then PC'*- PC + TEMP
		// * Condition Codes    : Not affected.
		// * Description        : Tests the state of the C (carry) bit and causes a branch If it Is clear.
		// * Addressing Mode    : Relative
		// */
		//BccInstruction:
		//     instruction = ('BCC' | 'LBCC')
		//    WS operand = RelativeMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// instruction = ('BCC' | 'LBCC')
		//WS operand = RelativeMode
		public Group getGroup() { return cGroup; }
		
		//instruction = ('BCC' | 'LBCC')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('BCC' | 'LBCC')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'BCC'
		public Keyword getInstructionBCCKeyword_0_0_0() { return cInstructionBCCKeyword_0_0_0; }
		
		//'LBCC'
		public Keyword getInstructionLBCCKeyword_0_0_1() { return cInstructionLBCCKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = RelativeMode
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//RelativeMode
		public RuleCall getOperandRelativeModeParserRuleCall_2_0() { return cOperandRelativeModeParserRuleCall_2_0; }
	}
	public class AsrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AsrInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionASRAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionASRBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionASRKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * ASR
		// *
		// * Arithmetic Shift Right
		// * Source Form        : ASR Q, ASLA; ASLB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AsrInstruction:
		//    (
		//        instruction = ('ASRA' | 'ASRB')
		//    )
		//    |
		//    (
		//         instruction = ('ASR')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//    instruction = ('ASRA' | 'ASRB')
		//)
		//|
		//(
		//     instruction = ('ASR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//    instruction = ('ASRA' | 'ASRB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ASRA' | 'ASRB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ASRA'
		public Keyword getInstructionASRAKeyword_0_0_0() { return cInstructionASRAKeyword_0_0_0; }
		
		//'ASRB'
		public Keyword getInstructionASRBKeyword_0_0_1() { return cInstructionASRBKeyword_0_0_1; }
		
		//(
		//     instruction = ('ASR')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('ASR')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('ASR')
		public Keyword getInstructionASRKeyword_1_0_0() { return cInstructionASRKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class AslInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AslInstruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionASLAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionASLBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInstructionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cInstructionASLKeyword_1_0_0 = (Keyword)cInstructionAssignment_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_1_2_0 = (Alternatives)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_1_2_0_2 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3 = (RuleCall)cOperandAlternatives_1_2_0.eContents().get(3);
		
		///*
		// * ASL
		// *
		// * Arithmetic Shift Left
		// * Source Form        : ASL Q, ASLA; ASLB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is
		// *                    shifted into the C (carry) bit.
		// * Addressing Mode    : Inherent
		// */
		//AslInstruction:
		//    (
		//       instruction = ('ASLA' | 'ASLB')
		//    )
		//    |
		//    (
		//         instruction = ('ASL')
		//        WS operand = (
		//            DirectOperand  |
		//            IndexedOperand |
		//            ExtendedOperand |
		//            ExtendedIndirectOperand
		//        )
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//   instruction = ('ASLA' | 'ASLB')
		//)
		//|
		//(
		//     instruction = ('ASL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(
		//   instruction = ('ASLA' | 'ASLB')
		//)
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ASLA' | 'ASLB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ASLA'
		public Keyword getInstructionASLAKeyword_0_0_0() { return cInstructionASLAKeyword_0_0_0; }
		
		//'ASLB'
		public Keyword getInstructionASLBKeyword_0_0_1() { return cInstructionASLBKeyword_0_0_1; }
		
		//(
		//     instruction = ('ASL')
		//    WS operand = (
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//instruction = ('ASL')
		public Assignment getInstructionAssignment_1_0() { return cInstructionAssignment_1_0; }
		
		//('ASL')
		public Keyword getInstructionASLKeyword_1_0_0() { return cInstructionASLKeyword_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1() { return cWSTerminalRuleCall_1_1; }
		
		//operand = (
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//(
		//           DirectOperand  |
		//           IndexedOperand |
		//           ExtendedOperand |
		//           ExtendedIndirectOperand
		//       )
		public Alternatives getOperandAlternatives_1_2_0() { return cOperandAlternatives_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_1_2_0_0() { return cOperandDirectOperandParserRuleCall_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_1_2_0_3; }
	}
	public class AndCCInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AndCCInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionANDCCKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// * ANDCC
		// *
		// * Logical AND Immediate Memory into Condition Code Register
		// * Source Form        : ANDOG #xx
		// * Operation        : R' R A Ml
		// * Condition Codes    : Affected according to the operation.
		// * Description        : PPerforms a logical AND between the condition code register and the Immediate byte specified In
		// *                    the instruction and places the result in the condition code register.
		// * Addressing Mode    : Immediate
		// */
		//AndCCInstruction:
		//    instruction = ('ANDCC')
		//    WS operand = (
		//        ImmediatOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ANDCC')
		//WS operand = (
		//    ImmediatOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ANDCC')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ANDCC')
		public Keyword getInstructionANDCCKeyword_0_0() { return cInstructionANDCCKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand
		//   )
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0() { return cOperandImmediatOperandParserRuleCall_2_0; }
	}
	public class AndInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AndInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionANDAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionANDBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * AND
		// *
		// * Logical AND Memory into Register
		// * Source Form        : ANDA P; ANDB P
		// * Operation        : R' RAM
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Performs the logical AND operation between the contents of an accumulator and the contents
		// *                       of memory location M and the result is stored in the accumulator.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AndInstruction:
		//    instruction = ('ANDA' | 'ANDB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ANDA' | 'ANDB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ANDA' | 'ANDB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ANDA' | 'ANDB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ANDA'
		public Keyword getInstructionANDAKeyword_0_0_0() { return cInstructionANDAKeyword_0_0_0; }
		
		//'ANDB'
		public Keyword getInstructionANDBKeyword_0_0_1() { return cInstructionANDBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class AdddInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AdddInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInstructionADDDKeyword_0_0 = (Keyword)cInstructionAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * ADDD
		// *
		// * Add Memory into Register
		// * Source Form        : ADDD P
		// * Operation        : R' R + M:M + 1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if an overflow is generated; cleared otherwise,
		// *                       C - Set if a carry is generated; cleared otherwise.
		// * Description        : Adds the 16-bit memory value into the 16-bit accumulator
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AdddInstruction:
		//    instruction = ('ADDD')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ADDD')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ADDD')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ADDD')
		public Keyword getInstructionADDDKeyword_0_0() { return cInstructionADDDKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class AddInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AddInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionADDAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionADDBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * ADD
		// *
		// * Add Memory into Register
		// * Source Form        : ADDA P; ADDB P
		// * Operation        : R' R + M
		// * Condition Codes    : H - Set if a half-carry is generated; cleared otherwise,
		// *                       N - Set if the result Is negative; cleared otherwise,
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if an overflow is generated; cleared otherwise,
		// *                       C - Set if a carry is generated; cleared otherwise.
		// * Description        : Adds the memory byte into an 8-bit accumulator.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AddInstruction:
		//    instruction = ('ADDA' | 'ADDB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ADDA' | 'ADDB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ADDA' | 'ADDB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ADDA' | 'ADDB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ADDA'
		public Keyword getInstructionADDAKeyword_0_0_0() { return cInstructionADDAKeyword_0_0_0; }
		
		//'ADDB'
		public Keyword getInstructionADDBKeyword_0_0_1() { return cInstructionADDBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class AdcInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AdcInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cInstructionAlternatives_0_0 = (Alternatives)cInstructionAssignment_0.eContents().get(0);
		private final Keyword cInstructionADCAKeyword_0_0_0 = (Keyword)cInstructionAlternatives_0_0.eContents().get(0);
		private final Keyword cInstructionADCBKeyword_0_0_1 = (Keyword)cInstructionAlternatives_0_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_0 = (Alternatives)cOperandAssignment_2.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_2_0_0 = (RuleCall)cOperandAlternatives_2_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_0_1 = (RuleCall)cOperandAlternatives_2_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_0_2 = (RuleCall)cOperandAlternatives_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_0_3 = (RuleCall)cOperandAlternatives_2_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_0_4 = (RuleCall)cOperandAlternatives_2_0.eContents().get(4);
		
		///*
		// * ADC
		// *
		// * Add with Carry into Register
		// * Source Form        : ADCA P; ADCB P
		// * Operation        : R'*-R + M + C
		// * Condition Codes    : H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
		// *                       N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
		// *                       Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
		// *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
		// *                       C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
		// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AdcInstruction:
		//    instruction = ('ADCA' | 'ADCB')
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = ('ADCA' | 'ADCB')
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		public Group getGroup() { return cGroup; }
		
		//instruction = ('ADCA' | 'ADCB')
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//('ADCA' | 'ADCB')
		public Alternatives getInstructionAlternatives_0_0() { return cInstructionAlternatives_0_0; }
		
		//'ADCA'
		public Keyword getInstructionADCAKeyword_0_0_0() { return cInstructionADCAKeyword_0_0_0; }
		
		//'ADCB'
		public Keyword getInstructionADCBKeyword_0_0_1() { return cInstructionADCBKeyword_0_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_2_0() { return cOperandAlternatives_2_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_2_0_0() { return cOperandImmediatOperandParserRuleCall_2_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_0_1() { return cOperandDirectOperandParserRuleCall_2_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_0_2() { return cOperandIndexedOperandParserRuleCall_2_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_0_3() { return cOperandExtendedOperandParserRuleCall_2_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_2_0_4; }
	}
	public class AbxInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AbxInstruction");
		private final Assignment cInstructionAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cInstructionABXKeyword_0 = (Keyword)cInstructionAssignment.eContents().get(0);
		
		///*
		// * ABX
		// *
		// * Add Accumulator B into Index Register X
		// * Source Form        : ABX
		// * Operation        : IX' IX + ACCB
		// * Condition Codes    : Not affected.
		// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
		// * Addressing Mode    : Inherent
		// */
		//AbxInstruction:
		//    instruction = 'ABX'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = 'ABX'
		public Assignment getInstructionAssignment() { return cInstructionAssignment; }
		
		//'ABX'
		public Keyword getInstructionABXKeyword_0() { return cInstructionABXKeyword_0; }
	}
	public class ExtendedIndirectOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ExtendedIndirectOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///*
		// * Extended Indirect
		// *
		// * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to
		// * two bytes in memory which are used as the effective address.
		// *
		// * Example:
		// * LDA [$A012] loads A from the address stored at locations $A012 and $A013
		// */
		//ExtendedIndirectOperand:
		//    '[' operand=Expression ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'[' operand=Expression ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ExtendedOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ExtendedOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		///*
		// * Extended
		// *
		// * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
		// * memory address value.
		// *
		// * Example:
		// * LDA $1000 load A from memory location 1000 hex
		// */
		//ExtendedOperand:
		//    ('>'?) operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//('>'?) operand=Expression
		public Group getGroup() { return cGroup; }
		
		//('>'?)
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class DirectOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DirectOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		////
		////IndexedOperand:
		////
		////;
		///*
		// * Direct
		// * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
		// * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
		// * found in the Direct Page register. Thus, the effective address is a concatenation of the
		// * Direct Page register as the most significant half and the byte following the opcode as the
		// * least significant half.
		// *
		// * Example:
		// * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register
		// */
		//DirectOperand:
		//    '<' operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<' operand=Expression
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class ImmediatOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ImmediatOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		///*
		// * Immediate
		// * In Immediate addressing the byte or bytes following the opcode are the information being
		// * addressed. These byte or bytes are specified as part of the instruction.
		// *
		// * Example:
		// * LDA #8 load immediate value (8) into A
		// */
		//ImmediatOperand:
		//    '#' operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'#' operand=Expression
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class IndexedOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IndexedOperand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cModeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cModeAutoIncDecModeParserRuleCall_0_0 = (RuleCall)cModeAssignment_0.eContents().get(0);
		private final Assignment cModeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cModeConstantIndexedModeParserRuleCall_1_0 = (RuleCall)cModeAssignment_1.eContents().get(0);
		private final Assignment cModeAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cModeAccumulatorMovingModeParserRuleCall_2_0 = (RuleCall)cModeAssignment_2.eContents().get(0);
		private final Assignment cModeAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cModeRelatifToPCModeParserRuleCall_3_0 = (RuleCall)cModeAssignment_3.eContents().get(0);
		private final Assignment cModeAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cModeConstantIndexedMovingIndirectModeParserRuleCall_4_0 = (RuleCall)cModeAssignment_4.eContents().get(0);
		private final Assignment cModeAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cModeAutoIncDecIndirectModeParserRuleCall_5_0 = (RuleCall)cModeAssignment_5.eContents().get(0);
		private final Assignment cModeAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cModeAccumulatorMovingIndirectModeParserRuleCall_6_0 = (RuleCall)cModeAssignment_6.eContents().get(0);
		private final Assignment cModeAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cModeRelatifToPCIndirectModeParserRuleCall_7_0 = (RuleCall)cModeAssignment_7.eContents().get(0);
		
		//IndexedOperand:
		//    mode=AutoIncDecMode  |
		//    mode=ConstantIndexedMode |
		//    mode=AccumulatorMovingMode |
		//    mode=RelatifToPCMode |
		//    mode=ConstantIndexedMovingIndirectMode |
		//    mode=AutoIncDecIndirectMode  |
		//    mode=AccumulatorMovingIndirectMode |
		//    mode=RelatifToPCIndirectMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//mode=AutoIncDecMode  |
		//mode=ConstantIndexedMode |
		//mode=AccumulatorMovingMode |
		//mode=RelatifToPCMode |
		//mode=ConstantIndexedMovingIndirectMode |
		//mode=AutoIncDecIndirectMode  |
		//mode=AccumulatorMovingIndirectMode |
		//mode=RelatifToPCIndirectMode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//mode=AutoIncDecMode
		public Assignment getModeAssignment_0() { return cModeAssignment_0; }
		
		//AutoIncDecMode
		public RuleCall getModeAutoIncDecModeParserRuleCall_0_0() { return cModeAutoIncDecModeParserRuleCall_0_0; }
		
		//mode=ConstantIndexedMode
		public Assignment getModeAssignment_1() { return cModeAssignment_1; }
		
		//ConstantIndexedMode
		public RuleCall getModeConstantIndexedModeParserRuleCall_1_0() { return cModeConstantIndexedModeParserRuleCall_1_0; }
		
		//mode=AccumulatorMovingMode
		public Assignment getModeAssignment_2() { return cModeAssignment_2; }
		
		//AccumulatorMovingMode
		public RuleCall getModeAccumulatorMovingModeParserRuleCall_2_0() { return cModeAccumulatorMovingModeParserRuleCall_2_0; }
		
		//mode=RelatifToPCMode
		public Assignment getModeAssignment_3() { return cModeAssignment_3; }
		
		//RelatifToPCMode
		public RuleCall getModeRelatifToPCModeParserRuleCall_3_0() { return cModeRelatifToPCModeParserRuleCall_3_0; }
		
		//mode=ConstantIndexedMovingIndirectMode
		public Assignment getModeAssignment_4() { return cModeAssignment_4; }
		
		//ConstantIndexedMovingIndirectMode
		public RuleCall getModeConstantIndexedMovingIndirectModeParserRuleCall_4_0() { return cModeConstantIndexedMovingIndirectModeParserRuleCall_4_0; }
		
		//mode=AutoIncDecIndirectMode
		public Assignment getModeAssignment_5() { return cModeAssignment_5; }
		
		//AutoIncDecIndirectMode
		public RuleCall getModeAutoIncDecIndirectModeParserRuleCall_5_0() { return cModeAutoIncDecIndirectModeParserRuleCall_5_0; }
		
		//mode=AccumulatorMovingIndirectMode
		public Assignment getModeAssignment_6() { return cModeAssignment_6; }
		
		//AccumulatorMovingIndirectMode
		public RuleCall getModeAccumulatorMovingIndirectModeParserRuleCall_6_0() { return cModeAccumulatorMovingIndirectModeParserRuleCall_6_0; }
		
		//mode=RelatifToPCIndirectMode
		public Assignment getModeAssignment_7() { return cModeAssignment_7; }
		
		//RelatifToPCIndirectMode
		public RuleCall getModeRelatifToPCIndirectModeParserRuleCall_7_0() { return cModeRelatifToPCIndirectModeParserRuleCall_7_0; }
	}
	public class ConstantIndexedModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ConstantIndexedMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cRegisterAlternatives_2_0 = (Alternatives)cRegisterAssignment_2.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_0 = (Keyword)cRegisterAlternatives_2_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1 = (Keyword)cRegisterAlternatives_2_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_2 = (Keyword)cRegisterAlternatives_2_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_3 = (Keyword)cRegisterAlternatives_2_0.eContents().get(3);
		
		//ConstantIndexedMode:
		//    deplacement=NumericalValue?
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0() { return cRegisterAlternatives_2_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_0() { return cRegisterSKeyword_2_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1() { return cRegisterUKeyword_2_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_2() { return cRegisterXKeyword_2_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_3() { return cRegisterYKeyword_2_0_3; }
	}
	public class ConstantIndexedMovingIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ConstantIndexedMovingIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRegisterAlternatives_3_0 = (Alternatives)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_0 = (Keyword)cRegisterAlternatives_3_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1 = (Keyword)cRegisterAlternatives_3_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_2 = (Keyword)cRegisterAlternatives_3_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_3 = (Keyword)cRegisterAlternatives_3_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstantIndexedMovingIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0() { return cRegisterAlternatives_3_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_0() { return cRegisterSKeyword_3_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1() { return cRegisterUKeyword_3_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_2() { return cRegisterXKeyword_3_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_3() { return cRegisterYKeyword_3_0_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AccumulatorMovingModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AccumulatorMovingMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cDeplacementAlternatives_0_0 = (Alternatives)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cDeplacementAKeyword_0_0_0 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(0);
		private final Keyword cDeplacementBKeyword_0_0_1 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(1);
		private final Keyword cDeplacementDKeyword_0_0_2 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(2);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cRegisterAlternatives_2_0 = (Alternatives)cRegisterAssignment_2.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_0 = (Keyword)cRegisterAlternatives_2_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1 = (Keyword)cRegisterAlternatives_2_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_2 = (Keyword)cRegisterAlternatives_2_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_3 = (Keyword)cRegisterAlternatives_2_0.eContents().get(3);
		
		//AccumulatorMovingMode:
		//    deplacement=('A' | 'B' | 'D')
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=('A' | 'B' | 'D')
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup() { return cGroup; }
		
		//deplacement=('A' | 'B' | 'D')
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//('A' | 'B' | 'D')
		public Alternatives getDeplacementAlternatives_0_0() { return cDeplacementAlternatives_0_0; }
		
		//'A'
		public Keyword getDeplacementAKeyword_0_0_0() { return cDeplacementAKeyword_0_0_0; }
		
		//'B'
		public Keyword getDeplacementBKeyword_0_0_1() { return cDeplacementBKeyword_0_0_1; }
		
		//'D'
		public Keyword getDeplacementDKeyword_0_0_2() { return cDeplacementDKeyword_0_0_2; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0() { return cRegisterAlternatives_2_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_0() { return cRegisterSKeyword_2_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1() { return cRegisterUKeyword_2_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_2() { return cRegisterXKeyword_2_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_3() { return cRegisterYKeyword_2_0_3; }
	}
	public class AccumulatorMovingIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AccumulatorMovingIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDeplacementAlternatives_1_0 = (Alternatives)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cDeplacementAKeyword_1_0_0 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(0);
		private final Keyword cDeplacementBKeyword_1_0_1 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(1);
		private final Keyword cDeplacementDKeyword_1_0_2 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRegisterAlternatives_3_0 = (Alternatives)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_0 = (Keyword)cRegisterAlternatives_3_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1 = (Keyword)cRegisterAlternatives_3_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_2 = (Keyword)cRegisterAlternatives_3_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_3 = (Keyword)cRegisterAlternatives_3_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//AccumulatorMovingIndirectMode:
		//    '['
		//    deplacement=('A' | 'B' | 'D')
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=('A' | 'B' | 'D')
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=('A' | 'B' | 'D')
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//('A' | 'B' | 'D')
		public Alternatives getDeplacementAlternatives_1_0() { return cDeplacementAlternatives_1_0; }
		
		//'A'
		public Keyword getDeplacementAKeyword_1_0_0() { return cDeplacementAKeyword_1_0_0; }
		
		//'B'
		public Keyword getDeplacementBKeyword_1_0_1() { return cDeplacementBKeyword_1_0_1; }
		
		//'D'
		public Keyword getDeplacementDKeyword_1_0_2() { return cDeplacementDKeyword_1_0_2; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0() { return cRegisterAlternatives_3_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_0() { return cRegisterSKeyword_3_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1() { return cRegisterUKeyword_3_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_2() { return cRegisterXKeyword_3_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_3() { return cRegisterYKeyword_3_0_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AutoIncDecModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AutoIncDecMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Alternatives cAlternatives_2_0_0 = (Alternatives)cGroup_2_0.eContents().get(0);
		private final Assignment cDecrementAssignment_2_0_0_0 = (Assignment)cAlternatives_2_0_0.eContents().get(0);
		private final Keyword cDecrementHyphenMinusKeyword_2_0_0_0_0 = (Keyword)cDecrementAssignment_2_0_0_0.eContents().get(0);
		private final Assignment cDecrementAssignment_2_0_0_1 = (Assignment)cAlternatives_2_0_0.eContents().get(1);
		private final Keyword cDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0 = (Keyword)cDecrementAssignment_2_0_0_1.eContents().get(0);
		private final Assignment cRegisterAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final Alternatives cRegisterAlternatives_2_0_1_0 = (Alternatives)cRegisterAssignment_2_0_1.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_1_0_0 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1_0_1 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_1_0_2 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_1_0_3 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(3);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegisterAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Alternatives cRegisterAlternatives_2_1_0_0 = (Alternatives)cRegisterAssignment_2_1_0.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_1_0_0_0 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_1_0_0_1 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_1_0_0_2 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_1_0_0_3 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(3);
		private final Alternatives cAlternatives_2_1_1 = (Alternatives)cGroup_2_1.eContents().get(1);
		private final Assignment cIncrementAssignment_2_1_1_0 = (Assignment)cAlternatives_2_1_1.eContents().get(0);
		private final Keyword cIncrementPlusSignKeyword_2_1_1_0_0 = (Keyword)cIncrementAssignment_2_1_1_0.eContents().get(0);
		private final Assignment cIncrementAssignment_2_1_1_1 = (Assignment)cAlternatives_2_1_1.eContents().get(1);
		private final Keyword cIncrementPlusSignPlusSignKeyword_2_1_1_1_0 = (Keyword)cIncrementAssignment_2_1_1_1.eContents().get(0);
		
		//AutoIncDecMode:
		//    deplacement=NumericalValue?
		//    ','
		//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//(decrement='-' | decrement='--')
		public Alternatives getAlternatives_2_0_0() { return cAlternatives_2_0_0; }
		
		//decrement='-'
		public Assignment getDecrementAssignment_2_0_0_0() { return cDecrementAssignment_2_0_0_0; }
		
		//'-'
		public Keyword getDecrementHyphenMinusKeyword_2_0_0_0_0() { return cDecrementHyphenMinusKeyword_2_0_0_0_0; }
		
		//decrement='--'
		public Assignment getDecrementAssignment_2_0_0_1() { return cDecrementAssignment_2_0_0_1; }
		
		//'--'
		public Keyword getDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0() { return cDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2_0_1() { return cRegisterAssignment_2_0_1; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0_1_0() { return cRegisterAlternatives_2_0_1_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_1_0_0() { return cRegisterSKeyword_2_0_1_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1_0_1() { return cRegisterUKeyword_2_0_1_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_1_0_2() { return cRegisterXKeyword_2_0_1_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_1_0_3() { return cRegisterYKeyword_2_0_1_0_3; }
		
		//register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++')
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2_1_0() { return cRegisterAssignment_2_1_0; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_1_0_0() { return cRegisterAlternatives_2_1_0_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_1_0_0_0() { return cRegisterSKeyword_2_1_0_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_1_0_0_1() { return cRegisterUKeyword_2_1_0_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_1_0_0_2() { return cRegisterXKeyword_2_1_0_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_1_0_0_3() { return cRegisterYKeyword_2_1_0_0_3; }
		
		//(increment='+' | increment='++')
		public Alternatives getAlternatives_2_1_1() { return cAlternatives_2_1_1; }
		
		//increment='+'
		public Assignment getIncrementAssignment_2_1_1_0() { return cIncrementAssignment_2_1_1_0; }
		
		//'+'
		public Keyword getIncrementPlusSignKeyword_2_1_1_0_0() { return cIncrementPlusSignKeyword_2_1_1_0_0; }
		
		//increment='++'
		public Assignment getIncrementAssignment_2_1_1_1() { return cIncrementAssignment_2_1_1_1; }
		
		//'++'
		public Keyword getIncrementPlusSignPlusSignKeyword_2_1_1_1_0() { return cIncrementPlusSignPlusSignKeyword_2_1_1_1_0; }
	}
	public class AutoIncDecIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AutoIncDecIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Alternatives cAlternatives_3_0_0 = (Alternatives)cGroup_3_0.eContents().get(0);
		private final Assignment cDecrementAssignment_3_0_0_0 = (Assignment)cAlternatives_3_0_0.eContents().get(0);
		private final Keyword cDecrementHyphenMinusKeyword_3_0_0_0_0 = (Keyword)cDecrementAssignment_3_0_0_0.eContents().get(0);
		private final Assignment cDecrementAssignment_3_0_0_1 = (Assignment)cAlternatives_3_0_0.eContents().get(1);
		private final Keyword cDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0 = (Keyword)cDecrementAssignment_3_0_0_1.eContents().get(0);
		private final Assignment cRegisterAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final Alternatives cRegisterAlternatives_3_0_1_0 = (Alternatives)cRegisterAssignment_3_0_1.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_1_0_0 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1_0_1 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_1_0_2 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_1_0_3 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(3);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Assignment cRegisterAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final Alternatives cRegisterAlternatives_3_1_0_0 = (Alternatives)cRegisterAssignment_3_1_0.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_1_0_0_0 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_1_0_0_1 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_1_0_0_2 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_1_0_0_3 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(3);
		private final Alternatives cAlternatives_3_1_1 = (Alternatives)cGroup_3_1.eContents().get(1);
		private final Assignment cIncrementAssignment_3_1_1_0 = (Assignment)cAlternatives_3_1_1.eContents().get(0);
		private final Keyword cIncrementPlusSignKeyword_3_1_1_0_0 = (Keyword)cIncrementAssignment_3_1_1_0.eContents().get(0);
		private final Assignment cIncrementAssignment_3_1_1_1 = (Assignment)cAlternatives_3_1_1.eContents().get(1);
		private final Keyword cIncrementPlusSignPlusSignKeyword_3_1_1_1_0 = (Keyword)cIncrementAssignment_3_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//AutoIncDecIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//(decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//(decrement='-' | decrement='--')
		public Alternatives getAlternatives_3_0_0() { return cAlternatives_3_0_0; }
		
		//decrement='-'
		public Assignment getDecrementAssignment_3_0_0_0() { return cDecrementAssignment_3_0_0_0; }
		
		//'-'
		public Keyword getDecrementHyphenMinusKeyword_3_0_0_0_0() { return cDecrementHyphenMinusKeyword_3_0_0_0_0; }
		
		//decrement='--'
		public Assignment getDecrementAssignment_3_0_0_1() { return cDecrementAssignment_3_0_0_1; }
		
		//'--'
		public Keyword getDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0() { return cDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3_0_1() { return cRegisterAssignment_3_0_1; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0_1_0() { return cRegisterAlternatives_3_0_1_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_1_0_0() { return cRegisterSKeyword_3_0_1_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1_0_1() { return cRegisterUKeyword_3_0_1_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_1_0_2() { return cRegisterXKeyword_3_0_1_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_1_0_3() { return cRegisterYKeyword_3_0_1_0_3; }
		
		//register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++')
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3_1_0() { return cRegisterAssignment_3_1_0; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_1_0_0() { return cRegisterAlternatives_3_1_0_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_1_0_0_0() { return cRegisterSKeyword_3_1_0_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_1_0_0_1() { return cRegisterUKeyword_3_1_0_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_1_0_0_2() { return cRegisterXKeyword_3_1_0_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_1_0_0_3() { return cRegisterYKeyword_3_1_0_0_3; }
		
		//(increment='+' | increment='++')
		public Alternatives getAlternatives_3_1_1() { return cAlternatives_3_1_1; }
		
		//increment='+'
		public Assignment getIncrementAssignment_3_1_1_0() { return cIncrementAssignment_3_1_1_0; }
		
		//'+'
		public Keyword getIncrementPlusSignKeyword_3_1_1_0_0() { return cIncrementPlusSignKeyword_3_1_1_0_0; }
		
		//increment='++'
		public Assignment getIncrementAssignment_3_1_1_1() { return cIncrementAssignment_3_1_1_1; }
		
		//'++'
		public Keyword getIncrementPlusSignPlusSignKeyword_3_1_1_1_0() { return cIncrementPlusSignPlusSignKeyword_3_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class RelatifToPCModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RelatifToPCMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cRegisterPCRKeyword_2_0 = (Keyword)cRegisterAssignment_2.eContents().get(0);
		
		//RelatifToPCMode:
		//    deplacement=NumericalValue?
		//    ','
		//    (register='PCR' )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//(register='PCR' )
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//(register='PCR' )
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//'PCR'
		public Keyword getRegisterPCRKeyword_2_0() { return cRegisterPCRKeyword_2_0; }
	}
	public class RelatifToPCIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RelatifToPCIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cRegisterPCRKeyword_3_0 = (Keyword)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//RelatifToPCIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    (register='PCR' )
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//(register='PCR' )
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//(register='PCR' )
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//'PCR'
		public Keyword getRegisterPCRKeyword_3_0() { return cRegisterPCRKeyword_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class RelativeModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RelativeMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsPcRelativeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsPcRelativeAsteriskKeyword_0_0 = (Keyword)cIsPcRelativeAssignment_0.eContents().get(0);
		private final Assignment cOffsetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOffsetExpressionParserRuleCall_1_0 = (RuleCall)cOffsetAssignment_1.eContents().get(0);
		
		//RelativeMode:
		//    isPcRelative?='*'? offset=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//isPcRelative?='*'? offset=Expression
		public Group getGroup() { return cGroup; }
		
		//isPcRelative?='*'?
		public Assignment getIsPcRelativeAssignment_0() { return cIsPcRelativeAssignment_0; }
		
		//'*'
		public Keyword getIsPcRelativeAsteriskKeyword_0_0() { return cIsPcRelativeAsteriskKeyword_0_0; }
		
		//offset=Expression
		public Assignment getOffsetAssignment_1() { return cOffsetAssignment_1; }
		
		//Expression
		public RuleCall getOffsetExpressionParserRuleCall_1_0() { return cOffsetExpressionParserRuleCall_1_0; }
	}
	public class DirectiveLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DirectiveLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cDirectiveAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cDirectiveEquDirectiveParserRuleCall_2_0_0 = (RuleCall)cDirectiveAssignment_2_0.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cDirectiveOrgDirectiveParserRuleCall_2_1_0 = (RuleCall)cDirectiveAssignment_2_1.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cDirectiveBszDirectiveParserRuleCall_2_2_0 = (RuleCall)cDirectiveAssignment_2_2.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_3 = (Assignment)cAlternatives_2.eContents().get(3);
		private final RuleCall cDirectiveEndDirectiveParserRuleCall_2_3_0 = (RuleCall)cDirectiveAssignment_2_3.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_4 = (Assignment)cAlternatives_2.eContents().get(4);
		private final RuleCall cDirectiveFailDirectiveParserRuleCall_2_4_0 = (RuleCall)cDirectiveAssignment_2_4.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_5 = (Assignment)cAlternatives_2.eContents().get(5);
		private final RuleCall cDirectiveFillDirectiveParserRuleCall_2_5_0 = (RuleCall)cDirectiveAssignment_2_5.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_6 = (Assignment)cAlternatives_2.eContents().get(6);
		private final RuleCall cDirectiveOptDirectiveParserRuleCall_2_6_0 = (RuleCall)cDirectiveAssignment_2_6.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_7 = (Assignment)cAlternatives_2.eContents().get(7);
		private final RuleCall cDirectivePagDirectiveParserRuleCall_2_7_0 = (RuleCall)cDirectiveAssignment_2_7.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_8 = (Assignment)cAlternatives_2.eContents().get(8);
		private final RuleCall cDirectiveNamDirectiveParserRuleCall_2_8_0 = (RuleCall)cDirectiveAssignment_2_8.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_9 = (Assignment)cAlternatives_2.eContents().get(9);
		private final RuleCall cDirectiveSetDirectiveParserRuleCall_2_9_0 = (RuleCall)cDirectiveAssignment_2_9.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_10 = (Assignment)cAlternatives_2.eContents().get(10);
		private final RuleCall cDirectiveSpcDirectiveParserRuleCall_2_10_0 = (RuleCall)cDirectiveAssignment_2_10.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_11 = (Assignment)cAlternatives_2.eContents().get(11);
		private final RuleCall cDirectiveRegDirectiveParserRuleCall_2_11_0 = (RuleCall)cDirectiveAssignment_2_11.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_12 = (Assignment)cAlternatives_2.eContents().get(12);
		private final RuleCall cDirectiveFcbDirectiveParserRuleCall_2_12_0 = (RuleCall)cDirectiveAssignment_2_12.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_13 = (Assignment)cAlternatives_2.eContents().get(13);
		private final RuleCall cDirectiveFdbDirectiveParserRuleCall_2_13_0 = (RuleCall)cDirectiveAssignment_2_13.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_14 = (Assignment)cAlternatives_2.eContents().get(14);
		private final RuleCall cDirectiveFccDirectiveParserRuleCall_2_14_0 = (RuleCall)cDirectiveAssignment_2_14.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_15 = (Assignment)cAlternatives_2.eContents().get(15);
		private final RuleCall cDirectiveRmbDirectiveParserRuleCall_2_15_0 = (RuleCall)cDirectiveAssignment_2_15.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * Definition of the list possible directives
		// */
		//DirectiveLine:
		//    (name = IdentifierValue)? WS
		//    (
		//            directive = EquDirective
		//        |  directive = OrgDirective
		//        |  directive = BszDirective
		//        |  directive = EndDirective
		//        |  directive = FailDirective
		//        |  directive = FillDirective
		//        |  directive = OptDirective
		//        |  directive = PagDirective
		//        |  directive = NamDirective
		//        |  directive = SetDirective
		//        |  directive = SpcDirective
		//        |  directive = RegDirective
		//        |  directive = FcbDirective
		//        |  directive = FdbDirective
		//        |  directive = FccDirective
		//        |  directive = RmbDirective
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS
		//(
		//        directive = EquDirective
		//    |  directive = OrgDirective
		//    |  directive = BszDirective
		//    |  directive = EndDirective
		//    |  directive = FailDirective
		//    |  directive = FillDirective
		//    |  directive = OptDirective
		//    |  directive = PagDirective
		//    |  directive = NamDirective
		//    |  directive = SetDirective
		//    |  directive = SpcDirective
		//    |  directive = RegDirective
		//    |  directive = FcbDirective
		//    |  directive = FdbDirective
		//    |  directive = FccDirective
		//    |  directive = RmbDirective
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//        directive = EquDirective
		//    |  directive = OrgDirective
		//    |  directive = BszDirective
		//    |  directive = EndDirective
		//    |  directive = FailDirective
		//    |  directive = FillDirective
		//    |  directive = OptDirective
		//    |  directive = PagDirective
		//    |  directive = NamDirective
		//    |  directive = SetDirective
		//    |  directive = SpcDirective
		//    |  directive = RegDirective
		//    |  directive = FcbDirective
		//    |  directive = FdbDirective
		//    |  directive = FccDirective
		//    |  directive = RmbDirective
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//directive = EquDirective
		public Assignment getDirectiveAssignment_2_0() { return cDirectiveAssignment_2_0; }
		
		//EquDirective
		public RuleCall getDirectiveEquDirectiveParserRuleCall_2_0_0() { return cDirectiveEquDirectiveParserRuleCall_2_0_0; }
		
		//directive = OrgDirective
		public Assignment getDirectiveAssignment_2_1() { return cDirectiveAssignment_2_1; }
		
		//OrgDirective
		public RuleCall getDirectiveOrgDirectiveParserRuleCall_2_1_0() { return cDirectiveOrgDirectiveParserRuleCall_2_1_0; }
		
		//directive = BszDirective
		public Assignment getDirectiveAssignment_2_2() { return cDirectiveAssignment_2_2; }
		
		//BszDirective
		public RuleCall getDirectiveBszDirectiveParserRuleCall_2_2_0() { return cDirectiveBszDirectiveParserRuleCall_2_2_0; }
		
		//directive = EndDirective
		public Assignment getDirectiveAssignment_2_3() { return cDirectiveAssignment_2_3; }
		
		//EndDirective
		public RuleCall getDirectiveEndDirectiveParserRuleCall_2_3_0() { return cDirectiveEndDirectiveParserRuleCall_2_3_0; }
		
		//directive = FailDirective
		public Assignment getDirectiveAssignment_2_4() { return cDirectiveAssignment_2_4; }
		
		//FailDirective
		public RuleCall getDirectiveFailDirectiveParserRuleCall_2_4_0() { return cDirectiveFailDirectiveParserRuleCall_2_4_0; }
		
		//directive = FillDirective
		public Assignment getDirectiveAssignment_2_5() { return cDirectiveAssignment_2_5; }
		
		//FillDirective
		public RuleCall getDirectiveFillDirectiveParserRuleCall_2_5_0() { return cDirectiveFillDirectiveParserRuleCall_2_5_0; }
		
		//directive = OptDirective
		public Assignment getDirectiveAssignment_2_6() { return cDirectiveAssignment_2_6; }
		
		//OptDirective
		public RuleCall getDirectiveOptDirectiveParserRuleCall_2_6_0() { return cDirectiveOptDirectiveParserRuleCall_2_6_0; }
		
		//directive = PagDirective
		public Assignment getDirectiveAssignment_2_7() { return cDirectiveAssignment_2_7; }
		
		//PagDirective
		public RuleCall getDirectivePagDirectiveParserRuleCall_2_7_0() { return cDirectivePagDirectiveParserRuleCall_2_7_0; }
		
		//directive = NamDirective
		public Assignment getDirectiveAssignment_2_8() { return cDirectiveAssignment_2_8; }
		
		//NamDirective
		public RuleCall getDirectiveNamDirectiveParserRuleCall_2_8_0() { return cDirectiveNamDirectiveParserRuleCall_2_8_0; }
		
		//directive = SetDirective
		public Assignment getDirectiveAssignment_2_9() { return cDirectiveAssignment_2_9; }
		
		//SetDirective
		public RuleCall getDirectiveSetDirectiveParserRuleCall_2_9_0() { return cDirectiveSetDirectiveParserRuleCall_2_9_0; }
		
		//directive = SpcDirective
		public Assignment getDirectiveAssignment_2_10() { return cDirectiveAssignment_2_10; }
		
		//SpcDirective
		public RuleCall getDirectiveSpcDirectiveParserRuleCall_2_10_0() { return cDirectiveSpcDirectiveParserRuleCall_2_10_0; }
		
		//directive = RegDirective
		public Assignment getDirectiveAssignment_2_11() { return cDirectiveAssignment_2_11; }
		
		//RegDirective
		public RuleCall getDirectiveRegDirectiveParserRuleCall_2_11_0() { return cDirectiveRegDirectiveParserRuleCall_2_11_0; }
		
		//directive = FcbDirective
		public Assignment getDirectiveAssignment_2_12() { return cDirectiveAssignment_2_12; }
		
		//FcbDirective
		public RuleCall getDirectiveFcbDirectiveParserRuleCall_2_12_0() { return cDirectiveFcbDirectiveParserRuleCall_2_12_0; }
		
		//directive = FdbDirective
		public Assignment getDirectiveAssignment_2_13() { return cDirectiveAssignment_2_13; }
		
		//FdbDirective
		public RuleCall getDirectiveFdbDirectiveParserRuleCall_2_13_0() { return cDirectiveFdbDirectiveParserRuleCall_2_13_0; }
		
		//directive = FccDirective
		public Assignment getDirectiveAssignment_2_14() { return cDirectiveAssignment_2_14; }
		
		//FccDirective
		public RuleCall getDirectiveFccDirectiveParserRuleCall_2_14_0() { return cDirectiveFccDirectiveParserRuleCall_2_14_0; }
		
		//directive = RmbDirective
		public Assignment getDirectiveAssignment_2_15() { return cDirectiveAssignment_2_15; }
		
		//RmbDirective
		public RuleCall getDirectiveRmbDirectiveParserRuleCall_2_15_0() { return cDirectiveRmbDirectiveParserRuleCall_2_15_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class FccDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FccDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveFCCKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cStringAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStringSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cStringAssignment_1_1.eContents().get(0);
		
		///*
		// * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
		// * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will
		// * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid
		// * examples follow:
		// *
		// * LABEL1 FCC 'THIS IS AN FCC STRING'
		// * LABEL2 FCC .SO IS THIS.
		// * FCC /LABELS ARE NOT REQUIRED./
		// *
		// * There is another method of using FCC which is a deviation from the standard Motorola definition of this
		// * directive. This allows you to place certain expressions on the same line as the standard FCC delimited
		// * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
		// * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter,
		// * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111
		// * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
		// * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
		// * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
		// * inserted along with strings. Some examples follow:
		// *
		// * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
		// * FCC 'STRING 1',0,'STRING 2'
		// * FCC $04,LABEL,/DELIMITED STRING/
		// *
		// * Note that more than one delimited string may be placed on a line as in the second example.
		// */
		//FccDirective:
		//    directive = 'FCC'
		//    (WS string=STRING)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'FCC'
		//(WS string=STRING)
		public Group getGroup() { return cGroup; }
		
		//directive = 'FCC'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'FCC'
		public Keyword getDirectiveFCCKeyword_0_0() { return cDirectiveFCCKeyword_0_0; }
		
		//(WS string=STRING)
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//string=STRING
		public Assignment getStringAssignment_1_1() { return cStringAssignment_1_1; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_1_1_0() { return cStringSTRINGTerminalRuleCall_1_1_0; }
	}
	public class RegDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RegDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveREGKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOptionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOptionsRegisterEnumRuleCall_1_1_0 = (RuleCall)cOptionsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cOptionsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cOptionsRegisterEnumRuleCall_1_2_1_0 = (RuleCall)cOptionsAssignment_1_2_1.eContents().get(0);
		
		///*
		// *  REG
		// *
		// * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
		// * This list is represented by a value and the value is equated to the label supplied. In this respect,
		// * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
		// *
		// * <label> REG <register list>
		// *
		// * As an example, suppose a program has a large number of occurences of the following instructions:
		// *
		// * PSHS A,B,Y,U,DP
		// * PULS A,B,Y,U,DP
		// *
		// * To make things more convenient and less error prone the REG directive could be used as shown here:
		// *
		// * RLIST2 REG A,B,Y,U,DP
		// *
		// * Now all the pushes and pulls referred to above could be accomplished with the statements:
		// *
		// * PSHS #RLIST2
		// * PULS #RLIST2
		// *
		// * Of course, the register list may still be typed out on push and pull instructions or an immediate value
		// * (with the desired bit pattern) may be specified.
		// */
		//RegDirective:
		//    (directive = 'REG')
		//    (WS options+=Register ( ',' options+=Register)*)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(directive = 'REG')
		//(WS options+=Register ( ',' options+=Register)*)?
		public Group getGroup() { return cGroup; }
		
		//(directive = 'REG')
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'REG'
		public Keyword getDirectiveREGKeyword_0_0() { return cDirectiveREGKeyword_0_0; }
		
		//(WS options+=Register ( ',' options+=Register)*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//options+=Register
		public Assignment getOptionsAssignment_1_1() { return cOptionsAssignment_1_1; }
		
		//Register
		public RuleCall getOptionsRegisterEnumRuleCall_1_1_0() { return cOptionsRegisterEnumRuleCall_1_1_0; }
		
		//( ',' options+=Register)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//options+=Register
		public Assignment getOptionsAssignment_1_2_1() { return cOptionsAssignment_1_2_1; }
		
		//Register
		public RuleCall getOptionsRegisterEnumRuleCall_1_2_1_0() { return cOptionsRegisterEnumRuleCall_1_2_1_0; }
	}
	public class SpcDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SpcDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveSPCKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSpaceCountAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSpaceCountExpressionParserRuleCall_1_1_0 = (RuleCall)cSpaceCountAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cKeepCountAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cKeepCountExpressionParserRuleCall_1_2_1_0 = (RuleCall)cKeepCountAssignment_1_2_1.eContents().get(0);
		
		///*
		// *  SPC
		// *
		// * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
		// *  listing. The general form is:
		// *
		// * SPC [<space count>[,<keep count>]]
		// *
		// * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
		// * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
		// * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
		// * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
		// *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
		// *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing.
		// */
		//SpcDirective:
		//    directive = 'SPC'
		//    (WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'SPC'
		//(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		public Group getGroup() { return cGroup; }
		
		//directive = 'SPC'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'SPC'
		public Keyword getDirectiveSPCKeyword_0_0() { return cDirectiveSPCKeyword_0_0; }
		
		//(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(spaceCount=Expression)
		public Assignment getSpaceCountAssignment_1_1() { return cSpaceCountAssignment_1_1; }
		
		//Expression
		public RuleCall getSpaceCountExpressionParserRuleCall_1_1_0() { return cSpaceCountExpressionParserRuleCall_1_1_0; }
		
		//( ',' keepCount=Expression)?
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//keepCount=Expression
		public Assignment getKeepCountAssignment_1_2_1() { return cKeepCountAssignment_1_2_1; }
		
		//Expression
		public RuleCall getKeepCountExpressionParserRuleCall_1_2_1_0() { return cKeepCountExpressionParserRuleCall_1_2_1_0; }
	}
	public class NamDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NamDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cDirectiveAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cDirectiveNAMKeyword_0_0_0 = (Keyword)cDirectiveAssignment_0_0.eContents().get(0);
		private final Assignment cDirectiveAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cDirectiveTTLKeyword_0_1_0 = (Keyword)cDirectiveAssignment_0_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandIdentifierValueParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		///*
		// *  TTL or NAM
		// *
		// * The TTL or NAM directive allows the user to specify a title or name to the program being assembled.
		// * This title is then printed in the header at the top of each output listing page if the page option is
		// * selected. If the page option is not selected, this directive is ignored. The proper form is:
		// *
		// * TTL <text for the title>
		// * or
		// * NAM <text for the title>
		// *
		// * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer.
		// * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL
		// * or NAM directives in a source program. The latest one encountered will always be the one used for printing
		// * at the top of the following page(s).
		// */
		//NamDirective:
		//    (directive = 'NAM'|directive = 'TTL')
		//    WS (operand=IdentifierValue)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(directive = 'NAM'|directive = 'TTL')
		//WS (operand=IdentifierValue)
		public Group getGroup() { return cGroup; }
		
		//(directive = 'NAM'|directive = 'TTL')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//directive = 'NAM'
		public Assignment getDirectiveAssignment_0_0() { return cDirectiveAssignment_0_0; }
		
		//'NAM'
		public Keyword getDirectiveNAMKeyword_0_0_0() { return cDirectiveNAMKeyword_0_0_0; }
		
		//directive = 'TTL'
		public Assignment getDirectiveAssignment_0_1() { return cDirectiveAssignment_0_1; }
		
		//'TTL'
		public Keyword getDirectiveTTLKeyword_0_1_0() { return cDirectiveTTLKeyword_0_1_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(operand=IdentifierValue)
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//IdentifierValue
		public RuleCall getOperandIdentifierValueParserRuleCall_2_0() { return cOperandIdentifierValueParserRuleCall_2_0; }
	}
	public class PagDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PagDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectivePAGKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		
		///*
		// *  PAG
		// *
		// * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page.
		// * Note that the 'PAG' option must have been previously selected in order for this directive to take effect.
		// * It is possible to assign a new number to the new page by specifying such in the operand field. If no page
		// * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
		// *  The PAG operator itself will not appear in the listing unless some sort of error is encountered.
		// * The proper form is:
		// *
		// * PAG [<expression>]
		// *
		// * Where the expression is optional. The first page of a listing does not have the header printed on it and
		// * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and
		// * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title,
		// * or subtitle instructions being in the way.
		// */
		//PagDirective:
		//    directive = 'PAG'
		//    (WS (operand=Expression))?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'PAG'
		//(WS (operand=Expression))?
		public Group getGroup() { return cGroup; }
		
		//directive = 'PAG'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'PAG'
		public Keyword getDirectivePAGKeyword_0_0() { return cDirectivePAGKeyword_0_0; }
		
		//(WS (operand=Expression))?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(operand=Expression)
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_1_0() { return cOperandExpressionParserRuleCall_1_1_0; }
	}
	public class OptDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OptDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveOPTKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOptionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOptionsAssemblyOptionEnumRuleCall_1_1_0 = (RuleCall)cOptionsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cOptionsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cOptionsAssemblyOptionEnumRuleCall_1_2_1_0 = (RuleCall)cOptionsAssignment_1_2_1.eContents().get(0);
		
		///*
		// * OPT
		// *
		// *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
		// *  These options are generally related to the format of the output listing and object code. The options which
		// *  may be set with this command are listed below. There are several options not listed here which may be set
		// *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper
		// * form of this instruction is:
		// *
		// * OPT <option 1>,<option 2>,...,<option n>
		// *
		// * Note that any number of options may be given on one line if separated by commas. No label is allowed and no
		// * spaces may be embedded in the option list. The options are all set during pass one only although the
		// * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are
		// * specified, the last one appearing takes precedence. If a particular option is not specified, the default
		// * case for that option takes effect. The default cases are signified below by an asterisk.
		// *
		// * The allowable options are:
		// *
		// * PAG enable page formatting and numbering
		// * NOP* disable pagination
		// *
		// * CON print conditionally skipped code
		// * NOC* suppress conditional code printing
		// *
		// * MAC* print macro calling lines
		// * NOM suppress printing of macro calls
		// *
		// * EXP print macro expansion lines
		// * NOE* Suppress macro expansion printing
		// *
		// * * denotes default option and is not part of option name
		// */
		//OptDirective:
		//    directive = 'OPT'
		//    (WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'OPT'
		//(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		public Group getGroup() { return cGroup; }
		
		//directive = 'OPT'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'OPT'
		public Keyword getDirectiveOPTKeyword_0_0() { return cDirectiveOPTKeyword_0_0; }
		
		//(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//options+=AssemblyOption
		public Assignment getOptionsAssignment_1_1() { return cOptionsAssignment_1_1; }
		
		//AssemblyOption
		public RuleCall getOptionsAssemblyOptionEnumRuleCall_1_1_0() { return cOptionsAssemblyOptionEnumRuleCall_1_1_0; }
		
		//( ',' options+=AssemblyOption)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//options+=AssemblyOption
		public Assignment getOptionsAssignment_1_2_1() { return cOptionsAssignment_1_2_1; }
		
		//AssemblyOption
		public RuleCall getOptionsAssemblyOptionEnumRuleCall_1_2_1_0() { return cOptionsAssemblyOptionEnumRuleCall_1_2_1_0; }
	}
	public class FailDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FailDirective");
		private final Assignment cDirectiveAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cDirectiveFAILKeyword_0 = (Keyword)cDirectiveAssignment.eContents().get(0);
		
		///*
		// * FAIL
		// *
		// *
		// */
		//FailDirective:
		//    directive = 'FAIL'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'FAIL'
		public Assignment getDirectiveAssignment() { return cDirectiveAssignment; }
		
		//'FAIL'
		public Keyword getDirectiveFAILKeyword_0() { return cDirectiveFAILKeyword_0; }
	}
	public class SetDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SetDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveSETKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_2_0_0_0 = (Keyword)cIsRelativeToPCAssignment_2_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_2_0_1_0 = (RuleCall)cOperandAssignment_2_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_2_1_0 = (Keyword)cIsRelativeToPCAssignment_2_1.eContents().get(0);
		
		///*
		// * SET
		// *
		// * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
		// * The difference is that a symbol may be SET several times within the source (to different values) while
		// * a symbol may be Equated only once.
		// * If a symbol is SET to several values within the source, the current value of the symbol will be
		// * the value last SET. The statement form is:
		// *
		// * <label> SET <expression>
		// *
		// * The label is strictly required and no code is generated.
		// */
		//SetDirective:
		//    directive = 'SET'
		//    WS (
		//        ( isRelativeToPC?='*'? operand=Expression) |
		//        ( isRelativeToPC?='*' )
		//        )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'SET'
		//WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    )
		public Group getGroup() { return cGroup; }
		
		//directive = 'SET'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'SET'
		public Keyword getDirectiveSETKeyword_0_0() { return cDirectiveSETKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       ( isRelativeToPC?='*'? operand=Expression) |
		//       ( isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//( isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_2_0_0() { return cIsRelativeToPCAssignment_2_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_2_0_0_0() { return cIsRelativeToPCAsteriskKeyword_2_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_2_0_1() { return cOperandAssignment_2_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_2_0_1_0() { return cOperandExpressionParserRuleCall_2_0_1_0; }
		
		//( isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_2_1() { return cIsRelativeToPCAssignment_2_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_2_1_0() { return cIsRelativeToPCAsteriskKeyword_2_1_0; }
	}
	public class FillDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FillDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveFILLKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cNumberAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cNumberExpressionParserRuleCall_1_3_0 = (RuleCall)cNumberAssignment_1_3.eContents().get(0);
		
		///*
		// * FILL
		// *
		// * FILL allow to initialize a memory area with a value
		// * the first value define the value to set, the second value define the number of byte to set
		// */
		//FillDirective:
		//    directive = 'FILL'
		//    (WS value=Expression ',' number=Expression)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'FILL'
		//(WS value=Expression ',' number=Expression)
		public Group getGroup() { return cGroup; }
		
		//directive = 'FILL'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'FILL'
		public Keyword getDirectiveFILLKeyword_0_0() { return cDirectiveFILLKeyword_0_0; }
		
		//(WS value=Expression ',' number=Expression)
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//value=Expression
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_1_0() { return cValueExpressionParserRuleCall_1_1_0; }
		
		//','
		public Keyword getCommaKeyword_1_2() { return cCommaKeyword_1_2; }
		
		//number=Expression
		public Assignment getNumberAssignment_1_3() { return cNumberAssignment_1_3; }
		
		//Expression
		public RuleCall getNumberExpressionParserRuleCall_1_3_0() { return cNumberExpressionParserRuleCall_1_3_0; }
	}
	public class BszDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BszDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cDirectiveAlternatives_0_0 = (Alternatives)cDirectiveAssignment_0.eContents().get(0);
		private final Keyword cDirectiveBSZKeyword_0_0_0 = (Keyword)cDirectiveAlternatives_0_0.eContents().get(0);
		private final Keyword cDirectiveZMBKeyword_0_0_1 = (Keyword)cDirectiveAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		
		///*
		// * BSZ
		// *
		// * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
		// * The operand define the number on byte to reserve
		// */
		//BszDirective:
		//    directive = ('BSZ'|'ZMB')
		//    (WS operand=Expression)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = ('BSZ'|'ZMB')
		//(WS operand=Expression)
		public Group getGroup() { return cGroup; }
		
		//directive = ('BSZ'|'ZMB')
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//('BSZ'|'ZMB')
		public Alternatives getDirectiveAlternatives_0_0() { return cDirectiveAlternatives_0_0; }
		
		//'BSZ'
		public Keyword getDirectiveBSZKeyword_0_0_0() { return cDirectiveBSZKeyword_0_0_0; }
		
		//'ZMB'
		public Keyword getDirectiveZMBKeyword_0_0_1() { return cDirectiveZMBKeyword_0_0_1; }
		
		//(WS operand=Expression)
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_1_0() { return cOperandExpressionParserRuleCall_1_1_0; }
	}
	public class FdbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FdbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveFDBKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandListOfExpressionParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		
		///*
		// *  FDB
		// *
		// * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
		// * It is exactly like the FCB directive except that 16 bit quantities are evaluated
		// * and stored in memory for each expression given.
		// * The form of the statement is:
		// *
		// * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
		// *
		// * Again, the label field is optional.
		// */
		//FdbDirective:
		//    directive = 'FDB'
		//    (WS (operand = ListOfExpression))?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'FDB'
		//(WS (operand = ListOfExpression))?
		public Group getGroup() { return cGroup; }
		
		//directive = 'FDB'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'FDB'
		public Keyword getDirectiveFDBKeyword_0_0() { return cDirectiveFDBKeyword_0_0; }
		
		//(WS (operand = ListOfExpression))?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(operand = ListOfExpression)
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//ListOfExpression
		public RuleCall getOperandListOfExpressionParserRuleCall_1_1_0() { return cOperandListOfExpressionParserRuleCall_1_1_0; }
	}
	public class FcbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FcbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveFCBKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandListOfExpressionParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		
		///*
		// *  The FCB or Form Constant Byte directive is used to set associated memory bytes
		// * to some value as determined by the operand.
		// * FCB may be used to set any number of bytes as shown below:
		// *
		// * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
		// *
		// * Where <expr. x> stands for some expression.
		// * Each expression given (separated by commas) is evaluated to 8 bits
		// * and the resulting quantities are stored in successive memory locations.
		// * The label is optional.
		// */
		//FcbDirective:
		//    directive = 'FCB'
		//    (WS (operand = ListOfExpression))?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'FCB'
		//(WS (operand = ListOfExpression))?
		public Group getGroup() { return cGroup; }
		
		//directive = 'FCB'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'FCB'
		public Keyword getDirectiveFCBKeyword_0_0() { return cDirectiveFCBKeyword_0_0; }
		
		//(WS (operand = ListOfExpression))?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(operand = ListOfExpression)
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//ListOfExpression
		public RuleCall getOperandListOfExpressionParserRuleCall_1_1_0() { return cOperandListOfExpressionParserRuleCall_1_1_0; }
	}
	public class RmbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RmbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveRMBKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cIsRelativeToPCAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_1_1_0_0 = (Keyword)cIsRelativeToPCAssignment_1_1_0.eContents().get(0);
		private final Assignment cOperandAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_1_1_0 = (RuleCall)cOperandAssignment_1_1_1.eContents().get(0);
		
		///*
		// *  RMB
		// *
		// * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
		// * The number of bytes specified by the expression in the operand are skipped during assembly.
		// * No code is produced in those memory location and therefore the contents are undefined at run time.
		// *  The proper useage is shown here:
		// *
		// * [<label>] RMB <expression>
		// *
		// * The label is optional, and the expression is a 16 bit quantity.
		// */
		//RmbDirective:
		//    directive = 'RMB'
		//    (WS (isRelativeToPC?='*'? operand = Expression))?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'RMB'
		//(WS (isRelativeToPC?='*'? operand = Expression))?
		public Group getGroup() { return cGroup; }
		
		//directive = 'RMB'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'RMB'
		public Keyword getDirectiveRMBKeyword_0_0() { return cDirectiveRMBKeyword_0_0; }
		
		//(WS (isRelativeToPC?='*'? operand = Expression))?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(isRelativeToPC?='*'? operand = Expression)
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_1_1_0() { return cIsRelativeToPCAssignment_1_1_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_1_1_0_0() { return cIsRelativeToPCAsteriskKeyword_1_1_0_0; }
		
		//operand = Expression
		public Assignment getOperandAssignment_1_1_1() { return cOperandAssignment_1_1_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_1_1_0() { return cOperandExpressionParserRuleCall_1_1_1_0; }
	}
	public class EndDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EndDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveENDKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandIdentifierValueParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		
		///*
		// * The END pseudo-op is used to signal the assembler that the end of the source input has occurred.
		// * This terminates whatever pass is currently being executed. No label is allowed and no code is generated.
		// * An expression may be given (as shown below) as the transfer address to be placed in a binary file.
		// * It is optional, and if supplied when no binary file is being produced, will be ignored.
		// *
		// *  END [<expression>]
		// *
		// * Note that an end statement is not strictly required,
		// * but is the only means of getting a transfer address appended to a binary output file.
		// */
		//EndDirective:
		//    directive = 'END'
		//    (WS operand=IdentifierValue)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'END'
		//(WS operand=IdentifierValue)?
		public Group getGroup() { return cGroup; }
		
		//directive = 'END'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'END'
		public Keyword getDirectiveENDKeyword_0_0() { return cDirectiveENDKeyword_0_0; }
		
		//(WS operand=IdentifierValue)?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//operand=IdentifierValue
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }
		
		//IdentifierValue
		public RuleCall getOperandIdentifierValueParserRuleCall_1_1_0() { return cOperandIdentifierValueParserRuleCall_1_1_0; }
	}
	public class OrgDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OrgDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveORGKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cAlternatives_1_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_1_1_0_0 = (Assignment)cGroup_1_1_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_1_1_0_0_0 = (Keyword)cIsRelativeToPCAssignment_1_1_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_1_1_0_1 = (Assignment)cGroup_1_1_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_1_0_1_0 = (RuleCall)cOperandAssignment_1_1_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_1_1_1_0 = (Keyword)cIsRelativeToPCAssignment_1_1_1.eContents().get(0);
		
		///*
		// *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
		// *
		// *         ORG <expression>
		// *
		// *    No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed.
		// */
		//OrgDirective:
		//    directive = 'ORG'
		//    (WS (
		//        (isRelativeToPC?='*'? operand=Expression) |
		//        (isRelativeToPC?='*' )
		//        ))?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'ORG'
		//(WS (
		//    (isRelativeToPC?='*'? operand=Expression) |
		//    (isRelativeToPC?='*' )
		//    ))?
		public Group getGroup() { return cGroup; }
		
		//directive = 'ORG'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'ORG'
		public Keyword getDirectiveORGKeyword_0_0() { return cDirectiveORGKeyword_0_0; }
		
		//(WS (
		//    (isRelativeToPC?='*'? operand=Expression) |
		//    (isRelativeToPC?='*' )
		//    ))?
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(
		//       (isRelativeToPC?='*'? operand=Expression) |
		//       (isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//(isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_1_1_0_0() { return cIsRelativeToPCAssignment_1_1_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_1_1_0_0_0() { return cIsRelativeToPCAsteriskKeyword_1_1_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1_1_0_1() { return cOperandAssignment_1_1_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_1_0_1_0() { return cOperandExpressionParserRuleCall_1_1_0_1_0; }
		
		//(isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_1_1_1() { return cIsRelativeToPCAssignment_1_1_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_1_1_1_0() { return cIsRelativeToPCAsteriskKeyword_1_1_1_0; }
	}
	public class EquDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EquDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDirectiveEQUKeyword_0_0 = (Keyword)cDirectiveAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_2_0_0_0 = (Keyword)cIsRelativeToPCAssignment_2_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_2_0_1_0 = (RuleCall)cOperandAssignment_2_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_2_1_0 = (Keyword)cIsRelativeToPCAssignment_2_1.eContents().get(0);
		
		///*
		// * Description of an EQU directive
		// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
		// */
		//EquDirective:
		//    directive = 'EQU'
		//    WS (
		//        ( isRelativeToPC?='*'? operand=Expression) |
		//        ( isRelativeToPC?='*' )
		//        )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = 'EQU'
		//WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    )
		public Group getGroup() { return cGroup; }
		
		//directive = 'EQU'
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//'EQU'
		public Keyword getDirectiveEQUKeyword_0_0() { return cDirectiveEQUKeyword_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//       ( isRelativeToPC?='*'? operand=Expression) |
		//       ( isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//( isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_2_0_0() { return cIsRelativeToPCAssignment_2_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_2_0_0_0() { return cIsRelativeToPCAsteriskKeyword_2_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_2_0_1() { return cOperandAssignment_2_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_2_0_1_0() { return cOperandExpressionParserRuleCall_2_0_1_0; }
		
		//( isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_2_1() { return cIsRelativeToPCAssignment_2_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_2_1_0() { return cIsRelativeToPCAsteriskKeyword_2_1_0; }
	}
	public class ListOfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ListOfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Assignment cCommaExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommaExpressionsCommaExpressionParserRuleCall_1_0 = (RuleCall)cCommaExpressionsAssignment_1.eContents().get(0);
		
		//ListOfExpression:
		//    expression=Expression
		//    (
		//         commaExpressions+=CommaExpression
		//    )*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//expression=Expression
		//(
		//     commaExpressions+=CommaExpression
		//)*
		public Group getGroup() { return cGroup; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//(
		//     commaExpressions+=CommaExpression
		//)*
		public Assignment getCommaExpressionsAssignment_1() { return cCommaExpressionsAssignment_1; }
		
		//CommaExpression
		public RuleCall getCommaExpressionsCommaExpressionParserRuleCall_1_0() { return cCommaExpressionsCommaExpressionParserRuleCall_1_0; }
	}
	public class CommaExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CommaExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCommaAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cCommaCommaKeyword_0_0 = (Keyword)cCommaAssignment_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//CommaExpression:
		//    comma=',' expression=Expression?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//comma=',' expression=Expression?
		public Group getGroup() { return cGroup; }
		
		//comma=','
		public Assignment getCommaAssignment_0() { return cCommaAssignment_0; }
		
		//','
		public Keyword getCommaCommaKeyword_0_0() { return cCommaCommaKeyword_0_0; }
		
		//expression=Expression?
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Expression");
		private final Assignment cOperandAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOperandMultiplicationParserRuleCall_0 = (RuleCall)cOperandAssignment.eContents().get(0);
		
		//Expression:
		//        operand = Multiplication;
		@Override public ParserRule getRule() { return rule; }
		
		//operand = Multiplication
		public Assignment getOperandAssignment() { return cOperandAssignment; }
		
		//Multiplication
		public RuleCall getOperandMultiplicationParserRuleCall_0() { return cOperandMultiplicationParserRuleCall_0; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivisionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperationAsteriskKeyword_1_1_0 = (Keyword)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivisionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//      Division ({Multiplication.left=current} operation='*' right=Division)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Division ({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup() { return cGroup; }
		
		//Division
		public RuleCall getDivisionParserRuleCall_0() { return cDivisionParserRuleCall_0; }
		
		//({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }
		
		//operation='*'
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//'*'
		public Keyword getOperationAsteriskKeyword_1_1_0() { return cOperationAsteriskKeyword_1_1_0; }
		
		//right=Division
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Division
		public RuleCall getRightDivisionParserRuleCall_1_2_0() { return cRightDivisionParserRuleCall_1_2_0; }
	}
	public class DivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Division");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModuloParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivisionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationSolidusKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModuloParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Division returns Expression:
		//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Modulo ({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup() { return cGroup; }
		
		//Modulo
		public RuleCall getModuloParserRuleCall_0() { return cModuloParserRuleCall_0; }
		
		//({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Division.left=current}
		public Action getDivisionLeftAction_1_0() { return cDivisionLeftAction_1_0; }
		
		//opretation='/'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'/'
		public Keyword getOpretationSolidusKeyword_1_1_0() { return cOpretationSolidusKeyword_1_1_0; }
		
		//right=Modulo
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Modulo
		public RuleCall getRightModuloParserRuleCall_1_2_0() { return cRightModuloParserRuleCall_1_2_0; }
	}
	public class ModuloElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Modulo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModuloLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationPercentSignKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Modulo returns Expression:
		//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Addition ({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup() { return cGroup; }
		
		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }
		
		//({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Modulo.left=current}
		public Action getModuloLeftAction_1_0() { return cModuloLeftAction_1_0; }
		
		//opretation='%'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'%'
		public Keyword getOpretationPercentSignKeyword_1_1_0() { return cOpretationPercentSignKeyword_1_1_0; }
		
		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}
	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubstractionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSubstractionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns Expression:
		//    Substraction ({Addition.left=current} '+' right=Substraction)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Substraction ({Addition.left=current} '+' right=Substraction)*
		public Group getGroup() { return cGroup; }
		
		//Substraction
		public RuleCall getSubstractionParserRuleCall_0() { return cSubstractionParserRuleCall_0; }
		
		//({Addition.left=current} '+' right=Substraction)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0() { return cAdditionLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Substraction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Substraction
		public RuleCall getRightSubstractionParserRuleCall_1_2_0() { return cRightSubstractionParserRuleCall_1_2_0; }
	}
	public class SubstractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Substraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLeftShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSubstractionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightLeftShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Substraction returns Expression:
		//    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
		public Group getGroup() { return cGroup; }
		
		//LeftShift
		public RuleCall getLeftShiftParserRuleCall_0() { return cLeftShiftParserRuleCall_0; }
		
		//({Substraction.left=current} -> '-' right=LeftShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Substraction.left=current}
		public Action getSubstractionLeftAction_1_0() { return cSubstractionLeftAction_1_0; }
		
		//-> '-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=LeftShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//LeftShift
		public RuleCall getRightLeftShiftParserRuleCall_1_2_0() { return cRightLeftShiftParserRuleCall_1_2_0; }
	}
	public class LeftShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LeftShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRightShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLeftShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRightShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//LeftShift returns Expression:
		//    RightShift ({LeftShift.left=current} '<<' right=RightShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//RightShift ({LeftShift.left=current} '<<' right=RightShift)*
		public Group getGroup() { return cGroup; }
		
		//RightShift
		public RuleCall getRightShiftParserRuleCall_0() { return cRightShiftParserRuleCall_0; }
		
		//({LeftShift.left=current} '<<' right=RightShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{LeftShift.left=current}
		public Action getLeftShiftLeftAction_1_0() { return cLeftShiftLeftAction_1_0; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_1_1() { return cLessThanSignLessThanSignKeyword_1_1; }
		
		//right=RightShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RightShift
		public RuleCall getRightRightShiftParserRuleCall_1_2_0() { return cRightRightShiftParserRuleCall_1_2_0; }
	}
	public class RightShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RightShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRightShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RightShift returns Expression:
		//    And ({RightShift.left=current} '>>' right=And)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({RightShift.left=current} '>>' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({RightShift.left=current} '>>' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{RightShift.left=current}
		public Action getRightShiftLeftAction_1_0() { return cRightShiftLeftAction_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_1_1() { return cGreaterThanSignGreaterThanSignKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And returns Expression:
		//    Or ({And.left=current} '&&' right=Or)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({And.left=current} '&&' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({And.left=current} '&&' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or returns Expression:
		//    Xor ({Or.left=current} '||' right=Xor)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({Or.left=current} '||' right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({Or.left=current} '||' right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor returns Expression:
		//    Primary ({Xor.left=current} '^' right=Primary)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Xor.left=current} '^' right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Xor.left=current} '^' right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueDecimalValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueHexaDecimalValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueOctalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueBinaryValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cValueCharacterValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Assignment cValueAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cValueIdentifierValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cNotAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cValueAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cValuePrimaryParserRuleCall_6_2_0 = (RuleCall)cValueAssignment_6_2.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final RuleCall cMultiplicationParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		
		//Primary returns Expression:
		//            value=DecimalValue
		//      |    value=HexaDecimalValue
		//      |    value=OctalValue
		//      |   value=BinaryValue
		//      |   value=CharacterValue
		//       |    value=IdentifierValue
		//       |   {Not} '!' value=Primary
		//      |  '(' Multiplication ')'
		// ;
		@Override public ParserRule getRule() { return rule; }
		
		//      value=DecimalValue
		//|    value=HexaDecimalValue
		//|    value=OctalValue
		//|   value=BinaryValue
		//|   value=CharacterValue
		// |    value=IdentifierValue
		// |   {Not} '!' value=Primary
		//|  '(' Multiplication ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=DecimalValue
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DecimalValue
		public RuleCall getValueDecimalValueParserRuleCall_0_0() { return cValueDecimalValueParserRuleCall_0_0; }
		
		//value=HexaDecimalValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HexaDecimalValue
		public RuleCall getValueHexaDecimalValueParserRuleCall_1_0() { return cValueHexaDecimalValueParserRuleCall_1_0; }
		
		//value=OctalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//OctalValue
		public RuleCall getValueOctalValueParserRuleCall_2_0() { return cValueOctalValueParserRuleCall_2_0; }
		
		//value=BinaryValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BinaryValue
		public RuleCall getValueBinaryValueParserRuleCall_3_0() { return cValueBinaryValueParserRuleCall_3_0; }
		
		//value=CharacterValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//CharacterValue
		public RuleCall getValueCharacterValueParserRuleCall_4_0() { return cValueCharacterValueParserRuleCall_4_0; }
		
		//value=IdentifierValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//IdentifierValue
		public RuleCall getValueIdentifierValueParserRuleCall_5_0() { return cValueIdentifierValueParserRuleCall_5_0; }
		
		//{Not} '!' value=Primary
		public Group getGroup_6() { return cGroup_6; }
		
		//{Not}
		public Action getNotAction_6_0() { return cNotAction_6_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_6_1() { return cExclamationMarkKeyword_6_1; }
		
		//value=Primary
		public Assignment getValueAssignment_6_2() { return cValueAssignment_6_2; }
		
		//Primary
		public RuleCall getValuePrimaryParserRuleCall_6_2_0() { return cValuePrimaryParserRuleCall_6_2_0; }
		
		//'(' Multiplication ')'
		public Group getGroup_7() { return cGroup_7; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_0() { return cLeftParenthesisKeyword_7_0; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_7_1() { return cMultiplicationParserRuleCall_7_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_2() { return cRightParenthesisKeyword_7_2; }
	}
	public class NumericalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NumericalValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueDecimalValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueHexaDecimalValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueOctalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueBinaryValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cValueCharacterValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Assignment cValueAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cValueIdentifierValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		
		//NumericalValue:
		//            value=DecimalValue
		//      |    value=HexaDecimalValue
		//      |    value=OctalValue
		//      |   value=BinaryValue
		//      |   value=CharacterValue
		//       |    value=IdentifierValue
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//      value=DecimalValue
		//|    value=HexaDecimalValue
		//|    value=OctalValue
		//|   value=BinaryValue
		//|   value=CharacterValue
		// |    value=IdentifierValue
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=DecimalValue
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DecimalValue
		public RuleCall getValueDecimalValueParserRuleCall_0_0() { return cValueDecimalValueParserRuleCall_0_0; }
		
		//value=HexaDecimalValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HexaDecimalValue
		public RuleCall getValueHexaDecimalValueParserRuleCall_1_0() { return cValueHexaDecimalValueParserRuleCall_1_0; }
		
		//value=OctalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//OctalValue
		public RuleCall getValueOctalValueParserRuleCall_2_0() { return cValueOctalValueParserRuleCall_2_0; }
		
		//value=BinaryValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BinaryValue
		public RuleCall getValueBinaryValueParserRuleCall_3_0() { return cValueBinaryValueParserRuleCall_3_0; }
		
		//value=CharacterValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//CharacterValue
		public RuleCall getValueCharacterValueParserRuleCall_4_0() { return cValueCharacterValueParserRuleCall_4_0; }
		
		//value=IdentifierValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//IdentifierValue
		public RuleCall getValueIdentifierValueParserRuleCall_5_0() { return cValueIdentifierValueParserRuleCall_5_0; }
	}
	public class IdentifierValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IdentifierValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IdentifierValue:
		//    value=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=ID
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//ID
		public RuleCall getValueIDTerminalRuleCall_0() { return cValueIDTerminalRuleCall_0; }
	}
	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.StringValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringValue:
		//    value=STRING
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class DecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DecimalValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cSignAlternatives_0_0 = (Alternatives)cSignAssignment_0.eContents().get(0);
		private final Keyword cSignHyphenMinusKeyword_0_0_0 = (Keyword)cSignAlternatives_0_0.eContents().get(0);
		private final Keyword cSignPlusSignKeyword_0_0_1 = (Keyword)cSignAlternatives_0_0.eContents().get(1);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNUMBERSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//DecimalValue:
		//    sign=('-'|'+')? value=NUMBERS
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sign=('-'|'+')? value=NUMBERS
		public Group getGroup() { return cGroup; }
		
		//sign=('-'|'+')?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }
		
		//('-'|'+')
		public Alternatives getSignAlternatives_0_0() { return cSignAlternatives_0_0; }
		
		//'-'
		public Keyword getSignHyphenMinusKeyword_0_0_0() { return cSignHyphenMinusKeyword_0_0_0; }
		
		//'+'
		public Keyword getSignPlusSignKeyword_0_0_1() { return cSignPlusSignKeyword_0_0_1; }
		
		//value=NUMBERS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//NUMBERS
		public RuleCall getValueNUMBERSTerminalRuleCall_1_0() { return cValueNUMBERSTerminalRuleCall_1_0; }
	}
	public class HexaDecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HexaDecimalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueHEXATerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//HexaDecimalValue:
		//    value=HEXA
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=HEXA
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//HEXA
		public RuleCall getValueHEXATerminalRuleCall_0() { return cValueHEXATerminalRuleCall_0; }
	}
	public class OctalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OctalValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNUMBERSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//OctalValue:
		//    '@' value=NUMBERS
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' value=NUMBERS
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//value=NUMBERS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//NUMBERS
		public RuleCall getValueNUMBERSTerminalRuleCall_1_0() { return cValueNUMBERSTerminalRuleCall_1_0; }
	}
	public class BinaryValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BinaryValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPercentSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNUMBERSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BinaryValue:
		//    '%' value=NUMBERS
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'%' value=NUMBERS
		public Group getGroup() { return cGroup; }
		
		//'%'
		public Keyword getPercentSignKeyword_0() { return cPercentSignKeyword_0; }
		
		//value=NUMBERS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//NUMBERS
		public RuleCall getValueNUMBERSTerminalRuleCall_1_0() { return cValueNUMBERSTerminalRuleCall_1_0; }
	}
	public class CharacterValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CharacterValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueCHARACTERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//CharacterValue:
		//    value=CHARACTER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=CHARACTER
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//CHARACTER
		public RuleCall getValueCHARACTERTerminalRuleCall_0() { return cValueCHARACTERTerminalRuleCall_0; }
	}
	public class EndOfLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EndOfLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCRTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEND_OF_FILETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EndOfLine: CR | END_OF_FILE;
		@Override public ParserRule getRule() { return rule; }
		
		//CR | END_OF_FILE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CR
		public RuleCall getCRTerminalRuleCall_0() { return cCRTerminalRuleCall_0; }
		
		//END_OF_FILE
		public RuleCall getEND_OF_FILETerminalRuleCall_1() { return cEND_OF_FILETerminalRuleCall_1; }
	}
	
	public class AssemblyOptionElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AssemblyOption");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPAGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPAGPAGKeyword_0_0 = (Keyword)cPAGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOPEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOPNOPKeyword_1_0 = (Keyword)cNOPEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCONEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCONCONKeyword_2_0 = (Keyword)cCONEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNOCEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNOCNOCKeyword_3_0 = (Keyword)cNOCEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMACEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMACMACKeyword_4_0 = (Keyword)cMACEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNOMEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNOMNOMKeyword_5_0 = (Keyword)cNOMEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cEXPEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cEXPEXPKeyword_6_0 = (Keyword)cEXPEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cNOEEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cNOENOEKeyword_7_0 = (Keyword)cNOEEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum AssemblyOption:
		//    PAG= 'PAG' |
		//    NOP= 'NOP' |
		//    CON= 'CON' |
		//    NOC= 'NOC' |
		//    MAC= 'MAC' |
		//    NOM= 'NOM' |
		//    EXP= 'EXP' |
		//    NOE= 'NOE'
		//    ;
		public EnumRule getRule() { return rule; }
		
		//PAG= 'PAG' |
		//NOP= 'NOP' |
		//CON= 'CON' |
		//NOC= 'NOC' |
		//MAC= 'MAC' |
		//NOM= 'NOM' |
		//EXP= 'EXP' |
		//NOE= 'NOE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PAG= 'PAG'
		public EnumLiteralDeclaration getPAGEnumLiteralDeclaration_0() { return cPAGEnumLiteralDeclaration_0; }
		
		//'PAG'
		public Keyword getPAGPAGKeyword_0_0() { return cPAGPAGKeyword_0_0; }
		
		//NOP= 'NOP'
		public EnumLiteralDeclaration getNOPEnumLiteralDeclaration_1() { return cNOPEnumLiteralDeclaration_1; }
		
		//'NOP'
		public Keyword getNOPNOPKeyword_1_0() { return cNOPNOPKeyword_1_0; }
		
		//CON= 'CON'
		public EnumLiteralDeclaration getCONEnumLiteralDeclaration_2() { return cCONEnumLiteralDeclaration_2; }
		
		//'CON'
		public Keyword getCONCONKeyword_2_0() { return cCONCONKeyword_2_0; }
		
		//NOC= 'NOC'
		public EnumLiteralDeclaration getNOCEnumLiteralDeclaration_3() { return cNOCEnumLiteralDeclaration_3; }
		
		//'NOC'
		public Keyword getNOCNOCKeyword_3_0() { return cNOCNOCKeyword_3_0; }
		
		//MAC= 'MAC'
		public EnumLiteralDeclaration getMACEnumLiteralDeclaration_4() { return cMACEnumLiteralDeclaration_4; }
		
		//'MAC'
		public Keyword getMACMACKeyword_4_0() { return cMACMACKeyword_4_0; }
		
		//NOM= 'NOM'
		public EnumLiteralDeclaration getNOMEnumLiteralDeclaration_5() { return cNOMEnumLiteralDeclaration_5; }
		
		//'NOM'
		public Keyword getNOMNOMKeyword_5_0() { return cNOMNOMKeyword_5_0; }
		
		//EXP= 'EXP'
		public EnumLiteralDeclaration getEXPEnumLiteralDeclaration_6() { return cEXPEnumLiteralDeclaration_6; }
		
		//'EXP'
		public Keyword getEXPEXPKeyword_6_0() { return cEXPEXPKeyword_6_0; }
		
		//NOE= 'NOE'
		public EnumLiteralDeclaration getNOEEnumLiteralDeclaration_7() { return cNOEEnumLiteralDeclaration_7; }
		
		//'NOE'
		public Keyword getNOENOEKeyword_7_0() { return cNOENOEKeyword_7_0; }
	}
	public class RegisterElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Register");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAAKeyword_0_0 = (Keyword)cAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBBKeyword_1_0 = (Keyword)cBEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDDKeyword_2_0 = (Keyword)cDEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cXEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cXXKeyword_3_0 = (Keyword)cXEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cYEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cYYKeyword_4_0 = (Keyword)cYEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cUEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cUUKeyword_5_0 = (Keyword)cUEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cSEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cSSKeyword_6_0 = (Keyword)cSEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cDPEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cDPDPKeyword_7_0 = (Keyword)cDPEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cCCEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cCCCCKeyword_8_0 = (Keyword)cCCEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cPCEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cPCPCKeyword_9_0 = (Keyword)cPCEnumLiteralDeclaration_9.eContents().get(0);
		
		//enum Register:
		//    A = 'A'    |
		//    B = 'B'       |
		//    D = 'D'       |
		//    X = 'X'       |
		//    Y = 'Y'       |
		//    U = 'U'       |
		//    S = 'S'       |
		//    DP = 'DP'  |
		//    CC = 'CC'  |
		//    PC = 'PC'
		//;
		public EnumRule getRule() { return rule; }
		
		//A = 'A'    |
		//B = 'B'       |
		//D = 'D'       |
		//X = 'X'       |
		//Y = 'Y'       |
		//U = 'U'       |
		//S = 'S'       |
		//DP = 'DP'  |
		//CC = 'CC'  |
		//PC = 'PC'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//A = 'A'
		public EnumLiteralDeclaration getAEnumLiteralDeclaration_0() { return cAEnumLiteralDeclaration_0; }
		
		//'A'
		public Keyword getAAKeyword_0_0() { return cAAKeyword_0_0; }
		
		//B = 'B'
		public EnumLiteralDeclaration getBEnumLiteralDeclaration_1() { return cBEnumLiteralDeclaration_1; }
		
		//'B'
		public Keyword getBBKeyword_1_0() { return cBBKeyword_1_0; }
		
		//D = 'D'
		public EnumLiteralDeclaration getDEnumLiteralDeclaration_2() { return cDEnumLiteralDeclaration_2; }
		
		//'D'
		public Keyword getDDKeyword_2_0() { return cDDKeyword_2_0; }
		
		//X = 'X'
		public EnumLiteralDeclaration getXEnumLiteralDeclaration_3() { return cXEnumLiteralDeclaration_3; }
		
		//'X'
		public Keyword getXXKeyword_3_0() { return cXXKeyword_3_0; }
		
		//Y = 'Y'
		public EnumLiteralDeclaration getYEnumLiteralDeclaration_4() { return cYEnumLiteralDeclaration_4; }
		
		//'Y'
		public Keyword getYYKeyword_4_0() { return cYYKeyword_4_0; }
		
		//U = 'U'
		public EnumLiteralDeclaration getUEnumLiteralDeclaration_5() { return cUEnumLiteralDeclaration_5; }
		
		//'U'
		public Keyword getUUKeyword_5_0() { return cUUKeyword_5_0; }
		
		//S = 'S'
		public EnumLiteralDeclaration getSEnumLiteralDeclaration_6() { return cSEnumLiteralDeclaration_6; }
		
		//'S'
		public Keyword getSSKeyword_6_0() { return cSSKeyword_6_0; }
		
		//DP = 'DP'
		public EnumLiteralDeclaration getDPEnumLiteralDeclaration_7() { return cDPEnumLiteralDeclaration_7; }
		
		//'DP'
		public Keyword getDPDPKeyword_7_0() { return cDPDPKeyword_7_0; }
		
		//CC = 'CC'
		public EnumLiteralDeclaration getCCEnumLiteralDeclaration_8() { return cCCEnumLiteralDeclaration_8; }
		
		//'CC'
		public Keyword getCCCCKeyword_8_0() { return cCCCCKeyword_8_0; }
		
		//PC = 'PC'
		public EnumLiteralDeclaration getPCEnumLiteralDeclaration_9() { return cPCEnumLiteralDeclaration_9; }
		
		//'PC'
		public Keyword getPCPCKeyword_9_0() { return cPCPCKeyword_9_0; }
	}
	
	private final ModelElements pModel;
	private final SourceLineElements pSourceLine;
	private final BlankLineElements pBlankLine;
	private final CommentLineElements pCommentLine;
	private final InstructionLineElements pInstructionLine;
	private final TstInstructionElements pTstInstruction;
	private final TfrInstructionElements pTfrInstruction;
	private final SyncInstructionElements pSyncInstruction;
	private final Swi3InstructionElements pSwi3Instruction;
	private final Swi2InstructionElements pSwi2Instruction;
	private final SwiInstructionElements pSwiInstruction;
	private final SubdInstructionElements pSubdInstruction;
	private final SubInstructionElements pSubInstruction;
	private final St16InstructionElements pSt16Instruction;
	private final St8InstructionElements pSt8Instruction;
	private final SexInstructionElements pSexInstruction;
	private final SbcInstructionElements pSbcInstruction;
	private final RtsInstructionElements pRtsInstruction;
	private final RtiInstructionElements pRtiInstruction;
	private final RorInstructionElements pRorInstruction;
	private final RolInstructionElements pRolInstruction;
	private final PuluInstructionElements pPuluInstruction;
	private final PulsInstructionElements pPulsInstruction;
	private final PshuInstructionElements pPshuInstruction;
	private final PshsInstructionElements pPshsInstruction;
	private final OrccInstructionElements pOrccInstruction;
	private final OrInstructionElements pOrInstruction;
	private final NopInstructionElements pNopInstruction;
	private final NegInstructionElements pNegInstruction;
	private final MulInstructionElements pMulInstruction;
	private final LsrInstructionElements pLsrInstruction;
	private final LslInstructionElements pLslInstruction;
	private final LeaInstructionElements pLeaInstruction;
	private final Ld16InstructionElements pLd16Instruction;
	private final Ld8InstructionElements pLd8Instruction;
	private final JsrInstructionElements pJsrInstruction;
	private final JmpInstructionElements pJmpInstruction;
	private final IncInstructionElements pIncInstruction;
	private final ExgInstructionElements pExgInstruction;
	private final EorInstructionElements pEorInstruction;
	private final DecInstructionElements pDecInstruction;
	private final DaaInstructionElements pDaaInstruction;
	private final CwaiInstructionElements pCwaiInstruction;
	private final ComInstructionElements pComInstruction;
	private final CmpInstructionElements pCmpInstruction;
	private final ClrInstructionElements pClrInstruction;
	private final BvsInstructionElements pBvsInstruction;
	private final BvcInstructionElements pBvcInstruction;
	private final BsrInstructionElements pBsrInstruction;
	private final BrnInstructionElements pBrnInstruction;
	private final BraInstructionElements pBraInstruction;
	private final BplInstructionElements pBplInstruction;
	private final BneInstructionElements pBneInstruction;
	private final BmiInstructionElements pBmiInstruction;
	private final BltInstructionElements pBltInstruction;
	private final BlsInstructionElements pBlsInstruction;
	private final BloInstructionElements pBloInstruction;
	private final BleInstructionElements pBleInstruction;
	private final BitInstructionElements pBitInstruction;
	private final BhsInstructionElements pBhsInstruction;
	private final BhiInstructionElements pBhiInstruction;
	private final BgtInstructionElements pBgtInstruction;
	private final BgeInstructionElements pBgeInstruction;
	private final BeqInstructionElements pBeqInstruction;
	private final BcsInstructionElements pBcsInstruction;
	private final BccInstructionElements pBccInstruction;
	private final AsrInstructionElements pAsrInstruction;
	private final AslInstructionElements pAslInstruction;
	private final AndCCInstructionElements pAndCCInstruction;
	private final AndInstructionElements pAndInstruction;
	private final AdddInstructionElements pAdddInstruction;
	private final AddInstructionElements pAddInstruction;
	private final AdcInstructionElements pAdcInstruction;
	private final AbxInstructionElements pAbxInstruction;
	private final ExtendedIndirectOperandElements pExtendedIndirectOperand;
	private final ExtendedOperandElements pExtendedOperand;
	private final DirectOperandElements pDirectOperand;
	private final ImmediatOperandElements pImmediatOperand;
	private final IndexedOperandElements pIndexedOperand;
	private final ConstantIndexedModeElements pConstantIndexedMode;
	private final ConstantIndexedMovingIndirectModeElements pConstantIndexedMovingIndirectMode;
	private final AccumulatorMovingModeElements pAccumulatorMovingMode;
	private final AccumulatorMovingIndirectModeElements pAccumulatorMovingIndirectMode;
	private final AutoIncDecModeElements pAutoIncDecMode;
	private final AutoIncDecIndirectModeElements pAutoIncDecIndirectMode;
	private final RelatifToPCModeElements pRelatifToPCMode;
	private final RelatifToPCIndirectModeElements pRelatifToPCIndirectMode;
	private final RelativeModeElements pRelativeMode;
	private final DirectiveLineElements pDirectiveLine;
	private final FccDirectiveElements pFccDirective;
	private final RegDirectiveElements pRegDirective;
	private final SpcDirectiveElements pSpcDirective;
	private final NamDirectiveElements pNamDirective;
	private final PagDirectiveElements pPagDirective;
	private final OptDirectiveElements pOptDirective;
	private final FailDirectiveElements pFailDirective;
	private final SetDirectiveElements pSetDirective;
	private final FillDirectiveElements pFillDirective;
	private final BszDirectiveElements pBszDirective;
	private final FdbDirectiveElements pFdbDirective;
	private final FcbDirectiveElements pFcbDirective;
	private final RmbDirectiveElements pRmbDirective;
	private final EndDirectiveElements pEndDirective;
	private final OrgDirectiveElements pOrgDirective;
	private final EquDirectiveElements pEquDirective;
	private final ListOfExpressionElements pListOfExpression;
	private final CommaExpressionElements pCommaExpression;
	private final ExpressionElements pExpression;
	private final MultiplicationElements pMultiplication;
	private final DivisionElements pDivision;
	private final ModuloElements pModulo;
	private final AdditionElements pAddition;
	private final SubstractionElements pSubstraction;
	private final LeftShiftElements pLeftShift;
	private final RightShiftElements pRightShift;
	private final AndElements pAnd;
	private final OrElements pOr;
	private final XorElements pXor;
	private final PrimaryElements pPrimary;
	private final NumericalValueElements pNumericalValue;
	private final IdentifierValueElements pIdentifierValue;
	private final StringValueElements pStringValue;
	private final DecimalValueElements pDecimalValue;
	private final HexaDecimalValueElements pHexaDecimalValue;
	private final OctalValueElements pOctalValue;
	private final BinaryValueElements pBinaryValue;
	private final CharacterValueElements pCharacterValue;
	private final AssemblyOptionElements eAssemblyOption;
	private final RegisterElements eRegister;
	private final TerminalRule tID;
	private final TerminalRule tHEXA;
	private final TerminalRule tNUMBERS;
	private final TerminalRule tCHARACTER;
	private final EndOfLineElements pEndOfLine;
	private final TerminalRule tSTRING;
	private final TerminalRule tANY_EXCEPT_COMMENT_END_OF_LINE;
	private final TerminalRule tWS;
	private final TerminalRule tCR;
	private final TerminalRule tEND_OF_FILE;
	
	private final Grammar grammar;

	@Inject
	public AssemblerGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pSourceLine = new SourceLineElements();
		this.pBlankLine = new BlankLineElements();
		this.pCommentLine = new CommentLineElements();
		this.pInstructionLine = new InstructionLineElements();
		this.pTstInstruction = new TstInstructionElements();
		this.pTfrInstruction = new TfrInstructionElements();
		this.pSyncInstruction = new SyncInstructionElements();
		this.pSwi3Instruction = new Swi3InstructionElements();
		this.pSwi2Instruction = new Swi2InstructionElements();
		this.pSwiInstruction = new SwiInstructionElements();
		this.pSubdInstruction = new SubdInstructionElements();
		this.pSubInstruction = new SubInstructionElements();
		this.pSt16Instruction = new St16InstructionElements();
		this.pSt8Instruction = new St8InstructionElements();
		this.pSexInstruction = new SexInstructionElements();
		this.pSbcInstruction = new SbcInstructionElements();
		this.pRtsInstruction = new RtsInstructionElements();
		this.pRtiInstruction = new RtiInstructionElements();
		this.pRorInstruction = new RorInstructionElements();
		this.pRolInstruction = new RolInstructionElements();
		this.pPuluInstruction = new PuluInstructionElements();
		this.pPulsInstruction = new PulsInstructionElements();
		this.pPshuInstruction = new PshuInstructionElements();
		this.pPshsInstruction = new PshsInstructionElements();
		this.pOrccInstruction = new OrccInstructionElements();
		this.pOrInstruction = new OrInstructionElements();
		this.pNopInstruction = new NopInstructionElements();
		this.pNegInstruction = new NegInstructionElements();
		this.pMulInstruction = new MulInstructionElements();
		this.pLsrInstruction = new LsrInstructionElements();
		this.pLslInstruction = new LslInstructionElements();
		this.pLeaInstruction = new LeaInstructionElements();
		this.pLd16Instruction = new Ld16InstructionElements();
		this.pLd8Instruction = new Ld8InstructionElements();
		this.pJsrInstruction = new JsrInstructionElements();
		this.pJmpInstruction = new JmpInstructionElements();
		this.pIncInstruction = new IncInstructionElements();
		this.pExgInstruction = new ExgInstructionElements();
		this.pEorInstruction = new EorInstructionElements();
		this.pDecInstruction = new DecInstructionElements();
		this.pDaaInstruction = new DaaInstructionElements();
		this.pCwaiInstruction = new CwaiInstructionElements();
		this.pComInstruction = new ComInstructionElements();
		this.pCmpInstruction = new CmpInstructionElements();
		this.pClrInstruction = new ClrInstructionElements();
		this.pBvsInstruction = new BvsInstructionElements();
		this.pBvcInstruction = new BvcInstructionElements();
		this.pBsrInstruction = new BsrInstructionElements();
		this.pBrnInstruction = new BrnInstructionElements();
		this.pBraInstruction = new BraInstructionElements();
		this.pBplInstruction = new BplInstructionElements();
		this.pBneInstruction = new BneInstructionElements();
		this.pBmiInstruction = new BmiInstructionElements();
		this.pBltInstruction = new BltInstructionElements();
		this.pBlsInstruction = new BlsInstructionElements();
		this.pBloInstruction = new BloInstructionElements();
		this.pBleInstruction = new BleInstructionElements();
		this.pBitInstruction = new BitInstructionElements();
		this.pBhsInstruction = new BhsInstructionElements();
		this.pBhiInstruction = new BhiInstructionElements();
		this.pBgtInstruction = new BgtInstructionElements();
		this.pBgeInstruction = new BgeInstructionElements();
		this.pBeqInstruction = new BeqInstructionElements();
		this.pBcsInstruction = new BcsInstructionElements();
		this.pBccInstruction = new BccInstructionElements();
		this.pAsrInstruction = new AsrInstructionElements();
		this.pAslInstruction = new AslInstructionElements();
		this.pAndCCInstruction = new AndCCInstructionElements();
		this.pAndInstruction = new AndInstructionElements();
		this.pAdddInstruction = new AdddInstructionElements();
		this.pAddInstruction = new AddInstructionElements();
		this.pAdcInstruction = new AdcInstructionElements();
		this.pAbxInstruction = new AbxInstructionElements();
		this.pExtendedIndirectOperand = new ExtendedIndirectOperandElements();
		this.pExtendedOperand = new ExtendedOperandElements();
		this.pDirectOperand = new DirectOperandElements();
		this.pImmediatOperand = new ImmediatOperandElements();
		this.pIndexedOperand = new IndexedOperandElements();
		this.pConstantIndexedMode = new ConstantIndexedModeElements();
		this.pConstantIndexedMovingIndirectMode = new ConstantIndexedMovingIndirectModeElements();
		this.pAccumulatorMovingMode = new AccumulatorMovingModeElements();
		this.pAccumulatorMovingIndirectMode = new AccumulatorMovingIndirectModeElements();
		this.pAutoIncDecMode = new AutoIncDecModeElements();
		this.pAutoIncDecIndirectMode = new AutoIncDecIndirectModeElements();
		this.pRelatifToPCMode = new RelatifToPCModeElements();
		this.pRelatifToPCIndirectMode = new RelatifToPCIndirectModeElements();
		this.pRelativeMode = new RelativeModeElements();
		this.pDirectiveLine = new DirectiveLineElements();
		this.pFccDirective = new FccDirectiveElements();
		this.pRegDirective = new RegDirectiveElements();
		this.pSpcDirective = new SpcDirectiveElements();
		this.pNamDirective = new NamDirectiveElements();
		this.pPagDirective = new PagDirectiveElements();
		this.pOptDirective = new OptDirectiveElements();
		this.pFailDirective = new FailDirectiveElements();
		this.pSetDirective = new SetDirectiveElements();
		this.pFillDirective = new FillDirectiveElements();
		this.pBszDirective = new BszDirectiveElements();
		this.pFdbDirective = new FdbDirectiveElements();
		this.pFcbDirective = new FcbDirectiveElements();
		this.pRmbDirective = new RmbDirectiveElements();
		this.pEndDirective = new EndDirectiveElements();
		this.pOrgDirective = new OrgDirectiveElements();
		this.pEquDirective = new EquDirectiveElements();
		this.pListOfExpression = new ListOfExpressionElements();
		this.pCommaExpression = new CommaExpressionElements();
		this.pExpression = new ExpressionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pDivision = new DivisionElements();
		this.pModulo = new ModuloElements();
		this.pAddition = new AdditionElements();
		this.pSubstraction = new SubstractionElements();
		this.pLeftShift = new LeftShiftElements();
		this.pRightShift = new RightShiftElements();
		this.pAnd = new AndElements();
		this.pOr = new OrElements();
		this.pXor = new XorElements();
		this.pPrimary = new PrimaryElements();
		this.pNumericalValue = new NumericalValueElements();
		this.pIdentifierValue = new IdentifierValueElements();
		this.pStringValue = new StringValueElements();
		this.pDecimalValue = new DecimalValueElements();
		this.pHexaDecimalValue = new HexaDecimalValueElements();
		this.pOctalValue = new OctalValueElements();
		this.pBinaryValue = new BinaryValueElements();
		this.pCharacterValue = new CharacterValueElements();
		this.eAssemblyOption = new AssemblyOptionElements();
		this.eRegister = new RegisterElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ID");
		this.tHEXA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HEXA");
		this.tNUMBERS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NUMBERS");
		this.tCHARACTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CHARACTER");
		this.pEndOfLine = new EndOfLineElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.STRING");
		this.tANY_EXCEPT_COMMENT_END_OF_LINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ANY_EXCEPT_COMMENT_END_OF_LINE");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.WS");
		this.tCR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CR");
		this.tEND_OF_FILE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.END_OF_FILE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.bpy.electronics.mc6809.assembler.Assembler".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	///*
	// * Entry point of an as9 file
	// */
	//Model:
	//    sourceLines += SourceLine*
	//;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///*
	// * Description of an assembler line.
	// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
	// */
	//SourceLine:
	//    (
	//          (lineContent = BlankLine)
	//        | (lineContent = CommentLine)
	//        | (lineContent = DirectiveLine)
	//        | (lineContent = InstructionLine)
	//    )
	//;
	public SourceLineElements getSourceLineAccess() {
		return pSourceLine;
	}
	
	public ParserRule getSourceLineRule() {
		return getSourceLineAccess().getRule();
	}
	
	///*
	// * Blanck line is an empty line or a set of space or tabs followed by a end of line
	// */
	//BlankLine:
	//    {BlankLine} (blankLine = WS)? EndOfLine
	//;
	public BlankLineElements getBlankLineAccess() {
		return pBlankLine;
	}
	
	public ParserRule getBlankLineRule() {
		return getBlankLineAccess().getRule();
	}
	
	///*
	// * definition of a comment line
	// * A comment line start with a ; following by anything and finish with a end of line
	// */
	//CommentLine:
	//    {CommentLine}
	//    startingSpace = WS? comment=ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
	//;
	public CommentLineElements getCommentLineAccess() {
		return pCommentLine;
	}
	
	public ParserRule getCommentLineRule() {
		return getCommentLineAccess().getRule();
	}
	
	///*
	// * Definition of the list possible instructions
	// */
	//InstructionLine:
	//    (name = IdentifierValue)? WS
	//    (
	//        instruction = AbxInstruction            |
	//        instruction = AdcInstruction            |
	//        instruction = AddInstruction            |
	//        instruction = AdddInstruction           |
	//        instruction = AndInstruction            |
	//        instruction = AndCCInstruction          |
	//        instruction = AslInstruction            |
	//        instruction = AsrInstruction            |
	//        instruction = BccInstruction            |
	//        instruction = BcsInstruction              |
	//        instruction = BeqInstruction            |
	//        instruction = BgeInstruction            |
	//        instruction = BgtInstruction            |
	//        instruction = BhiInstruction            |
	//        instruction = BhsInstruction              |
	//        instruction = BitInstruction            |
	//        instruction = BleInstruction            |
	//        instruction = BloInstruction            |
	//        instruction = BlsInstruction            |
	//        instruction = BltInstruction            |
	//        instruction = BmiInstruction            |
	//        instruction = BneInstruction            |
	//        instruction = BplInstruction            |
	//        instruction = BraInstruction            |
	//        instruction = BrnInstruction            |
	//        instruction = BsrInstruction            |
	//        instruction = BvcInstruction            |
	//        instruction = BvsInstruction            |
	//        instruction = ClrInstruction            |
	//        instruction = CmpInstruction            |
	//        instruction = ComInstruction            |
	//        instruction = CwaiInstruction            |
	//        instruction = DaaInstruction            |
	//        instruction = DecInstruction            |
	//        instruction = EorInstruction            |
	//        instruction = ExgInstruction            |
	//        instruction = IncInstruction            |
	//        instruction = JmpInstruction            |
	//        instruction = JsrInstruction            |
	//        instruction = Ld8Instruction            |
	//        instruction = Ld16Instruction            |
	//        instruction = LeaInstruction            |
	//        instruction = LslInstruction            |
	//        instruction = LsrInstruction            |
	//        instruction = MulInstruction            |
	//        instruction = NegInstruction            |
	//        instruction = NopInstruction            |
	//        instruction = OrInstruction                |
	//        instruction = OrccInstruction            |
	//        instruction = PshsInstruction            |
	//        instruction = PshuInstruction            |
	//        instruction = PulsInstruction            |
	//        instruction = PuluInstruction            |
	//        instruction = RolInstruction            |
	//        instruction = RorInstruction            |
	//        instruction = RtiInstruction            |
	//        instruction = RtsInstruction            |
	//        instruction = SbcInstruction            |
	//        instruction = SexInstruction            |
	//        instruction = St8Instruction            |
	//        instruction = St16Instruction            |
	//        instruction = SubInstruction            |
	//        instruction = SubdInstruction            |
	//        instruction = SwiInstruction            |
	//        instruction = Swi2Instruction            |
	//        instruction = Swi3Instruction            |
	//        instruction = SyncInstruction            |
	//        instruction = TfrInstruction            |
	//        instruction = TstInstruction
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public InstructionLineElements getInstructionLineAccess() {
		return pInstructionLine;
	}
	
	public ParserRule getInstructionLineRule() {
		return getInstructionLineAccess().getRule();
	}
	
	///*
	// * TST
	// *
	// * Test
	// * Source Form        : TST Q, TSTA; TSTB
	// * Operation        : TEMP< M-0
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Set the N (negative) and Z (zero) bits according to the contents of memory location M, and clear the V (overflow) bit. The TST instruction provides
	// *                    only minimum information when testing unsigned values; since no unsigned value is less than zero, BLO and BLS have no utility. While BHI could be
	// *                    used after TST, it provides exactly the same control as BNE, which is preferred. The signed branches are available.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//TstInstruction:
	//    (
	//       instruction = ('TSTA' | 'TSTB')
	//    )
	//    |
	//    (
	//         instruction = ('TST')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public TstInstructionElements getTstInstructionAccess() {
		return pTstInstruction;
	}
	
	public ParserRule getTstInstructionRule() {
		return getTstInstructionAccess().getRule();
	}
	
	///*
	// * TFR
	// *
	// * Transfer Register to Register
	// * Source Form        : TFR R1,R2
	// * Operation        : R1->R2
	// * Condition Codes    :Not affected unless R2 is the condition code register.
	// * Description        : Exchanges data between two designated registers. Bits 3-0 of the postbyte define one register,
	// *                    while bits 7-4 define the other, as follows:
	// *                                     0000 = A:B                1000 = A
	// *                                     0001 =X                    1001 = B
	// *                                     0010 = Y                1010 = COR
	// *                                     0011= US                1011= DPR
	// *                                     0100 = SP                1100 = Undefined
	// *                                     0101 = PC                1101 = Undefined
	// *                                     0110 = Undefined        1110 = Undefined
	// *                                     0111= Undefined            1111 = Undefined
	// *                      Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
	// * Addressing Mode    : Immediate
	// */
	//TfrInstruction:
	//    instruction = ('TFR' )
	//    WS reg1=Register ',' reg2=Register
	//;
	public TfrInstructionElements getTfrInstructionAccess() {
		return pTfrInstruction;
	}
	
	public ParserRule getTfrInstructionRule() {
		return getTfrInstructionAccess().getRule();
	}
	
	///*
	// * SYNC
	// *
	// * Synchronize to External Event
	// * Source Form        : SYNC
	// * Operation        : Synchronize to External Event
	// * Condition Codes    : Not affected.
	// * Description        : When a SYNC instruction is excuted, tlie processor enters a synchronizing state, stops processing instructions, and waits for an interrupt.
	// *                       When an interrupt occurs, the synchronizing state is cleared and processing continues. If the interrupt is enabled, and it lasts three cycles
	// *                    or more, the processor will perform the interrupt routine. If the interrupt is masked or is shorter than three cycles, the processor simply
	// *                    continues to the next instruction. While in the synchronizing state, the address and data buses are in the high impedance state.
	// * Addressing Mode    : Inherent
	// */
	//SyncInstruction:
	//    instruction = 'SYNC'
	//;
	public SyncInstructionElements getSyncInstructionAccess() {
		return pSyncInstruction;
	}
	
	public ParserRule getSyncInstructionRule() {
		return getSyncInstructionAccess().getRule();
	}
	
	///*
	// * SWI3
	// *
	// * Software Interrupt 3
	// * Source Form        : SWI3
	// * Operation        : Set E (entire state will be saved)
	// *                       SP'-SP-1,(SP)-PCL
	// *                    SP'^SP-1,(SP) PCH
	// *                    SP'SP-1,(SP)*-USL
	// *                    SP' SP-1,(SP)*-USH
	// *                    SP'-SP-1,(SP) lYL
	// *                    SP'*-SP-1,(SP) lYH
	// *                    SP'-SP-1,(SP)-IXL
	// *                    SP'SP-1,(SP) IXH
	// *                    SP'SP-1,(SP)^DPR
	// *                    SP' SP-1,(SP)*-ACCB
	// *                    SP' SP-1,(SP) ACCA
	// *                    SP'SP-1,(SP) OCR
	// *                    Set I, F (mask interrupts)
	// *                    PC'-(FFF2):(FFF3)
	// * Condition Codes    : Not affected.
	// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
	// *                    is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged software.
	// *                    This interrupt does not mask (disable) the norma! and fast interrupts.
	// * Addressing Mode    : Inherent
	// */
	//Swi3Instruction:
	//    instruction = 'SWI3'
	//;
	public Swi3InstructionElements getSwi3InstructionAccess() {
		return pSwi3Instruction;
	}
	
	public ParserRule getSwi3InstructionRule() {
		return getSwi3InstructionAccess().getRule();
	}
	
	///*
	// * SWI2
	// *
	// * Software Interrupt 2
	// * Source Form        : SWI2
	// * Operation        : Set E (entire state will be saved)
	// *                       SP'-SP-1,(SP)-PCL
	// *                    SP'^SP-1,(SP) PCH
	// *                    SP'SP-1,(SP)*-USL
	// *                    SP' SP-1,(SP)*-USH
	// *                    SP'-SP-1,(SP) lYL
	// *                    SP'*-SP-1,(SP) lYH
	// *                    SP'-SP-1,(SP)-IXL
	// *                    SP'SP-1,(SP) IXH
	// *                    SP'SP-1,(SP)^DPR
	// *                    SP' SP-1,(SP)*-ACCB
	// *                    SP' SP-1,(SP) ACCA
	// *                    SP'SP-1,(SP) OCR
	// *                    Set I, F (mask interrupts)
	// *                    PC'-(FFF4):(FFF5)
	// * Condition Codes    : Not affected.
	// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
	// *                    is transferred through the software interrupt 2 vector. This interrupt is available to the end user and must not be used in packaged software.
	// *                    This interrupt does not mask (disable) the norma! and fast interrupts.
	// * Addressing Mode    : Inherent
	// */
	//Swi2Instruction:
	//    instruction = 'SWI2'
	//;
	public Swi2InstructionElements getSwi2InstructionAccess() {
		return pSwi2Instruction;
	}
	
	public ParserRule getSwi2InstructionRule() {
		return getSwi2InstructionAccess().getRule();
	}
	
	///*
	// * SWI
	// *
	// * Software Interrupt
	// * Source Form        : SWI
	// * Operation        : Set E (entire state will be saved)
	// *                       SP'-SP-1,(SP)-PCL
	// *                    SP'^SP-1,(SP) PCH
	// *                    SP'SP-1,(SP)*-USL
	// *                    SP' SP-1,(SP)*-USH
	// *                    SP'-SP-1,(SP) lYL
	// *                    SP'*-SP-1,(SP) lYH
	// *                    SP'-SP-1,(SP)-IXL
	// *                    SP'SP-1,(SP) IXH
	// *                    SP'SP-1,(SP)^DPR
	// *                    SP' SP-1,(SP)*-ACCB
	// *                    SP' SP-1,(SP) ACCA
	// *                    SP'SP-1,(SP) OCR
	// *                    Set I, F (mask interrupts)
	// *                    PC'*-(FFFA):(FFFB)
	// * Condition Codes    : Not affected.
	// * Description        : All of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself), and control
	// *                    is transferred through the software Interrupt vector. Both the normal and fast interrupts are masked (disabled).
	// * Addressing Mode    : Inherent
	// */
	//SwiInstruction:
	//    instruction = 'SWI'
	//;
	public SwiInstructionElements getSwiInstructionAccess() {
		return pSwiInstruction;
	}
	
	public ParserRule getSwiInstructionRule() {
		return getSwiInstructionAccess().getRule();
	}
	
	///*
	// * SUBD
	// *
	// * Subtract Memory from Register
	// * Source Form        : SUBD P
	// * Operation        : R'*-R - M:M+1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Set if the overflow is generated; cleared otherwise.
	// *                       C - Set if a borrow is generated; cleared otherwise.
	// * Description        : Subtracts the value in memory location M:M + 1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow
	// *                       and is set to the inverse of the resulting binary carry.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//SubdInstruction:
	//    instruction = 'SUBD'
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public SubdInstructionElements getSubdInstructionAccess() {
		return pSubdInstruction;
	}
	
	public ParserRule getSubdInstructionRule() {
		return getSubdInstructionAccess().getRule();
	}
	
	///*
	// * SUB
	// *
	// * ASubtract Memory from Register
	// * Source Form        : SUBA P; SUBB P;
	// * Operation        : R'*-R - M
	// * Condition Codes    : H - Undefined.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Set if the result is zero; cleared otherwise.
	// *                       C - Set if a borrow is generated; cleared otherwise.
	// * Description        : Subtracts the value in memory location M:M + 1 from the contents of a designated 16-bit register. The C (carry) bit represents a borrow
	// *                    and is set to the inverse of the resulting binary carry.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//SubInstruction:
	//    instruction = ('SUBA' | 'SUBB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public SubInstructionElements getSubInstructionAccess() {
		return pSubInstruction;
	}
	
	public ParserRule getSubInstructionRule() {
		return getSubInstructionAccess().getRule();
	}
	
	///*
	// * ST (16 bits)
	// *
	// * store Register into Memory
	// * Source Form        : STD P, STX P, STY P, STS P, STU P
	// * Operation        : M:%+1 <- R
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Writes the contents of a 16-bit register into two consecutive memory locations.
	// * Addressing Mode    : Extended
	// *                    Direct
	// *                    Indexed
	// */
	//St16Instruction:
	//     instruction = ('STD' | 'STX' | 'STY' | 'STS' | 'STU')
	//    WS operand = (
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public St16InstructionElements getSt16InstructionAccess() {
		return pSt16Instruction;
	}
	
	public ParserRule getSt16InstructionRule() {
		return getSt16InstructionAccess().getRule();
	}
	
	///*
	// * ST (8 bits)
	// *
	// * store Register into Memory
	// * Source Form        : STA P, STB P
	// * Operation        : M <- R
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Writes the contents of an 8-bit register into a memory location.
	// * Addressing Mode    : Extended
	// *                    Direct
	// *                    Indexed
	// */
	//St8Instruction:
	//     instruction = ('STA' | 'STB')
	//    WS operand = (
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public St8InstructionElements getSt8InstructionAccess() {
		return pSt8Instruction;
	}
	
	public ParserRule getSt8InstructionRule() {
		return getSt8InstructionAccess().getRule();
	}
	
	///*
	// * SEX
	// *
	// * Sign Extended
	// * Source Form        : SEX
	// * Operation        : If bit seven of ACCB is set then ACCA'-^FF16
	// *                      else ACCA'-^OO16
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected.
	// *                       C - Not affected.
	// * Description        : This instruction transforms a twos complement 8-bit value in accumulator B into a twos complement 16-bit value in the D accumulator.
	// * Addressing Mode    : Inherent
	// */
	//SexInstruction:
	//    instruction = 'SEX'
	//;
	public SexInstructionElements getSexInstructionAccess() {
		return pSexInstruction;
	}
	
	public ParserRule getSexInstructionRule() {
		return getSexInstructionAccess().getRule();
	}
	
	///*
	// * SBC
	// *
	// * Subtract with Borrow
	// * Source Form        : SBCA P, SBCB P
	// * Operation        : R <- R-M-C
	// * Condition Codes    : H - Undefined.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if an overflow is generated; cleared otherwise.
	// *                       C - Set if a borrow is generated; cleared otherwise.
	// * Description        : Subtracts the contents of memory location M and the borrow (in the C (carry) bit) from the contents of the designated 8-bit register, and
	// *                    places the result in that register. The C bit represents a borrow and is set to the inverse of the resulting binary carry.
	// * Addressing Mode    : Immediate
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//SbcInstruction:
	//     instruction = ('SBCA' | 'SBCB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public SbcInstructionElements getSbcInstructionAccess() {
		return pSbcInstruction;
	}
	
	public ParserRule getSbcInstructionRule() {
		return getSbcInstructionAccess().getRule();
	}
	
	///*
	// * RTS
	// *
	// * Return from Subroutine
	// * Source Form        : RTS
	// * Operation        : PCH'(SP), SP'*-SP + 1
	//                      PCL'*-(SP), SP'-SP+1
	// * Condition Codes    : Not affected.
	// * Description        : Program control is returned from the subroutine to the calling program. The return address is pulled from the stack.
	// * Addressing Mode    : Inherent
	// */
	//RtsInstruction:
	//    instruction = 'RTS'
	//;
	public RtsInstructionElements getRtsInstructionAccess() {
		return pRtsInstruction;
	}
	
	public ParserRule getRtsInstructionRule() {
		return getRtsInstructionAccess().getRule();
	}
	
	///*
	// * RTI
	// *
	// * Return from Interrupt
	// * Source Form        : RTI
	// * Operation        : OCR' (SP),SP'SP + 1, then
	// *                        IFF COR bit E is set, then:     ACCA'-(SP), SP'*-SP + 1
	// *                                                        ACCB'*-(SP), SP'-SP + 1
	// *                                                        DPR' -(SP), SP'-SP + 1
	// *                                                        IXH' (SP), SP'*-SP + 1
	// *                                                        IXL' (SP), SP' SP + 1
	// *                                                        lYH' (SP), SP'*-SP + 1
	// *                                                        lYL' -(SP), SP' SP + 1
	// *                                                        USH' (SP), SP' SP + 1
	// *                                                        USL' *-(SP), SP'*-SP + 1
	// *                                                        PCH' ^(SP), SP' SP + 1
	// *                                                         PCL' *-(SP), SP'*-SP + 1
	// *                        IFF CCR bit E is clear, then:     PCH' ^(SP), SP' SP + 1
	// *                                                        PCL' *-(SP), SP' SP + 1
	// * Condition Codes    : Recovered from the stack
	// * Description        : The saved machine state is recovered from the hardware stack and control is returned to the Interrupted program. If the recovered E (entire) bit is clear,
	// *                    it indicates that only a subset of the machine state was saved (return address and condition codes) and only that subset is recovered.
	// * Addressing Mode    : Inherent
	// */
	//RtiInstruction:
	//    instruction = 'RTI'
	//;
	public RtiInstructionElements getRtiInstructionAccess() {
		return pRtiInstruction;
	}
	
	public ParserRule getRtiInstructionRule() {
		return getRtiInstructionAccess().getRule();
	}
	
	///*
	// * ROR
	// *
	// * Rotate Right
	// * Source Form        : ROR Q, RORA; RORB
	// * Operation        :
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected.
	// *                       C - Loaded with bit zero of the previous operand.
	// * Description        : Rotates all bits of the operand one place right through the C (carry) bit. This is a 9-bit rotation.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//RorInstruction:
	//    (
	//       instruction = ('RORA' | 'RORB')
	//    )
	//    |
	//    (
	//         instruction = ('ROR')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public RorInstructionElements getRorInstructionAccess() {
		return pRorInstruction;
	}
	
	public ParserRule getRorInstructionRule() {
		return getRorInstructionAccess().getRule();
	}
	
	///*
	// * ROL
	// *
	// * Rotate Left
	// * Source Form        : ROL Q, ROLA; ROLB
	// * Operation        :
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Rotates all bits of the operand one place left through the (carry) bit. This is a 9-bit rotation.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//RolInstruction:
	//    (
	//       instruction = ('ROLA' | 'ROLB')
	//    )
	//    |
	//    (
	//         instruction = ('ROL')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public RolInstructionElements getRolInstructionAccess() {
		return pRolInstruction;
	}
	
	public ParserRule getRolInstructionRule() {
		return getRolInstructionAccess().getRule();
	}
	
	///*
	// * PULu
	// *
	// * Pull Registers from the User Stack
	// * Source Form        : PULU register list
	//                      PULU #LABEL
	// * Operation        :
	// * Condition Codes    : May be pulled from stack; not affected otherwise.
	// * Description        : All, some, or none of the processor registers are pulled from the user stack (with the exception of the user stack pointer itself).
	// * Addressing Mode    : Immediate
	// */
	//PuluInstruction:
	//    instruction = 'PULU'
	//    WS
	//    (
	//           (operand = ImmediatOperand)
	//        |  ( registers+=Register (',' registers+=Register)*)
	//    )
	//;
	public PuluInstructionElements getPuluInstructionAccess() {
		return pPuluInstruction;
	}
	
	public ParserRule getPuluInstructionRule() {
		return getPuluInstructionAccess().getRule();
	}
	
	///*
	// * PULS
	// *
	// * Pull Registers from the Hardware Stack
	// * Source Form        : PULS register list
	//                      PULS #LABEL
	// * Operation        :
	// * Condition Codes    : May be pulled from stack; not affected otherwise.
	// * Description        : All, some, or none of the processor registers are pulled from the hardware stack (with the exception of the hardware stack pointer itself).
	// * Addressing Mode    : Immediate
	// */
	//PulsInstruction:
	//    instruction = 'PULS'
	//    WS
	//    (
	//           (operand = ImmediatOperand)
	//        |  ( registers+=Register (',' registers+=Register)*)
	//    )
	//;
	public PulsInstructionElements getPulsInstructionAccess() {
		return pPulsInstruction;
	}
	
	public ParserRule getPulsInstructionRule() {
		return getPulsInstructionAccess().getRule();
	}
	
	///*
	// * PSHU
	// *
	// * Push Registers on the user Stack
	// * Source Form        : PSHU register list
	//                      PSHU #LABEL
	// * Operation        :
	// * Condition Codes    : not effected
	// * Description        : All, some, or none of the processor registers are pushed onto the user stack (with the exception of the user stack pointer itself).
	// * Addressing Mode    : Immediate
	// */
	//PshuInstruction:
	//    instruction = 'PSHU'
	//    WS
	//    (
	//           (operand = ImmediatOperand)
	//        |  ( registers+=Register (',' registers+=Register)*)
	//    )
	//;
	public PshuInstructionElements getPshuInstructionAccess() {
		return pPshuInstruction;
	}
	
	public ParserRule getPshuInstructionRule() {
		return getPshuInstructionAccess().getRule();
	}
	
	///*
	// * PSHS
	// *
	// * Push Registers on the Hardware Stack
	// * Source Form        : PSHS register list
	//                      PSHS #LABEL
	// * Operation        :
	// * Condition Codes    : not effected
	// * Description        : All, some, or none of the processor registers are pushed onto the hardware stack (with the exception of the hardware stack pointer itself).
	// * Addressing Mode    : Immediate
	// */
	//PshsInstruction:
	//    instruction = 'PSHS'
	//    WS
	//    (
	//           (operand = ImmediatOperand)
	//        |  ( registers+=Register (',' registers+=Register)*)
	//    )
	//;
	public PshsInstructionElements getPshsInstructionAccess() {
		return pPshsInstruction;
	}
	
	public ParserRule getPshsInstructionRule() {
		return getPshsInstructionAccess().getRule();
	}
	
	///*
	// * ORCC
	// *
	// * Inclusive OR Memory Immediate Into Condition Code Register
	// * Source Form        : ORCC #XX
	// * Operation        : R' RvMi
	// * Condition Codes    : Affected according to the operation.
	// * Description        : Performs an inclusive OR operation between the contents of the condition code registers and the immediate value, and the result is
	// *                    piaced in the condition code register. This instruction may be used to set interrupt maslcs (disable interrupts) or any other bit(s).
	// * Addressing Mode    : Immediate
	// */
	//OrccInstruction:
	//    instruction = 'ORCC'
	//    WS operand = ImmediatOperand
	//;
	public OrccInstructionElements getOrccInstructionAccess() {
		return pOrccInstruction;
	}
	
	public ParserRule getOrccInstructionRule() {
		return getOrccInstructionAccess().getRule();
	}
	
	///*
	// * OR
	// *
	// * Inclusive OR Memory into Register
	// * Source Form        : ORA P; ORB P
	// * Operation        : R' RvM
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Performs an inclusive OR operation between the contents of accumulator A or B and the contents of memory location M and the result is
	// *                       stored in accumulator A or B.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//OrInstruction:
	//    instruction = ('ORA' | 'ORB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public OrInstructionElements getOrInstructionAccess() {
		return pOrInstruction;
	}
	
	public ParserRule getOrInstructionRule() {
		return getOrInstructionAccess().getRule();
	}
	
	///*
	// * NOP
	// *
	// * No operation
	// * Source Form        : NOP
	// * Operation        : Not affected.
	// * Condition Codes    : Not affected.
	// * Description        : This instruction causes only the program counter to be incremented. No other registers
	// *                    or memory locations are affected.
	// * Addressing Mode    : Inherent
	// *
	// */
	//NopInstruction:
	//    instruction = 'NOP'
	//;
	public NopInstructionElements getNopInstructionAccess() {
		return pNopInstruction;
	}
	
	public ParserRule getNopInstructionRule() {
		return getNopInstructionAccess().getRule();
	}
	
	///*
	// * NEG
	// *
	// * Negate
	// * Source Form        : NEG Q, NEGA; NEGB
	// * Operation        : M'0-M
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Set if the original operand was 10000000.
	// *                       C - Set if a borrow is generated; cleared otherwise.
	// * Description        : Replaces the operand with its twos complement. The (carry) bit represents a borrow and is
	// *                    set to the inverse of the resulting binary carry. Note that 80i6 is replaced by itself and
	// *                    only in this case is the  V (overflow) bit set. The value OOie is also replaced by itself,
	// *                    and only in this case is the C (carry) bit cleared.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *
	// */
	//NegInstruction:
	//    (
	//       instruction = ('NEGA' | 'NEGB')
	//    )
	//    |
	//    (
	//         instruction = ('NEG')
	//        WS operand = (
	//            DirectOperand  |
	//            ExtendedOperand
	//        )
	//    )
	//;
	public NegInstructionElements getNegInstructionAccess() {
		return pNegInstruction;
	}
	
	public ParserRule getNegInstructionRule() {
		return getNegInstructionAccess().getRule();
	}
	
	///*
	// * Mul
	// *
	// * Multiply
	// * Source Form        : MUL
	// * Operation        : ACCA':ACCB'<ACCA x ACCB
	// * Condition Codes    : H - Not affected.
	// *                       N - Not affected.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected.
	// *                       C - Set if ACOB bit 7 of result is set; cleared otherwise.
	// * Description        : Multiply the unsigned binary numbers in the accumulators and place the result In both accumulators
	// *                    (ACCA contains the most significant byte of the result). Unsigned multiply allows multiple precision
	// *                    operations.
	// * Addressing Mode    : Inherent
	// */
	//MulInstruction:
	//    instruction = 'MUL'
	//;
	public MulInstructionElements getMulInstructionAccess() {
		return pMulInstruction;
	}
	
	public ParserRule getMulInstructionRule() {
		return getMulInstructionAccess().getRule();
	}
	
	///*
	// * LSR
	// *
	// * Logical Shift Right
	// * Source Form        : LSR Q, LSRA; LSRB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Always cleared.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected.
	// *                       C - Loaded with bit zero of the original operand.
	// * Description        : Performs a logical shift right on the operand. Shifts a zero into bit seven and bit
	// *                    zero into the C (carry) bit.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//LsrInstruction:
	//    (
	//       instruction = ('LSRA' | 'LSRB')
	//    )
	//    |
	//    (
	//         instruction = ('LSR')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public LsrInstructionElements getLsrInstructionAccess() {
		return pLsrInstruction;
	}
	
	public ParserRule getLsrInstructionRule() {
		return getLsrInstructionAccess().getRule();
	}
	
	///*
	// * LSL
	// *
	// * Logical Shift Left
	// * Source Form        : LSL Q, LSLA; LSLB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Shifts all bits of accumulator A or B or memory location M one place to the left.
	// *                    Bit zero is loaded with a zero. Bit seven of accumulator A or B or memory location M
	// *                    is shifted into the (carry) bit.
	// * Addressing Mode    : Inherent
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//LslInstruction:
	//    (
	//       instruction = ('LSLA' | 'LSLB')
	//    )
	//    |
	//    (
	//         instruction = ('LSL')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public LslInstructionElements getLslInstructionAccess() {
		return pLslInstruction;
	}
	
	public ParserRule getLslInstructionRule() {
		return getLslInstructionAccess().getRule();
	}
	
	///*
	// * LEA
	// *
	// * Load Effective Address
	// * Source Form        : LEAX, LEAY, LEAS, LEAU
	// * Operation        : R <- EA
	// * Condition Codes    : H - Not affected.
	// *                       N - Not affected.
	// *                       Z -  LEAX, LEAY: Set if the result is zero; cleared otherwise
	// *                         LEAS, LEAU: Not affected.
	// *                    V - Not affected.
	// *                       C - Not affected.
	// * Description        : Calculates the effective address from the indexed addressing and places the address in an
	// *                    indexable register. LEAX and LEAY affect the Z (zero) bit to allow use of these registers
	// *                    as counters and for MC6800 INX/DEX compatibility. LEAU and LEAS do not affect the Z bit to
	// *                    allow cleaning up the stack while returning the Z bit as a parameter to a calling routine,
	// *                    and also for MC6800 INS/DES compatibility.
	// * Addressing Mode    : Indexed
	// */
	//LeaInstruction:
	//     instruction = ('LEAX' | 'LEAY' | 'LEAS' | 'LEAU' )
	//    WS operand = IndexedOperand
	//;
	public LeaInstructionElements getLeaInstructionAccess() {
		return pLeaInstruction;
	}
	
	public ParserRule getLeaInstructionRule() {
		return getLeaInstructionAccess().getRule();
	}
	
	///*
	// * LD (16 bits)
	// *
	// * Load Register from Memory
	// * Source Form        : LDA P, LDB P
	// * Operation        : R <- M:M+1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Loads the contents of memory location M:M+1 into the designated 16 bits register.
	// * Addressing Mode    : Immediate
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//Ld16Instruction:
	//     instruction = ('LDD' | 'LDX' | 'LDY' | 'LDS' | 'LDU')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public Ld16InstructionElements getLd16InstructionAccess() {
		return pLd16Instruction;
	}
	
	public ParserRule getLd16InstructionRule() {
		return getLd16InstructionAccess().getRule();
	}
	
	///*
	// * LD (8 bits)
	// *
	// * Load Register from Memory
	// * Source Form        : LDA P, LDB P
	// * Operation        : R <- M
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Loads the contents of memory location M into the designated register.
	// * Addressing Mode    : Immediate
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//Ld8Instruction:
	//     instruction = ('LDA' | 'LDB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public Ld8InstructionElements getLd8InstructionAccess() {
		return pLd8Instruction;
	}
	
	public ParserRule getLd8InstructionRule() {
		return getLd8InstructionAccess().getRule();
	}
	
	///*
	// * JSR
	// *
	// * Jump to Subroutine
	// * Source Form        : JSR EA
	// * Operation        : SP' SP-1,(SP)*-PCL
	// *                    SP' SP-1,(SP)*-PCH
	// *                    PC EA
	// * Condition Codes    : Not affected.
	// * Description        : Program control is transferred to the effective address after storing the return address on the
	// *                    hardware stack. A RTS Instruction should be the last executed instruction of the subroutine.
	// * Addressing Mode    : Extended
	// *                    Direct
	// *                    Indexed
	// */
	//JsrInstruction:
	//     instruction = ('JSR')
	//    WS operand = (
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public JsrInstructionElements getJsrInstructionAccess() {
		return pJsrInstruction;
	}
	
	public ParserRule getJsrInstructionRule() {
		return getJsrInstructionAccess().getRule();
	}
	
	///*
	// * JMP
	// *
	// * Jump
	// * Source Form        : JMP EA
	// * Operation        : PC'*-EA
	// * Condition Codes    : Not affected.
	// * Description        : Program control is transferred to the effective address.
	// * Addressing Mode    : Extended
	// *                    Direct
	// *                    Indexed
	// */
	//JmpInstruction:
	//     instruction = ('JMP')
	//    WS operand = (
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public JmpInstructionElements getJmpInstructionAccess() {
		return pJmpInstruction;
	}
	
	public ParserRule getJmpInstructionRule() {
		return getJmpInstructionAccess().getRule();
	}
	
	///*
	// * INC
	// *
	// * Increment
	// * Source Form        : INC Q, INCA; INCB
	// * Operation        : M' M+1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V -Set if the original operand was 01111111; cleared otherwise.
	// *                       C - Not affected.
	// * Description        : Adds to the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter in multiple-precision computations.
	// *                       When operating on unsigned values, only the BEQ and BNE branches can be expected to behave consistently. When operating on twos complement values,
	// *                       all signed branches are correctly available.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//IncInstruction:
	//    (
	//       instruction = ('INCA' | 'INCB')
	//    )
	//    |
	//    (
	//         instruction = ('INC')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public IncInstructionElements getIncInstructionAccess() {
		return pIncInstruction;
	}
	
	public ParserRule getIncInstructionRule() {
		return getIncInstructionAccess().getRule();
	}
	
	///*
	// * EXG
	// *
	// * Exclusive OR
	// * Source Form        : EXG R1,R2
	// * Operation        : R1<->R2
	// * Condition Codes    : Not affected (unless one of the registers is the condition coderegister).
	// * Description        : Exchanges data between two designated registers. Bits 3-0 of the postbyte define one register,
	// *                    while bits 7-4 define the other, as follows:
	// *                                     0000 = A:B                1000 = A
	// *                                     0001 =X                    1001 = B
	// *                                     0010 = Y                1010 = COR
	// *                                     0011= US                1011= DPR
	// *                                     0100 = SP                1100 = Undefined
	// *                                     0101 = PC                1101 = Undefined
	// *                                     0110 = Undefined        1110 = Undefined
	// *                                     0111= Undefined            1111 = Undefined
	// *                     Only like size registers may be exchanged. (8-bit with 8-bit or 16-bit with 16-bit.)
	// * Addressing Mode    : Immediate
	// */
	//ExgInstruction:
	//    instruction = ('EXG' )
	//    WS reg1=Register ',' reg2=Register
	//;
	public ExgInstructionElements getExgInstructionAccess() {
		return pExgInstruction;
	}
	
	public ParserRule getExgInstructionRule() {
		return getExgInstructionAccess().getRule();
	}
	
	///*
	// * EOR
	// *
	// * Exclusive OR
	// * Source Form        : EORA P; EORB P
	// * Operation        : R' RM
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : The contents of memory location M is exclusive ORed into an 8-blt register..
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//EorInstruction:
	//    instruction = ('EORA' | 'EORB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public EorInstructionElements getEorInstructionAccess() {
		return pEorInstruction;
	}
	
	public ParserRule getEorInstructionRule() {
		return getEorInstructionAccess().getRule();
	}
	
	///*
	// * DEC
	// *
	// * Decrement
	// * Source Form        : DEC Q, DECA; DECB
	// * Operation        : M' M-1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if the original operand was 10000000; cleared otherwise.
	// *                       C - Not affected.
	// * Description        : Subtract one from the operand. The carry bit is not affected, thus allowing this instruction to be used as a loop counter
	// *                    in multipleprecision computations. When operating on unsigned values, only BEQ and BNE branches can be expected to behave consistently.
	// *                    When operating on twos complement values, all signed branches are available.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//DecInstruction:
	//    (
	//       instruction = ('DECA' | 'DECB')
	//    )
	//    |
	//    (
	//         instruction = ('DEC')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public DecInstructionElements getDecInstructionAccess() {
		return pDecInstruction;
	}
	
	public ParserRule getDecInstructionRule() {
		return getDecInstructionAccess().getRule();
	}
	
	///*
	// * DAA
	// *
	// * Decimal Addition Adjust
	// * Source Form        : DAA
	// * Operation        : ACCA' ACCA + OF (MSN):CF(LSN)
	// *                    where OF is a Correction Factor, as follows: the CF for each nibble
	// *                    (BCD) digit is determined separately, and is either 6 or 0.
	// *
	// *                    Least Significant Nibble
	// *                    CF(LSN) = 6IFF1)C = 1
	// *                                     or2)LSN>9
	// *
	// *                    Most Significant Nibble
	// *                   CF(MSN) = 6IFF1)C = 1
	// *                                     or 2) MSN > 9
	// *                                     or 3) MSN > 8 and LSN> 9
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Undefined
	// *                       C - Set if a carry is generated or if the carry bit was set before the operation; cleared otherwise.
	// * Description        : The sequence of a single-byte add instruction on accumulator A (either ADDA or ADCA) and a following decimal addition adjust instruction results
	// *                    in a BCD addition with an appropriate carry bit. Both values to be added must be in proper BCD form (each nibble such that: 0<nibble<9).
	// *                    Multiple-precision addition must add the carry generated by this decimal addition adjust into the next higher digit during the add operation (ADCA)
	// *                    immediately prior to the next decimal addition adjust.
	// * Addressing Mode    : inherent
	// */
	//DaaInstruction:
	//    instruction = 'DAA'
	//;
	public DaaInstructionElements getDaaInstructionAccess() {
		return pDaaInstruction;
	}
	
	public ParserRule getDaaInstructionRule() {
		return getDaaInstructionAccess().getRule();
	}
	
	///*
	// * CWAI
	// *
	// * Clear CC bits and Wait for Interrupt
	// * Source Form        : CWAI #$xx
	// * Operation        : CCR'^CCR A Ml (Possibly clear masks)
	// *                    Set E (entire state saved)
	// *                    SP' SP-1,(SP)*-PCL
	// *                    SP' SP-1,(SP) PCH
	// *                    SP'*-SP-1,(SP) USL
	// *                    SP' SP-1,(SP) USH
	// *                    SP' SP-1,(SP)*-IYL
	// *                    SP'*-SP-1,(SP) lYH
	// *                    SP' SP-1,(SP)-IXL
	// *                    SP'SP-1,(SP) IXH
	// *                    SP' SP-1,(SP)-DPR
	// *                    SP'-SP-1,(SP)-ACCB
	// *                    SP'^SP-1, (SP) ACCA
	// *                    SP' SP-1,(SP)-CCR
	// * Condition Codes    : Affected according to the operation.
	// * Description        : This instruction ANDs an immediate byte with the condition code register which may clear the
	// *                    interrupt mask bits I and F, stacks the entire machine state on the hardware stack and then
	// *                    looks for an interrupt. When a non-masked interrupt occurs, no further machine state information
	// *                    need be saved before vectoring to the interrupt handling routine. This instruction replaced the
	// *                    MC6800 CLI WAI sequence, but does not place the buses in a high-impedance state. A FIRQ
	// *                    (fast interrupt request) may enter its interrupt handler with its entire machine state saved.
	// *                    The RTI (return from interrupt) instruction will automatically return the entire machine state
	// *                    after testing the E (entire) bit of the recovered condition code register.
	// * Addressing Mode    : Immediate
	// */
	//CwaiInstruction:
	//     instruction = ('CWAI')
	//    WS operand = (
	//        ImmediatOperand
	//    )
	//;
	public CwaiInstructionElements getCwaiInstructionAccess() {
		return pCwaiInstruction;
	}
	
	public ParserRule getCwaiInstructionRule() {
		return getCwaiInstructionAccess().getRule();
	}
	
	///*
	// * COM
	// *
	// * Complement
	// * Source Form        : COM Q, COMA; COMB
	// * Operation        : M'< 0 + !M
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Always cleared.
	// *                       C - Always set.
	// * Description        : Replaces the contents of memory location M or accumulator A or B with its logical complement.
	// *                    When operating on unsigned values, only BEQ and BNE branches can be expected to behave properly
	// *                    following a COM instruction. When operating on twos complement values, all signed branches are
	// *                    available.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//ComInstruction:
	//    (
	//        instruction = ('COMA' | 'COMB')
	//    )
	//    |
	//    (
	//         instruction = ('COM')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public ComInstructionElements getComInstructionAccess() {
		return pComInstruction;
	}
	
	public ParserRule getComInstructionRule() {
		return getComInstructionAccess().getRule();
	}
	
	///*
	// * CMP
	// *
	// * Compare Memory from Register
	// * Source Form        : CMPA Q, CMPB Q
	// * Operation        : TEMP<-R_M
	// * Condition Codes    : H - Undefined.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result is zero; cleared otherwise.
	// *                    V - Set if an overflow is generated; cleared otherwise.
	// *                       C - Set if a borrow is generated; cleared otherwise.
	// * Description        : Compares the contents of memory location to the contents of the specified register and sets the
	// *                    appropriate condition codes. Neither memory location M nor the specified register is modified.
	// *                    The carry flag represents a borrow and is set to the inverse of the resulting binary carry.
	// * Addressing Mode    : Immediate
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//CmpInstruction:
	//     instruction = ('CMPA' | 'CMPB')
	//    WS operand = (
	//        ImmediatOperand      |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public CmpInstructionElements getCmpInstructionAccess() {
		return pCmpInstruction;
	}
	
	public ParserRule getCmpInstructionRule() {
		return getCmpInstructionAccess().getRule();
	}
	
	///*
	// * CLR
	// *
	// * Clear
	// * Source Form        : CLR Q, CLRA; CLRB
	// * Operation        : TEMP<-M
	// *                    : M<OO16
	// * Condition Codes    : H - Not affected.
	// *                       N - Always cleared.
	// *                       Z - Always set.
	// *                    V - Always cleared.
	// *                       C - Always cleared.
	// * Description        : Accumulator A or B or memory location M is loaded with 00000000.
	// *                       Note that the EA is read during this operation.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//ClrInstruction:
	//    (
	//        instruction = ('CLRA' | 'CLRB')
	//    )
	//    |
	//    (
	//         instruction = ('CLR')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public ClrInstructionElements getClrInstructionAccess() {
		return pClrInstruction;
	}
	
	public ParserRule getClrInstructionRule() {
		return getClrInstructionAccess().getRule();
	}
	
	///*
	// * BVS
	// *
	// * Branch on Overflow set
	// * Source Form        : BVS dd; LBVS DDDD
	// * Operation        : TEMP-MI
	// *                    IFF V = 1 then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the V (overflow) bit and causes a branch if it is set. That is, branch if the
	// *                    twos complement result was valid. When used after an operation on twos complement binary values, this
	// *                    instruction will branch if there was no overflow.
	// * Addressing Mode    : Relative
	// */
	//BvsInstruction:
	//     instruction = ('BVS' | 'LBVS')
	//    WS operand = RelativeMode
	//;
	public BvsInstructionElements getBvsInstructionAccess() {
		return pBvsInstruction;
	}
	
	public ParserRule getBvsInstructionRule() {
		return getBvsInstructionAccess().getRule();
	}
	
	///*
	// * BVC
	// *
	// * Branch on Overflow Clear
	// * Source Form        : BVC dd; LBVC DDDD
	// * Operation        : TEMP-MI
	// *                    IFF V = 0 then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the V (overflow) bit and causes a branch if it is clear. That is, branch if the
	// *                    twos complement result was valid. When used after an operation on twos complement binary values, this
	// *                    instruction will branch if there was no overflow.
	// * Addressing Mode    : Relative
	// */
	//BvcInstruction:
	//     instruction = ('BVC' | 'LBVC')
	//    WS operand = RelativeMode
	//;
	public BvcInstructionElements getBvcInstructionAccess() {
		return pBvcInstruction;
	}
	
	public ParserRule getBvcInstructionRule() {
		return getBvcInstructionAccess().getRule();
	}
	
	///*
	// * BSR
	// *
	// * Branch to Subroutine
	// * Source Form        : BSR dd; LBSR DDDD
	// * Operation        : TEMP-MI
	// *                    SP' SP-1,(SP) POL
	// *                       SP'-SP-1,(SP) PCH
	// *                       PC PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : The program counter is pushed onto the stack. The program counter is then loaded with the sum
	// *                       of the program counter and the offset.
	// * Addressing Mode    : Relative
	// */
	//BsrInstruction:
	//     instruction = ('BSR' | 'LBSR')
	//    WS operand = RelativeMode
	//;
	public BsrInstructionElements getBsrInstructionAccess() {
		return pBsrInstruction;
	}
	
	public ParserRule getBsrInstructionRule() {
		return getBsrInstructionAccess().getRule();
	}
	
	///*
	// * BRN
	// *
	// * Branch Never
	// * Source Form        : BRN dd; LBRN DDDD
	// * Operation        : TEMP-MI
	// * Condition Codes    : Not affected.
	// * Description        : Does not cause a branch. This instruction is essentially a no operation, but has a bit pattern logically related to branch always.
	// * Addressing Mode    : Relative
	// */
	//BrnInstruction:
	//     instruction = ('BRN' | 'LBRN')
	//    WS operand = RelativeMode
	//;
	public BrnInstructionElements getBrnInstructionAccess() {
		return pBrnInstruction;
	}
	
	public ParserRule getBrnInstructionRule() {
		return getBrnInstructionAccess().getRule();
	}
	
	///*
	// * BRA
	// *
	// * Branch always
	// * Source Form        : BRA dd; LBRA DDDD
	// * Operation        : TEMP-MI
	// *                    PC PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes an unconditlonai branch.
	// * Addressing Mode    : Relative
	// */
	//BraInstruction:
	//     instruction = ('BRA' | 'LBRA')
	//    WS operand = RelativeMode
	//;
	public BraInstructionElements getBraInstructionAccess() {
		return pBraInstruction;
	}
	
	public ParserRule getBraInstructionRule() {
		return getBraInstructionAccess().getRule();
	}
	
	///*
	// * BPL
	// *
	// * Branch on plus
	// * Source Form        : BPL dd; LBPL DDDD
	// * Operation        : TEMP-MI
	// *                    IFF N=0 then PC PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the N (negative) bit and causes a branch if it is clear. That is, branch if the sign of
	// *                    the twos complement result is positive.
	// * Addressing Mode    : Relative
	// */
	//BplInstruction:
	//     instruction = ('BPL' | 'LBPL')
	//    WS operand = RelativeMode
	//;
	public BplInstructionElements getBplInstructionAccess() {
		return pBplInstruction;
	}
	
	public ParserRule getBplInstructionRule() {
		return getBplInstructionAccess().getRule();
	}
	
	///*
	// * BNE
	// *
	// * Branch not equal
	// * Source Form        : BNE dd; LBNE DDDD
	// * Operation        : TEMP-MI
	// *                    IFF Z = then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the Z (zero) bit and causes a branch if it is clear. When used after a subtract or compare
	// *                       operation on any binary values, this instruction will branch if the register is, or would be, not equal to the
	// *                    memory operand.
	// * Addressing Mode    : Relative
	// */
	//BneInstruction:
	//     instruction = ('BNE' | 'LBNE')
	//    WS operand = RelativeMode
	//;
	public BneInstructionElements getBneInstructionAccess() {
		return pBneInstruction;
	}
	
	public ParserRule getBneInstructionRule() {
		return getBneInstructionAccess().getRule();
	}
	
	///*
	// * BMI
	// *
	// * Branch on Minus
	// * Source Form        : BMI dd; LBMI DDDD
	// * Operation        : TEMP-MI
	// *                    IFF N = 1 then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the N (negative) bit and causes a branch if set.
	// *                      That is, branch if the sign of the twos compiement result is negative.
	// * Addressing Mode    : Relative
	// */
	//BmiInstruction:
	//     instruction = ('BMI' | 'LBMI')
	//    WS operand = RelativeMode
	//;
	public BmiInstructionElements getBmiInstructionAccess() {
		return pBmiInstruction;
	}
	
	public ParserRule getBmiInstructionRule() {
		return getBmiInstructionAccess().getRule();
	}
	
	///*
	// * BLT
	// *
	// * Branch on Less than Zero
	// * Source Form        : BLT dd; LBLT DDDD
	// * Operation        : TEMP-MI
	// *                    IFF [NeV]=1 then PCPC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if either, but not both, of the N (negative) or V (overflow) bits is set. That is, branch
	// *                    if the sign of a valid twos complement result is, or would be, negative. When used after a subtract or compare
	// *                    operation on twos complement binary values, this instruction will branch if the register was less than the memory
	// *                    operand.
	// * Addressing Mode    : Relative
	// */
	//BltInstruction:
	//     instruction = ('BLT' | 'LBLT')
	//    WS operand = RelativeMode
	//;
	public BltInstructionElements getBltInstructionAccess() {
		return pBltInstruction;
	}
	
	public ParserRule getBltInstructionRule() {
		return getBltInstructionAccess().getRule();
	}
	
	///*
	// * BLS
	// *
	// * Branch on Lower
	// * Source Form        : BLS dd; LBLS DDDD
	// * Operation        : TEMP-MI
	// *                    IFF(CvZ) = 1 then PC PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if the previous operation caused either a carry or a zero result. When used after a subtract or
	// *                    compare operation on unsigned binary values, this instruction will branch if the register was lower than or the
	// *                    same as the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BlsInstruction:
	//     instruction = ('BLS' | 'LBLS')
	//    WS operand = RelativeMode
	//;
	public BlsInstructionElements getBlsInstructionAccess() {
		return pBlsInstruction;
	}
	
	public ParserRule getBlsInstructionRule() {
		return getBlsInstructionAccess().getRule();
	}
	
	///*
	// * BLO
	// *
	// * Branch on Lower
	// * Source Form        : BLO dd; LBLO DDDD
	// * Operation        : TEMP-MI
	// *                    IFF = 1 then PO'*-PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the (carry) bit and causes a branch if it is set. When used after a subtract or compare on unsigned
	// *                    binary values, this instruction will branch if the register was lower than the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BloInstruction:
	//     instruction = ('BLO' | 'LBLO')
	//    WS operand = RelativeMode
	//;
	public BloInstructionElements getBloInstructionAccess() {
		return pBloInstruction;
	}
	
	public ParserRule getBloInstructionRule() {
		return getBloInstructionAccess().getRule();
	}
	
	///*
	// * BLE
	// *
	// * Branch on Less than or Equal to Zero
	// * Source Form        : BLE dd; LBLE DDDD
	// * Operation        : TEMP-MI
	// *                    IFF Z V [N  V] = 1 then PC- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if the exclusive OR of the N (negative) and V (overflow) bits is 1 or if the Z (zero) bit is set.
	// *                    That is, branch if the sign of a valid twos complement result is, or would be, negative. When used after a subtract
	// *                    or compare operation on twos complement values, this instruction will branch if the register was less than or equal
	// *                    to the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BleInstruction:
	//     instruction = ('BLE' | 'LBLE')
	//    WS operand = RelativeMode
	//;
	public BleInstructionElements getBleInstructionAccess() {
		return pBleInstruction;
	}
	
	public ParserRule getBleInstructionRule() {
		return getBleInstructionAccess().getRule();
	}
	
	///*
	// * BIT
	// *
	// * Bit Test
	// * Source Form        : Bit P
	// * Operation        : TEMP RAM
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V -  Always cleared
	// *                       C - Not affected.
	// * Description        : Performs the logical AND of the contents of accumulator A or B and the contents of memory location M and modifies the condition
	// *                    codes accordingly. The contents of accumulator A or B and memory location M are not affected.
	// * Addressing Mode    : Immediate
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//BitInstruction:
	//    instruction = ('BITA' | 'BITB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public BitInstructionElements getBitInstructionAccess() {
		return pBitInstruction;
	}
	
	public ParserRule getBitInstructionRule() {
		return getBitInstructionAccess().getRule();
	}
	
	///*
	// * BHS
	// *
	// * Branch if Higher or Same
	// * Source Form        : BHS dd; LBHS DDDD
	// * Operation        : TEMP Ml
	// *                    IFF C = 0 then PC'^PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the C (carry) bit and causes a branch if it is clear.
	// *                    When used after a subtract or compare on unsigned binary values,
	// *                    this instruction will branch if the register was higher than or the
	// *                    same as the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BhsInstruction:
	//     instruction = ('BHS' | 'LBHS')
	//    WS operand = RelativeMode
	//;
	public BhsInstructionElements getBhsInstructionAccess() {
		return pBhsInstruction;
	}
	
	public ParserRule getBhsInstructionRule() {
		return getBhsInstructionAccess().getRule();
	}
	
	///*
	// * BHI
	// *
	// * Branch if Higher
	// * Source Form        : BHI dd; LBHI DDDD
	// * Operation        : TEMP Ml
	// *                    IFF [0 V Z] = 0 then PC'^PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if the previous operation caused neither a carry nor
	// *                    a zero result. When used after a subtract or compare operation on
	// *                    unsigned binary values, this instruction will branch if the register
	// *                    was higher than the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BhiInstruction:
	//     instruction = ('BHI' | 'LBHI')
	//    WS operand = RelativeMode
	//;
	public BhiInstructionElements getBhiInstructionAccess() {
		return pBhiInstruction;
	}
	
	public ParserRule getBhiInstructionRule() {
		return getBhiInstructionAccess().getRule();
	}
	
	///*
	// * BGT
	// *
	// * Branch on Greater than or Equal to Zero
	// * Source Form        : BGT dd; LBGT DDDD
	// * Operation        : TEMP Ml
	// *                    IFF ZA[NV] = 0 then PC'^PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if the N (negative) bit and V (overflow) bit are either
	// *                      both set or both clear and the Z (zero) bit is clear. In other words,
	// *                       branch if the sign of a valid twos complement result is, or would be,
	// *                       positive and not zero. When used after a subtract or compare operation on twos complement values, this instruction will branch if the
	// *                       register was greater than the memory operand.
	// * Addressing Mode    : Relative
	// */
	//BgtInstruction:
	//     instruction = ('BGT' | 'LBGT')
	//    WS operand = RelativeMode
	//;
	public BgtInstructionElements getBgtInstructionAccess() {
		return pBgtInstruction;
	}
	
	public ParserRule getBgtInstructionRule() {
		return getBgtInstructionAccess().getRule();
	}
	
	///*
	// * BGE
	// *
	// * Branch on Greater than or Equal to Zero
	// * Source Form        : BGE dd; LBGE DDDD
	// * Operation        : TEMP Ml
	// *                    IFF [NV] = then PC'^PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Causes a branch if the N (negative) bit and the V (overflow) bit are
	// *                      either both set or both clear. That is, branch if the sign of a valid
	// *                    twos complement result is, or would be, positive. When used after a
	// *                    subtract or compare operation on twos complement values, this instruction will branch if the register was greater than or equal to the
	// *                    memory operand.
	// * Addressing Mode    : Relative
	// */
	//BgeInstruction:
	//     instruction = ('BGE' | 'LBGE')
	//    WS operand = RelativeMode
	//;
	public BgeInstructionElements getBgeInstructionAccess() {
		return pBgeInstruction;
	}
	
	public ParserRule getBgeInstructionRule() {
		return getBgeInstructionAccess().getRule();
	}
	
	///*
	// * BEQ
	// *
	// * Branch on Equal
	// * Source Form        : BEQ dd; LBEQ DDDD
	// * Operation        : TEMP Ml
	// *                    IFF Z=1  then PC'<- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the Z (zero) bit and causes a branch if it is set.
	// *                       When used after a subtract or compare operation, this Instruction
	// *                       will branch If the compared values, signed or unsigned, were exactly
	// *                       the same.
	// * Addressing Mode    : Relative
	// */
	//BeqInstruction:
	//     instruction = ('BEQ' | 'LBEQ')
	//    WS operand = RelativeMode
	//;
	public BeqInstructionElements getBeqInstructionAccess() {
		return pBeqInstruction;
	}
	
	public ParserRule getBeqInstructionRule() {
		return getBeqInstructionAccess().getRule();
	}
	
	///*
	// * BCS
	// *
	// * Branch on Carry Set
	// * Source Form        : BCS dd; LBCS DDDD
	// * Operation        : TEMP Ml
	// *                    IFF C=A  then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the C (carry) bit and causes a branch If it Is set.
	// * Addressing Mode    : Relative
	// */
	//BcsInstruction:
	//     instruction = ('BCS' | 'LBCS')
	//    WS operand = RelativeMode
	//;
	public BcsInstructionElements getBcsInstructionAccess() {
		return pBcsInstruction;
	}
	
	public ParserRule getBcsInstructionRule() {
		return getBcsInstructionAccess().getRule();
	}
	
	///*
	// * BCC
	// *
	// * Branch on Carry Clear
	// * Source Form        : BCC dd; LBCC DDDD
	// * Operation        : TEMP Ml
	// *                    IFF C = then PC'*- PC + TEMP
	// * Condition Codes    : Not affected.
	// * Description        : Tests the state of the C (carry) bit and causes a branch If it Is clear.
	// * Addressing Mode    : Relative
	// */
	//BccInstruction:
	//     instruction = ('BCC' | 'LBCC')
	//    WS operand = RelativeMode
	//;
	public BccInstructionElements getBccInstructionAccess() {
		return pBccInstruction;
	}
	
	public ParserRule getBccInstructionRule() {
		return getBccInstructionAccess().getRule();
	}
	
	///*
	// * ASR
	// *
	// * Arithmetic Shift Right
	// * Source Form        : ASR Q, ASLA; ASLB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AsrInstruction:
	//    (
	//        instruction = ('ASRA' | 'ASRB')
	//    )
	//    |
	//    (
	//         instruction = ('ASR')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public AsrInstructionElements getAsrInstructionAccess() {
		return pAsrInstruction;
	}
	
	public ParserRule getAsrInstructionRule() {
		return getAsrInstructionAccess().getRule();
	}
	
	///*
	// * ASL
	// *
	// * Arithmetic Shift Left
	// * Source Form        : ASL Q, ASLA; ASLB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is
	// *                    shifted into the C (carry) bit.
	// * Addressing Mode    : Inherent
	// */
	//AslInstruction:
	//    (
	//       instruction = ('ASLA' | 'ASLB')
	//    )
	//    |
	//    (
	//         instruction = ('ASL')
	//        WS operand = (
	//            DirectOperand  |
	//            IndexedOperand |
	//            ExtendedOperand |
	//            ExtendedIndirectOperand
	//        )
	//    )
	//;
	public AslInstructionElements getAslInstructionAccess() {
		return pAslInstruction;
	}
	
	public ParserRule getAslInstructionRule() {
		return getAslInstructionAccess().getRule();
	}
	
	///*
	// * ANDCC
	// *
	// * Logical AND Immediate Memory into Condition Code Register
	// * Source Form        : ANDOG #xx
	// * Operation        : R' R A Ml
	// * Condition Codes    : Affected according to the operation.
	// * Description        : PPerforms a logical AND between the condition code register and the Immediate byte specified In
	// *                    the instruction and places the result in the condition code register.
	// * Addressing Mode    : Immediate
	// */
	//AndCCInstruction:
	//    instruction = ('ANDCC')
	//    WS operand = (
	//        ImmediatOperand
	//    )
	//;
	public AndCCInstructionElements getAndCCInstructionAccess() {
		return pAndCCInstruction;
	}
	
	public ParserRule getAndCCInstructionRule() {
		return getAndCCInstructionAccess().getRule();
	}
	
	///*
	// * AND
	// *
	// * Logical AND Memory into Register
	// * Source Form        : ANDA P; ANDB P
	// * Operation        : R' RAM
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Performs the logical AND operation between the contents of an accumulator and the contents
	// *                       of memory location M and the result is stored in the accumulator.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AndInstruction:
	//    instruction = ('ANDA' | 'ANDB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public AndInstructionElements getAndInstructionAccess() {
		return pAndInstruction;
	}
	
	public ParserRule getAndInstructionRule() {
		return getAndInstructionAccess().getRule();
	}
	
	///*
	// * ADDD
	// *
	// * Add Memory into Register
	// * Source Form        : ADDD P
	// * Operation        : R' R + M:M + 1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if an overflow is generated; cleared otherwise,
	// *                       C - Set if a carry is generated; cleared otherwise.
	// * Description        : Adds the 16-bit memory value into the 16-bit accumulator
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AdddInstruction:
	//    instruction = ('ADDD')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public AdddInstructionElements getAdddInstructionAccess() {
		return pAdddInstruction;
	}
	
	public ParserRule getAdddInstructionRule() {
		return getAdddInstructionAccess().getRule();
	}
	
	///*
	// * ADD
	// *
	// * Add Memory into Register
	// * Source Form        : ADDA P; ADDB P
	// * Operation        : R' R + M
	// * Condition Codes    : H - Set if a half-carry is generated; cleared otherwise,
	// *                       N - Set if the result Is negative; cleared otherwise,
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if an overflow is generated; cleared otherwise,
	// *                       C - Set if a carry is generated; cleared otherwise.
	// * Description        : Adds the memory byte into an 8-bit accumulator.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AddInstruction:
	//    instruction = ('ADDA' | 'ADDB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public AddInstructionElements getAddInstructionAccess() {
		return pAddInstruction;
	}
	
	public ParserRule getAddInstructionRule() {
		return getAddInstructionAccess().getRule();
	}
	
	///*
	// * ADC
	// *
	// * Add with Carry into Register
	// * Source Form        : ADCA P; ADCB P
	// * Operation        : R'*-R + M + C
	// * Condition Codes    : H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
	// *                       N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
	// *                       Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
	// *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
	// *                       C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
	// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AdcInstruction:
	//    instruction = ('ADCA' | 'ADCB')
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//;
	public AdcInstructionElements getAdcInstructionAccess() {
		return pAdcInstruction;
	}
	
	public ParserRule getAdcInstructionRule() {
		return getAdcInstructionAccess().getRule();
	}
	
	///*
	// * ABX
	// *
	// * Add Accumulator B into Index Register X
	// * Source Form        : ABX
	// * Operation        : IX' IX + ACCB
	// * Condition Codes    : Not affected.
	// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
	// * Addressing Mode    : Inherent
	// */
	//AbxInstruction:
	//    instruction = 'ABX'
	//;
	public AbxInstructionElements getAbxInstructionAccess() {
		return pAbxInstruction;
	}
	
	public ParserRule getAbxInstructionRule() {
		return getAbxInstructionAccess().getRule();
	}
	
	///*
	// * Extended Indirect
	// *
	// * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to
	// * two bytes in memory which are used as the effective address.
	// *
	// * Example:
	// * LDA [$A012] loads A from the address stored at locations $A012 and $A013
	// */
	//ExtendedIndirectOperand:
	//    '[' operand=Expression ']'
	//;
	public ExtendedIndirectOperandElements getExtendedIndirectOperandAccess() {
		return pExtendedIndirectOperand;
	}
	
	public ParserRule getExtendedIndirectOperandRule() {
		return getExtendedIndirectOperandAccess().getRule();
	}
	
	///*
	// * Extended
	// *
	// * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
	// * memory address value.
	// *
	// * Example:
	// * LDA $1000 load A from memory location 1000 hex
	// */
	//ExtendedOperand:
	//    ('>'?) operand=Expression
	//;
	public ExtendedOperandElements getExtendedOperandAccess() {
		return pExtendedOperand;
	}
	
	public ParserRule getExtendedOperandRule() {
		return getExtendedOperandAccess().getRule();
	}
	
	////
	////IndexedOperand:
	////
	////;
	///*
	// * Direct
	// * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
	// * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
	// * found in the Direct Page register. Thus, the effective address is a concatenation of the
	// * Direct Page register as the most significant half and the byte following the opcode as the
	// * least significant half.
	// *
	// * Example:
	// * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register
	// */
	//DirectOperand:
	//    '<' operand=Expression
	//;
	public DirectOperandElements getDirectOperandAccess() {
		return pDirectOperand;
	}
	
	public ParserRule getDirectOperandRule() {
		return getDirectOperandAccess().getRule();
	}
	
	///*
	// * Immediate
	// * In Immediate addressing the byte or bytes following the opcode are the information being
	// * addressed. These byte or bytes are specified as part of the instruction.
	// *
	// * Example:
	// * LDA #8 load immediate value (8) into A
	// */
	//ImmediatOperand:
	//    '#' operand=Expression
	//;
	public ImmediatOperandElements getImmediatOperandAccess() {
		return pImmediatOperand;
	}
	
	public ParserRule getImmediatOperandRule() {
		return getImmediatOperandAccess().getRule();
	}
	
	//IndexedOperand:
	//    mode=AutoIncDecMode  |
	//    mode=ConstantIndexedMode |
	//    mode=AccumulatorMovingMode |
	//    mode=RelatifToPCMode |
	//    mode=ConstantIndexedMovingIndirectMode |
	//    mode=AutoIncDecIndirectMode  |
	//    mode=AccumulatorMovingIndirectMode |
	//    mode=RelatifToPCIndirectMode
	//;
	public IndexedOperandElements getIndexedOperandAccess() {
		return pIndexedOperand;
	}
	
	public ParserRule getIndexedOperandRule() {
		return getIndexedOperandAccess().getRule();
	}
	
	//ConstantIndexedMode:
	//    deplacement=NumericalValue?
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//;
	public ConstantIndexedModeElements getConstantIndexedModeAccess() {
		return pConstantIndexedMode;
	}
	
	public ParserRule getConstantIndexedModeRule() {
		return getConstantIndexedModeAccess().getRule();
	}
	
	//ConstantIndexedMovingIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//    ']'
	//;
	public ConstantIndexedMovingIndirectModeElements getConstantIndexedMovingIndirectModeAccess() {
		return pConstantIndexedMovingIndirectMode;
	}
	
	public ParserRule getConstantIndexedMovingIndirectModeRule() {
		return getConstantIndexedMovingIndirectModeAccess().getRule();
	}
	
	//AccumulatorMovingMode:
	//    deplacement=('A' | 'B' | 'D')
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//;
	public AccumulatorMovingModeElements getAccumulatorMovingModeAccess() {
		return pAccumulatorMovingMode;
	}
	
	public ParserRule getAccumulatorMovingModeRule() {
		return getAccumulatorMovingModeAccess().getRule();
	}
	
	//AccumulatorMovingIndirectMode:
	//    '['
	//    deplacement=('A' | 'B' | 'D')
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//    ']'
	//;
	public AccumulatorMovingIndirectModeElements getAccumulatorMovingIndirectModeAccess() {
		return pAccumulatorMovingIndirectMode;
	}
	
	public ParserRule getAccumulatorMovingIndirectModeRule() {
		return getAccumulatorMovingIndirectModeAccess().getRule();
	}
	
	//AutoIncDecMode:
	//    deplacement=NumericalValue?
	//    ','
	//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	//;
	public AutoIncDecModeElements getAutoIncDecModeAccess() {
		return pAutoIncDecMode;
	}
	
	public ParserRule getAutoIncDecModeRule() {
		return getAutoIncDecModeAccess().getRule();
	}
	
	//AutoIncDecIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	//    ']'
	//;
	public AutoIncDecIndirectModeElements getAutoIncDecIndirectModeAccess() {
		return pAutoIncDecIndirectMode;
	}
	
	public ParserRule getAutoIncDecIndirectModeRule() {
		return getAutoIncDecIndirectModeAccess().getRule();
	}
	
	//RelatifToPCMode:
	//    deplacement=NumericalValue?
	//    ','
	//    (register='PCR' )
	//;
	public RelatifToPCModeElements getRelatifToPCModeAccess() {
		return pRelatifToPCMode;
	}
	
	public ParserRule getRelatifToPCModeRule() {
		return getRelatifToPCModeAccess().getRule();
	}
	
	//RelatifToPCIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    (register='PCR' )
	//    ']'
	//;
	public RelatifToPCIndirectModeElements getRelatifToPCIndirectModeAccess() {
		return pRelatifToPCIndirectMode;
	}
	
	public ParserRule getRelatifToPCIndirectModeRule() {
		return getRelatifToPCIndirectModeAccess().getRule();
	}
	
	//RelativeMode:
	//    isPcRelative?='*'? offset=Expression
	//;
	public RelativeModeElements getRelativeModeAccess() {
		return pRelativeMode;
	}
	
	public ParserRule getRelativeModeRule() {
		return getRelativeModeAccess().getRule();
	}
	
	///*
	// * Definition of the list possible directives
	// */
	//DirectiveLine:
	//    (name = IdentifierValue)? WS
	//    (
	//            directive = EquDirective
	//        |  directive = OrgDirective
	//        |  directive = BszDirective
	//        |  directive = EndDirective
	//        |  directive = FailDirective
	//        |  directive = FillDirective
	//        |  directive = OptDirective
	//        |  directive = PagDirective
	//        |  directive = NamDirective
	//        |  directive = SetDirective
	//        |  directive = SpcDirective
	//        |  directive = RegDirective
	//        |  directive = FcbDirective
	//        |  directive = FdbDirective
	//        |  directive = FccDirective
	//        |  directive = RmbDirective
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public DirectiveLineElements getDirectiveLineAccess() {
		return pDirectiveLine;
	}
	
	public ParserRule getDirectiveLineRule() {
		return getDirectiveLineAccess().getRule();
	}
	
	///*
	// * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
	// * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will
	// * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid
	// * examples follow:
	// *
	// * LABEL1 FCC 'THIS IS AN FCC STRING'
	// * LABEL2 FCC .SO IS THIS.
	// * FCC /LABELS ARE NOT REQUIRED./
	// *
	// * There is another method of using FCC which is a deviation from the standard Motorola definition of this
	// * directive. This allows you to place certain expressions on the same line as the standard FCC delimited
	// * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
	// * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter,
	// * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111
	// * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
	// * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
	// * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
	// * inserted along with strings. Some examples follow:
	// *
	// * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
	// * FCC 'STRING 1',0,'STRING 2'
	// * FCC $04,LABEL,/DELIMITED STRING/
	// *
	// * Note that more than one delimited string may be placed on a line as in the second example.
	// */
	//FccDirective:
	//    directive = 'FCC'
	//    (WS string=STRING)
	//;
	public FccDirectiveElements getFccDirectiveAccess() {
		return pFccDirective;
	}
	
	public ParserRule getFccDirectiveRule() {
		return getFccDirectiveAccess().getRule();
	}
	
	///*
	// *  REG
	// *
	// * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
	// * This list is represented by a value and the value is equated to the label supplied. In this respect,
	// * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
	// *
	// * <label> REG <register list>
	// *
	// * As an example, suppose a program has a large number of occurences of the following instructions:
	// *
	// * PSHS A,B,Y,U,DP
	// * PULS A,B,Y,U,DP
	// *
	// * To make things more convenient and less error prone the REG directive could be used as shown here:
	// *
	// * RLIST2 REG A,B,Y,U,DP
	// *
	// * Now all the pushes and pulls referred to above could be accomplished with the statements:
	// *
	// * PSHS #RLIST2
	// * PULS #RLIST2
	// *
	// * Of course, the register list may still be typed out on push and pull instructions or an immediate value
	// * (with the desired bit pattern) may be specified.
	// */
	//RegDirective:
	//    (directive = 'REG')
	//    (WS options+=Register ( ',' options+=Register)*)?
	//;
	public RegDirectiveElements getRegDirectiveAccess() {
		return pRegDirective;
	}
	
	public ParserRule getRegDirectiveRule() {
		return getRegDirectiveAccess().getRule();
	}
	
	///*
	// *  SPC
	// *
	// * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
	// *  listing. The general form is:
	// *
	// * SPC [<space count>[,<keep count>]]
	// *
	// * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
	// * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
	// * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
	// * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
	// *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
	// *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing.
	// */
	//SpcDirective:
	//    directive = 'SPC'
	//    (WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
	//;
	public SpcDirectiveElements getSpcDirectiveAccess() {
		return pSpcDirective;
	}
	
	public ParserRule getSpcDirectiveRule() {
		return getSpcDirectiveAccess().getRule();
	}
	
	///*
	// *  TTL or NAM
	// *
	// * The TTL or NAM directive allows the user to specify a title or name to the program being assembled.
	// * This title is then printed in the header at the top of each output listing page if the page option is
	// * selected. If the page option is not selected, this directive is ignored. The proper form is:
	// *
	// * TTL <text for the title>
	// * or
	// * NAM <text for the title>
	// *
	// * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer.
	// * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL
	// * or NAM directives in a source program. The latest one encountered will always be the one used for printing
	// * at the top of the following page(s).
	// */
	//NamDirective:
	//    (directive = 'NAM'|directive = 'TTL')
	//    WS (operand=IdentifierValue)
	//;
	public NamDirectiveElements getNamDirectiveAccess() {
		return pNamDirective;
	}
	
	public ParserRule getNamDirectiveRule() {
		return getNamDirectiveAccess().getRule();
	}
	
	///*
	// *  PAG
	// *
	// * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page.
	// * Note that the 'PAG' option must have been previously selected in order for this directive to take effect.
	// * It is possible to assign a new number to the new page by specifying such in the operand field. If no page
	// * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
	// *  The PAG operator itself will not appear in the listing unless some sort of error is encountered.
	// * The proper form is:
	// *
	// * PAG [<expression>]
	// *
	// * Where the expression is optional. The first page of a listing does not have the header printed on it and
	// * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and
	// * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title,
	// * or subtitle instructions being in the way.
	// */
	//PagDirective:
	//    directive = 'PAG'
	//    (WS (operand=Expression))?
	//;
	public PagDirectiveElements getPagDirectiveAccess() {
		return pPagDirective;
	}
	
	public ParserRule getPagDirectiveRule() {
		return getPagDirectiveAccess().getRule();
	}
	
	///*
	// * OPT
	// *
	// *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
	// *  These options are generally related to the format of the output listing and object code. The options which
	// *  may be set with this command are listed below. There are several options not listed here which may be set
	// *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper
	// * form of this instruction is:
	// *
	// * OPT <option 1>,<option 2>,...,<option n>
	// *
	// * Note that any number of options may be given on one line if separated by commas. No label is allowed and no
	// * spaces may be embedded in the option list. The options are all set during pass one only although the
	// * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are
	// * specified, the last one appearing takes precedence. If a particular option is not specified, the default
	// * case for that option takes effect. The default cases are signified below by an asterisk.
	// *
	// * The allowable options are:
	// *
	// * PAG enable page formatting and numbering
	// * NOP* disable pagination
	// *
	// * CON print conditionally skipped code
	// * NOC* suppress conditional code printing
	// *
	// * MAC* print macro calling lines
	// * NOM suppress printing of macro calls
	// *
	// * EXP print macro expansion lines
	// * NOE* Suppress macro expansion printing
	// *
	// * * denotes default option and is not part of option name
	// */
	//OptDirective:
	//    directive = 'OPT'
	//    (WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
	//;
	public OptDirectiveElements getOptDirectiveAccess() {
		return pOptDirective;
	}
	
	public ParserRule getOptDirectiveRule() {
		return getOptDirectiveAccess().getRule();
	}
	
	///*
	// * FAIL
	// *
	// *
	// */
	//FailDirective:
	//    directive = 'FAIL'
	//;
	public FailDirectiveElements getFailDirectiveAccess() {
		return pFailDirective;
	}
	
	public ParserRule getFailDirectiveRule() {
		return getFailDirectiveAccess().getRule();
	}
	
	///*
	// * SET
	// *
	// * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
	// * The difference is that a symbol may be SET several times within the source (to different values) while
	// * a symbol may be Equated only once.
	// * If a symbol is SET to several values within the source, the current value of the symbol will be
	// * the value last SET. The statement form is:
	// *
	// * <label> SET <expression>
	// *
	// * The label is strictly required and no code is generated.
	// */
	//SetDirective:
	//    directive = 'SET'
	//    WS (
	//        ( isRelativeToPC?='*'? operand=Expression) |
	//        ( isRelativeToPC?='*' )
	//        )
	//;
	public SetDirectiveElements getSetDirectiveAccess() {
		return pSetDirective;
	}
	
	public ParserRule getSetDirectiveRule() {
		return getSetDirectiveAccess().getRule();
	}
	
	///*
	// * FILL
	// *
	// * FILL allow to initialize a memory area with a value
	// * the first value define the value to set, the second value define the number of byte to set
	// */
	//FillDirective:
	//    directive = 'FILL'
	//    (WS value=Expression ',' number=Expression)
	//;
	public FillDirectiveElements getFillDirectiveAccess() {
		return pFillDirective;
	}
	
	public ParserRule getFillDirectiveRule() {
		return getFillDirectiveAccess().getRule();
	}
	
	///*
	// * BSZ
	// *
	// * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
	// * The operand define the number on byte to reserve
	// */
	//BszDirective:
	//    directive = ('BSZ'|'ZMB')
	//    (WS operand=Expression)
	//;
	public BszDirectiveElements getBszDirectiveAccess() {
		return pBszDirective;
	}
	
	public ParserRule getBszDirectiveRule() {
		return getBszDirectiveAccess().getRule();
	}
	
	///*
	// *  FDB
	// *
	// * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
	// * It is exactly like the FCB directive except that 16 bit quantities are evaluated
	// * and stored in memory for each expression given.
	// * The form of the statement is:
	// *
	// * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
	// *
	// * Again, the label field is optional.
	// */
	//FdbDirective:
	//    directive = 'FDB'
	//    (WS (operand = ListOfExpression))?
	//;
	public FdbDirectiveElements getFdbDirectiveAccess() {
		return pFdbDirective;
	}
	
	public ParserRule getFdbDirectiveRule() {
		return getFdbDirectiveAccess().getRule();
	}
	
	///*
	// *  The FCB or Form Constant Byte directive is used to set associated memory bytes
	// * to some value as determined by the operand.
	// * FCB may be used to set any number of bytes as shown below:
	// *
	// * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
	// *
	// * Where <expr. x> stands for some expression.
	// * Each expression given (separated by commas) is evaluated to 8 bits
	// * and the resulting quantities are stored in successive memory locations.
	// * The label is optional.
	// */
	//FcbDirective:
	//    directive = 'FCB'
	//    (WS (operand = ListOfExpression))?
	//;
	public FcbDirectiveElements getFcbDirectiveAccess() {
		return pFcbDirective;
	}
	
	public ParserRule getFcbDirectiveRule() {
		return getFcbDirectiveAccess().getRule();
	}
	
	///*
	// *  RMB
	// *
	// * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
	// * The number of bytes specified by the expression in the operand are skipped during assembly.
	// * No code is produced in those memory location and therefore the contents are undefined at run time.
	// *  The proper useage is shown here:
	// *
	// * [<label>] RMB <expression>
	// *
	// * The label is optional, and the expression is a 16 bit quantity.
	// */
	//RmbDirective:
	//    directive = 'RMB'
	//    (WS (isRelativeToPC?='*'? operand = Expression))?
	//;
	public RmbDirectiveElements getRmbDirectiveAccess() {
		return pRmbDirective;
	}
	
	public ParserRule getRmbDirectiveRule() {
		return getRmbDirectiveAccess().getRule();
	}
	
	///*
	// * The END pseudo-op is used to signal the assembler that the end of the source input has occurred.
	// * This terminates whatever pass is currently being executed. No label is allowed and no code is generated.
	// * An expression may be given (as shown below) as the transfer address to be placed in a binary file.
	// * It is optional, and if supplied when no binary file is being produced, will be ignored.
	// *
	// *  END [<expression>]
	// *
	// * Note that an end statement is not strictly required,
	// * but is the only means of getting a transfer address appended to a binary output file.
	// */
	//EndDirective:
	//    directive = 'END'
	//    (WS operand=IdentifierValue)?
	//;
	public EndDirectiveElements getEndDirectiveAccess() {
		return pEndDirective;
	}
	
	public ParserRule getEndDirectiveRule() {
		return getEndDirectiveAccess().getRule();
	}
	
	///*
	// *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
	// *
	// *         ORG <expression>
	// *
	// *    No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed.
	// */
	//OrgDirective:
	//    directive = 'ORG'
	//    (WS (
	//        (isRelativeToPC?='*'? operand=Expression) |
	//        (isRelativeToPC?='*' )
	//        ))?
	//;
	public OrgDirectiveElements getOrgDirectiveAccess() {
		return pOrgDirective;
	}
	
	public ParserRule getOrgDirectiveRule() {
		return getOrgDirectiveAccess().getRule();
	}
	
	///*
	// * Description of an EQU directive
	// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
	// */
	//EquDirective:
	//    directive = 'EQU'
	//    WS (
	//        ( isRelativeToPC?='*'? operand=Expression) |
	//        ( isRelativeToPC?='*' )
	//        )
	//;
	public EquDirectiveElements getEquDirectiveAccess() {
		return pEquDirective;
	}
	
	public ParserRule getEquDirectiveRule() {
		return getEquDirectiveAccess().getRule();
	}
	
	//ListOfExpression:
	//    expression=Expression
	//    (
	//         commaExpressions+=CommaExpression
	//    )*
	//;
	public ListOfExpressionElements getListOfExpressionAccess() {
		return pListOfExpression;
	}
	
	public ParserRule getListOfExpressionRule() {
		return getListOfExpressionAccess().getRule();
	}
	
	//CommaExpression:
	//    comma=',' expression=Expression?
	//;
	public CommaExpressionElements getCommaExpressionAccess() {
		return pCommaExpression;
	}
	
	public ParserRule getCommaExpressionRule() {
		return getCommaExpressionAccess().getRule();
	}
	
	//Expression:
	//        operand = Multiplication;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Multiplication returns Expression:
	//      Division ({Multiplication.left=current} operation='*' right=Division)*
	//;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	//Division returns Expression:
	//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
	//;
	public DivisionElements getDivisionAccess() {
		return pDivision;
	}
	
	public ParserRule getDivisionRule() {
		return getDivisionAccess().getRule();
	}
	
	//Modulo returns Expression:
	//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
	//;
	public ModuloElements getModuloAccess() {
		return pModulo;
	}
	
	public ParserRule getModuloRule() {
		return getModuloAccess().getRule();
	}
	
	//Addition returns Expression:
	//    Substraction ({Addition.left=current} '+' right=Substraction)*
	//;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}
	
	//Substraction returns Expression:
	//    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
	//;
	public SubstractionElements getSubstractionAccess() {
		return pSubstraction;
	}
	
	public ParserRule getSubstractionRule() {
		return getSubstractionAccess().getRule();
	}
	
	//LeftShift returns Expression:
	//    RightShift ({LeftShift.left=current} '<<' right=RightShift)*
	//;
	public LeftShiftElements getLeftShiftAccess() {
		return pLeftShift;
	}
	
	public ParserRule getLeftShiftRule() {
		return getLeftShiftAccess().getRule();
	}
	
	//RightShift returns Expression:
	//    And ({RightShift.left=current} '>>' right=And)*
	//;
	public RightShiftElements getRightShiftAccess() {
		return pRightShift;
	}
	
	public ParserRule getRightShiftRule() {
		return getRightShiftAccess().getRule();
	}
	
	//And returns Expression:
	//    Or ({And.left=current} '&&' right=Or)*
	//;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Or returns Expression:
	//    Xor ({Or.left=current} '||' right=Xor)*
	//;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//Xor returns Expression:
	//    Primary ({Xor.left=current} '^' right=Primary)*
	//;
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Primary returns Expression:
	//            value=DecimalValue
	//      |    value=HexaDecimalValue
	//      |    value=OctalValue
	//      |   value=BinaryValue
	//      |   value=CharacterValue
	//       |    value=IdentifierValue
	//       |   {Not} '!' value=Primary
	//      |  '(' Multiplication ')'
	// ;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//NumericalValue:
	//            value=DecimalValue
	//      |    value=HexaDecimalValue
	//      |    value=OctalValue
	//      |   value=BinaryValue
	//      |   value=CharacterValue
	//       |    value=IdentifierValue
	//;
	public NumericalValueElements getNumericalValueAccess() {
		return pNumericalValue;
	}
	
	public ParserRule getNumericalValueRule() {
		return getNumericalValueAccess().getRule();
	}
	
	//IdentifierValue:
	//    value=ID
	//;
	public IdentifierValueElements getIdentifierValueAccess() {
		return pIdentifierValue;
	}
	
	public ParserRule getIdentifierValueRule() {
		return getIdentifierValueAccess().getRule();
	}
	
	//StringValue:
	//    value=STRING
	//;
	public StringValueElements getStringValueAccess() {
		return pStringValue;
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}
	
	//DecimalValue:
	//    sign=('-'|'+')? value=NUMBERS
	//;
	public DecimalValueElements getDecimalValueAccess() {
		return pDecimalValue;
	}
	
	public ParserRule getDecimalValueRule() {
		return getDecimalValueAccess().getRule();
	}
	
	//HexaDecimalValue:
	//    value=HEXA
	//;
	public HexaDecimalValueElements getHexaDecimalValueAccess() {
		return pHexaDecimalValue;
	}
	
	public ParserRule getHexaDecimalValueRule() {
		return getHexaDecimalValueAccess().getRule();
	}
	
	//OctalValue:
	//    '@' value=NUMBERS
	//;
	public OctalValueElements getOctalValueAccess() {
		return pOctalValue;
	}
	
	public ParserRule getOctalValueRule() {
		return getOctalValueAccess().getRule();
	}
	
	//BinaryValue:
	//    '%' value=NUMBERS
	//;
	public BinaryValueElements getBinaryValueAccess() {
		return pBinaryValue;
	}
	
	public ParserRule getBinaryValueRule() {
		return getBinaryValueAccess().getRule();
	}
	
	//CharacterValue:
	//    value=CHARACTER
	//;
	public CharacterValueElements getCharacterValueAccess() {
		return pCharacterValue;
	}
	
	public ParserRule getCharacterValueRule() {
		return getCharacterValueAccess().getRule();
	}
	
	//enum AssemblyOption:
	//    PAG= 'PAG' |
	//    NOP= 'NOP' |
	//    CON= 'CON' |
	//    NOC= 'NOC' |
	//    MAC= 'MAC' |
	//    NOM= 'NOM' |
	//    EXP= 'EXP' |
	//    NOE= 'NOE'
	//    ;
	public AssemblyOptionElements getAssemblyOptionAccess() {
		return eAssemblyOption;
	}
	
	public EnumRule getAssemblyOptionRule() {
		return getAssemblyOptionAccess().getRule();
	}
	
	//enum Register:
	//    A = 'A'    |
	//    B = 'B'       |
	//    D = 'D'       |
	//    X = 'X'       |
	//    Y = 'Y'       |
	//    U = 'U'       |
	//    S = 'S'       |
	//    DP = 'DP'  |
	//    CC = 'CC'  |
	//    PC = 'PC'
	//;
	public RegisterElements getRegisterAccess() {
		return eRegister;
	}
	
	public EnumRule getRegisterRule() {
		return getRegisterAccess().getRule();
	}
	
	//terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
	public TerminalRule getHEXARule() {
		return tHEXA;
	}
	
	//terminal NUMBERS 								: ('0'..'9')+;
	public TerminalRule getNUMBERSRule() {
		return tNUMBERS;
	}
	
	////terminal OCTAL                                 : '@'('0'..'7')+;
	////terminal BINARY                             : '0''b'('0'..'1')+;
	//terminal CHARACTER                            : '\'' ('\u0020'..'\u007F');
	public TerminalRule getCHARACTERRule() {
		return tCHARACTER;
	}
	
	//EndOfLine: CR | END_OF_FILE;
	public EndOfLineElements getEndOfLineAccess() {
		return pEndOfLine;
	}
	
	public ParserRule getEndOfLineRule() {
		return getEndOfLineAccess().getRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
	//        ;
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
	public TerminalRule getANY_EXCEPT_COMMENT_END_OF_LINERule() {
		return tANY_EXCEPT_COMMENT_END_OF_LINE;
	}
	
	//terminal WS         						: (' '|'\t')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal CR          						: '\r'? '\n';
	public TerminalRule getCRRule() {
		return tCR;
	}
	
	//terminal END_OF_FILE 						: EOF;
	public TerminalRule getEND_OF_FILERule() {
		return tEND_OF_FILE;
	}
}

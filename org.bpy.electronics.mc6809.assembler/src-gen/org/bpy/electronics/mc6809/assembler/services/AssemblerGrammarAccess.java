/*
 * generated by Xtext 2.29.0
 */
package org.bpy.electronics.mc6809.assembler.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class AssemblerGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Model");
		private final Assignment cSourceLinesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSourceLinesSourceLineParserRuleCall_0 = (RuleCall)cSourceLinesAssignment.eContents().get(0);
		
		///*
		// * Entry point of an as9 file
		// */
		//Model:
		//    sourceLines += SourceLine*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sourceLines += SourceLine*
		public Assignment getSourceLinesAssignment() { return cSourceLinesAssignment; }
		
		//SourceLine
		public RuleCall getSourceLinesSourceLineParserRuleCall_0() { return cSourceLinesSourceLineParserRuleCall_0; }
	}
	public class SourceLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SourceLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLineContentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cLineContentBlankLineParserRuleCall_0_0 = (RuleCall)cLineContentAssignment_0.eContents().get(0);
		private final Assignment cLineContentAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLineContentCommentLineParserRuleCall_1_0 = (RuleCall)cLineContentAssignment_1.eContents().get(0);
		private final Assignment cLineContentAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cLineContentDirectiveLineParserRuleCall_2_0 = (RuleCall)cLineContentAssignment_2.eContents().get(0);
		
		///*
		// * Description of an assembler line.
		// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
		// */
		//SourceLine:
		//    (
		//          (lineContent = BlankLine)
		//        | (lineContent = CommentLine)
		//        | (lineContent = DirectiveLine)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//      (lineContent = BlankLine)
		//    | (lineContent = CommentLine)
		//    | (lineContent = DirectiveLine)
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(lineContent = BlankLine)
		public Assignment getLineContentAssignment_0() { return cLineContentAssignment_0; }
		
		//BlankLine
		public RuleCall getLineContentBlankLineParserRuleCall_0_0() { return cLineContentBlankLineParserRuleCall_0_0; }
		
		//(lineContent = CommentLine)
		public Assignment getLineContentAssignment_1() { return cLineContentAssignment_1; }
		
		//CommentLine
		public RuleCall getLineContentCommentLineParserRuleCall_1_0() { return cLineContentCommentLineParserRuleCall_1_0; }
		
		//(lineContent = DirectiveLine)
		public Assignment getLineContentAssignment_2() { return cLineContentAssignment_2; }
		
		//DirectiveLine
		public RuleCall getLineContentDirectiveLineParserRuleCall_2_0() { return cLineContentDirectiveLineParserRuleCall_2_0; }
	}
	public class BlankLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BlankLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlankLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBlankLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlankLineWSTerminalRuleCall_1_0 = (RuleCall)cBlankLineAssignment_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		///*
		// * Blanck line is an empty line or a set of space or tabs followed by a end of line
		// */
		//BlankLine:
		//    {BlankLine} (blankLine = WS)? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{BlankLine} (blankLine = WS)? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//{BlankLine}
		public Action getBlankLineAction_0() { return cBlankLineAction_0; }
		
		//(blankLine = WS)?
		public Assignment getBlankLineAssignment_1() { return cBlankLineAssignment_1; }
		
		//WS
		public RuleCall getBlankLineWSTerminalRuleCall_1_0() { return cBlankLineWSTerminalRuleCall_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_2() { return cEndOfLineParserRuleCall_2; }
	}
	public class CommentLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CommentLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCommentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0 = (RuleCall)cCommentAssignment_0.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		///*
		// * definition of a comment line
		// * A comment line start with a ; following by anything and finish with a end of line
		// */
		//CommentLine:
		//    comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		public Group getGroup() { return cGroup; }
		
		//comment = ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_0() { return cCommentAssignment_0; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_1() { return cEndOfLineParserRuleCall_1; }
	}
	public class DirectiveLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DirectiveLine");
		private final Assignment cDirectiveAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDirectiveEquDirectiveParserRuleCall_0 = (RuleCall)cDirectiveAssignment.eContents().get(0);
		
		///*
		// * Definition of the list possible directives
		// *     EQU
		// */
		//DirectiveLine:
		//    directive = EquDirective
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//directive = EquDirective
		public Assignment getDirectiveAssignment() { return cDirectiveAssignment; }
		
		//EquDirective
		public RuleCall getDirectiveEquDirectiveParserRuleCall_0() { return cDirectiveEquDirectiveParserRuleCall_0; }
	}
	public class EquDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EquDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveEQUKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOperandOperandParserRuleCall_4_0 = (RuleCall)cOperandAssignment_4.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cCommentAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0 = (RuleCall)cCommentAssignment_6.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * Description of an EQU directive
		// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
		// */
		//EquDirective:
		//    (name = IdentifierValue)? WS (directive = 'EQU') WS (operand = Operand)? WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'EQU') WS (operand = Operand)? WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'EQU')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'EQU'
		public Keyword getDirectiveEQUKeyword_2_0() { return cDirectiveEQUKeyword_2_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//(operand = Operand)?
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//Operand
		public RuleCall getOperandOperandParserRuleCall_4_0() { return cOperandOperandParserRuleCall_4_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_6() { return cCommentAssignment_6; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cOperandAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cOperandMultiplicationParserRuleCall_0_0 = (RuleCall)cOperandAssignment_0.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cOperandStringValueParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		//Operand:
		//        (operand = Multiplication)
		//    |     (operand = StringValue)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//    (operand = Multiplication)
		//|     (operand = StringValue)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(operand = Multiplication)
		public Assignment getOperandAssignment_0() { return cOperandAssignment_0; }
		
		//Multiplication
		public RuleCall getOperandMultiplicationParserRuleCall_0_0() { return cOperandMultiplicationParserRuleCall_0_0; }
		
		//(operand = StringValue)
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//StringValue
		public RuleCall getOperandStringValueParserRuleCall_1_0() { return cOperandStringValueParserRuleCall_1_0; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivisionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperationAsteriskKeyword_1_1_0 = (Keyword)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivisionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//      Division ({Multiplication.left=current} operation='*' right=Division)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Division ({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup() { return cGroup; }
		
		//Division
		public RuleCall getDivisionParserRuleCall_0() { return cDivisionParserRuleCall_0; }
		
		//({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }
		
		//operation='*'
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//'*'
		public Keyword getOperationAsteriskKeyword_1_1_0() { return cOperationAsteriskKeyword_1_1_0; }
		
		//right=Division
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Division
		public RuleCall getRightDivisionParserRuleCall_1_2_0() { return cRightDivisionParserRuleCall_1_2_0; }
	}
	public class DivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Division");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModuloParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivisionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationSolidusKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModuloParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Division returns Expression:
		//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Modulo ({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup() { return cGroup; }
		
		//Modulo
		public RuleCall getModuloParserRuleCall_0() { return cModuloParserRuleCall_0; }
		
		//({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Division.left=current}
		public Action getDivisionLeftAction_1_0() { return cDivisionLeftAction_1_0; }
		
		//opretation='/'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'/'
		public Keyword getOpretationSolidusKeyword_1_1_0() { return cOpretationSolidusKeyword_1_1_0; }
		
		//right=Modulo
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Modulo
		public RuleCall getRightModuloParserRuleCall_1_2_0() { return cRightModuloParserRuleCall_1_2_0; }
	}
	public class ModuloElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Modulo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModuloLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationPercentSignKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Modulo returns Expression:
		//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Addition ({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup() { return cGroup; }
		
		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }
		
		//({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Modulo.left=current}
		public Action getModuloLeftAction_1_0() { return cModuloLeftAction_1_0; }
		
		//opretation='%'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'%'
		public Keyword getOpretationPercentSignKeyword_1_1_0() { return cOpretationPercentSignKeyword_1_1_0; }
		
		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}
	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubstractionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSubstractionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns Expression:
		//  Substraction ({Addition.left=current} '+' right=Substraction)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Substraction ({Addition.left=current} '+' right=Substraction)*
		public Group getGroup() { return cGroup; }
		
		//Substraction
		public RuleCall getSubstractionParserRuleCall_0() { return cSubstractionParserRuleCall_0; }
		
		//({Addition.left=current} '+' right=Substraction)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0() { return cAdditionLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Substraction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Substraction
		public RuleCall getRightSubstractionParserRuleCall_1_2_0() { return cRightSubstractionParserRuleCall_1_2_0; }
	}
	public class SubstractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Substraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLeftShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSubstractionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightLeftShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Substraction returns Expression:
		//  LeftShift ({Substraction.left=current} '-' right=LeftShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LeftShift ({Substraction.left=current} '-' right=LeftShift)*
		public Group getGroup() { return cGroup; }
		
		//LeftShift
		public RuleCall getLeftShiftParserRuleCall_0() { return cLeftShiftParserRuleCall_0; }
		
		//({Substraction.left=current} '-' right=LeftShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Substraction.left=current}
		public Action getSubstractionLeftAction_1_0() { return cSubstractionLeftAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=LeftShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//LeftShift
		public RuleCall getRightLeftShiftParserRuleCall_1_2_0() { return cRightLeftShiftParserRuleCall_1_2_0; }
	}
	public class LeftShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LeftShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRigthShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLeftShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRigthShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//LeftShift returns Expression:
		//    RigthShift ({LeftShift.left=current} '<<' right=RigthShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//RigthShift ({LeftShift.left=current} '<<' right=RigthShift)*
		public Group getGroup() { return cGroup; }
		
		//RigthShift
		public RuleCall getRigthShiftParserRuleCall_0() { return cRigthShiftParserRuleCall_0; }
		
		//({LeftShift.left=current} '<<' right=RigthShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{LeftShift.left=current}
		public Action getLeftShiftLeftAction_1_0() { return cLeftShiftLeftAction_1_0; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_1_1() { return cLessThanSignLessThanSignKeyword_1_1; }
		
		//right=RigthShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RigthShift
		public RuleCall getRightRigthShiftParserRuleCall_1_2_0() { return cRightRigthShiftParserRuleCall_1_2_0; }
	}
	public class RigthShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RigthShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegateParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRigthShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNegateAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNegatePrimaryParserRuleCall_1_2_0 = (RuleCall)cNegateAssignment_1_2.eContents().get(0);
		
		//RigthShift returns Expression:
		//    Negate ({RigthShift.left=current} '>>' Negate=Primary)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Negate ({RigthShift.left=current} '>>' Negate=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Negate
		public RuleCall getNegateParserRuleCall_0() { return cNegateParserRuleCall_0; }
		
		//({RigthShift.left=current} '>>' Negate=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{RigthShift.left=current}
		public Action getRigthShiftLeftAction_1_0() { return cRigthShiftLeftAction_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_1_1() { return cGreaterThanSignGreaterThanSignKeyword_1_1; }
		
		//Negate=Primary
		public Assignment getNegateAssignment_1_2() { return cNegateAssignment_1_2; }
		
		//Primary
		public RuleCall getNegatePrimaryParserRuleCall_1_2_0() { return cNegatePrimaryParserRuleCall_1_2_0; }
	}
	public class NegateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Negate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNegateLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cTildeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Negate returns Expression:
		//    And ({Negate.left=current} '~' right=And)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Negate.left=current} '~' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Negate.left=current} '~' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Negate.left=current}
		public Action getNegateLeftAction_1_0() { return cNegateLeftAction_1_0; }
		
		//'~'
		public Keyword getTildeKeyword_1_1() { return cTildeKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And returns Expression:
		//    Or ({And.left=current} '&&' right=Or)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({And.left=current} '&&' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({And.left=current} '&&' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or returns Expression:
		//    Xor ({Or.left=current} '||' right=Xor)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({Or.left=current} '||' right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({Or.left=current} '||' right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor returns Expression:
		//    Primary ({Or.left=current} '^' right=Primary)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Or.left=current} '^' right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Or.left=current} '^' right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueDecimalValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueHexaDecimalValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueOctalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueBinaryValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cValueCharacterValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Assignment cValueAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cValueIdentifierValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cLeftParenthesisKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final RuleCall cMultiplicationParserRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		
		//Primary returns Expression:
		//            value=DecimalValue
		//      |    value=HexaDecimalValue
		//      |    value=OctalValue
		//      |   value=BinaryValue
		//      |   value=CharacterValue
		//       |    value=IdentifierValue
		//      |  '(' Multiplication ')'
		// ;
		@Override public ParserRule getRule() { return rule; }
		
		//      value=DecimalValue
		//|    value=HexaDecimalValue
		//|    value=OctalValue
		//|   value=BinaryValue
		//|   value=CharacterValue
		// |    value=IdentifierValue
		//|  '(' Multiplication ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=DecimalValue
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DecimalValue
		public RuleCall getValueDecimalValueParserRuleCall_0_0() { return cValueDecimalValueParserRuleCall_0_0; }
		
		//value=HexaDecimalValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HexaDecimalValue
		public RuleCall getValueHexaDecimalValueParserRuleCall_1_0() { return cValueHexaDecimalValueParserRuleCall_1_0; }
		
		//value=OctalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//OctalValue
		public RuleCall getValueOctalValueParserRuleCall_2_0() { return cValueOctalValueParserRuleCall_2_0; }
		
		//value=BinaryValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BinaryValue
		public RuleCall getValueBinaryValueParserRuleCall_3_0() { return cValueBinaryValueParserRuleCall_3_0; }
		
		//value=CharacterValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//CharacterValue
		public RuleCall getValueCharacterValueParserRuleCall_4_0() { return cValueCharacterValueParserRuleCall_4_0; }
		
		//value=IdentifierValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//IdentifierValue
		public RuleCall getValueIdentifierValueParserRuleCall_5_0() { return cValueIdentifierValueParserRuleCall_5_0; }
		
		//'(' Multiplication ')'
		public Group getGroup_6() { return cGroup_6; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6_0() { return cLeftParenthesisKeyword_6_0; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_6_1() { return cMultiplicationParserRuleCall_6_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6_2() { return cRightParenthesisKeyword_6_2; }
	}
	public class IdentifierValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IdentifierValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IdentifierValue:
		//    value = ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = ID
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//ID
		public RuleCall getValueIDTerminalRuleCall_0() { return cValueIDTerminalRuleCall_0; }
	}
	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.StringValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringValue:
		//    value = STRING
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class DecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DecimalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DecimalValue:
		//    value = INT
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class HexaDecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HexaDecimalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueHEXATerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//HexaDecimalValue:
		//    value = HEXA
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = HEXA
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//HEXA
		public RuleCall getValueHEXATerminalRuleCall_0() { return cValueHEXATerminalRuleCall_0; }
	}
	public class OctalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OctalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueOCTALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//OctalValue:
		//    value = OCTAL
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = OCTAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//OCTAL
		public RuleCall getValueOCTALTerminalRuleCall_0() { return cValueOCTALTerminalRuleCall_0; }
	}
	public class BinaryValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BinaryValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBINARYTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BinaryValue:
		//    value = BINARY
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = BINARY
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BINARY
		public RuleCall getValueBINARYTerminalRuleCall_0() { return cValueBINARYTerminalRuleCall_0; }
	}
	public class CharacterValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CharacterValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueCHARACTERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//CharacterValue:
		//    value = CHARACTER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = CHARACTER
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//CHARACTER
		public RuleCall getValueCHARACTERTerminalRuleCall_0() { return cValueCHARACTERTerminalRuleCall_0; }
	}
	public class EndOfLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EndOfLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCRTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEND_OF_FILETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EndOfLine: CR | END_OF_FILE;
		@Override public ParserRule getRule() { return rule; }
		
		//CR | END_OF_FILE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CR
		public RuleCall getCRTerminalRuleCall_0() { return cCRTerminalRuleCall_0; }
		
		//END_OF_FILE
		public RuleCall getEND_OF_FILETerminalRuleCall_1() { return cEND_OF_FILETerminalRuleCall_1; }
	}
	
	
	private final ModelElements pModel;
	private final SourceLineElements pSourceLine;
	private final BlankLineElements pBlankLine;
	private final CommentLineElements pCommentLine;
	private final DirectiveLineElements pDirectiveLine;
	private final EquDirectiveElements pEquDirective;
	private final OperandElements pOperand;
	private final MultiplicationElements pMultiplication;
	private final DivisionElements pDivision;
	private final ModuloElements pModulo;
	private final AdditionElements pAddition;
	private final SubstractionElements pSubstraction;
	private final LeftShiftElements pLeftShift;
	private final RigthShiftElements pRigthShift;
	private final NegateElements pNegate;
	private final AndElements pAnd;
	private final OrElements pOr;
	private final XorElements pXor;
	private final PrimaryElements pPrimary;
	private final IdentifierValueElements pIdentifierValue;
	private final StringValueElements pStringValue;
	private final DecimalValueElements pDecimalValue;
	private final HexaDecimalValueElements pHexaDecimalValue;
	private final OctalValueElements pOctalValue;
	private final BinaryValueElements pBinaryValue;
	private final CharacterValueElements pCharacterValue;
	private final TerminalRule tID;
	private final TerminalRule tHEXA;
	private final TerminalRule tBINARY;
	private final TerminalRule tOCTAL;
	private final TerminalRule tCHARACTER;
	private final TerminalRule tINT;
	private final EndOfLineElements pEndOfLine;
	private final TerminalRule tSTRING;
	private final TerminalRule tANY_EXCEPT_COMMENT_END_OF_LINE;
	private final TerminalRule tWS;
	private final TerminalRule tCR;
	private final TerminalRule tEND_OF_FILE;
	
	private final Grammar grammar;

	@Inject
	public AssemblerGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pSourceLine = new SourceLineElements();
		this.pBlankLine = new BlankLineElements();
		this.pCommentLine = new CommentLineElements();
		this.pDirectiveLine = new DirectiveLineElements();
		this.pEquDirective = new EquDirectiveElements();
		this.pOperand = new OperandElements();
		this.pMultiplication = new MultiplicationElements();
		this.pDivision = new DivisionElements();
		this.pModulo = new ModuloElements();
		this.pAddition = new AdditionElements();
		this.pSubstraction = new SubstractionElements();
		this.pLeftShift = new LeftShiftElements();
		this.pRigthShift = new RigthShiftElements();
		this.pNegate = new NegateElements();
		this.pAnd = new AndElements();
		this.pOr = new OrElements();
		this.pXor = new XorElements();
		this.pPrimary = new PrimaryElements();
		this.pIdentifierValue = new IdentifierValueElements();
		this.pStringValue = new StringValueElements();
		this.pDecimalValue = new DecimalValueElements();
		this.pHexaDecimalValue = new HexaDecimalValueElements();
		this.pOctalValue = new OctalValueElements();
		this.pBinaryValue = new BinaryValueElements();
		this.pCharacterValue = new CharacterValueElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ID");
		this.tHEXA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HEXA");
		this.tBINARY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BINARY");
		this.tOCTAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OCTAL");
		this.tCHARACTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CHARACTER");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.INT");
		this.pEndOfLine = new EndOfLineElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.STRING");
		this.tANY_EXCEPT_COMMENT_END_OF_LINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ANY_EXCEPT_COMMENT_END_OF_LINE");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.WS");
		this.tCR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CR");
		this.tEND_OF_FILE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.END_OF_FILE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.bpy.electronics.mc6809.assembler.Assembler".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	///*
	// * Entry point of an as9 file
	// */
	//Model:
	//    sourceLines += SourceLine*
	//;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///*
	// * Description of an assembler line.
	// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
	// */
	//SourceLine:
	//    (
	//          (lineContent = BlankLine)
	//        | (lineContent = CommentLine)
	//        | (lineContent = DirectiveLine)
	//    )
	//;
	public SourceLineElements getSourceLineAccess() {
		return pSourceLine;
	}
	
	public ParserRule getSourceLineRule() {
		return getSourceLineAccess().getRule();
	}
	
	///*
	// * Blanck line is an empty line or a set of space or tabs followed by a end of line
	// */
	//BlankLine:
	//    {BlankLine} (blankLine = WS)? EndOfLine
	//;
	public BlankLineElements getBlankLineAccess() {
		return pBlankLine;
	}
	
	public ParserRule getBlankLineRule() {
		return getBlankLineAccess().getRule();
	}
	
	///*
	// * definition of a comment line
	// * A comment line start with a ; following by anything and finish with a end of line
	// */
	//CommentLine:
	//    comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
	//;
	public CommentLineElements getCommentLineAccess() {
		return pCommentLine;
	}
	
	public ParserRule getCommentLineRule() {
		return getCommentLineAccess().getRule();
	}
	
	///*
	// * Definition of the list possible directives
	// *     EQU
	// */
	//DirectiveLine:
	//    directive = EquDirective
	//;
	public DirectiveLineElements getDirectiveLineAccess() {
		return pDirectiveLine;
	}
	
	public ParserRule getDirectiveLineRule() {
		return getDirectiveLineAccess().getRule();
	}
	
	///*
	// * Description of an EQU directive
	// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
	// */
	//EquDirective:
	//    (name = IdentifierValue)? WS (directive = 'EQU') WS (operand = Operand)? WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? EndOfLine
	//;
	public EquDirectiveElements getEquDirectiveAccess() {
		return pEquDirective;
	}
	
	public ParserRule getEquDirectiveRule() {
		return getEquDirectiveAccess().getRule();
	}
	
	//Operand:
	//        (operand = Multiplication)
	//    |     (operand = StringValue)
	//;
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}
	
	//Multiplication returns Expression:
	//      Division ({Multiplication.left=current} operation='*' right=Division)*
	//;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	//Division returns Expression:
	//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
	//;
	public DivisionElements getDivisionAccess() {
		return pDivision;
	}
	
	public ParserRule getDivisionRule() {
		return getDivisionAccess().getRule();
	}
	
	//Modulo returns Expression:
	//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
	//;
	public ModuloElements getModuloAccess() {
		return pModulo;
	}
	
	public ParserRule getModuloRule() {
		return getModuloAccess().getRule();
	}
	
	//Addition returns Expression:
	//  Substraction ({Addition.left=current} '+' right=Substraction)*
	//;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}
	
	//Substraction returns Expression:
	//  LeftShift ({Substraction.left=current} '-' right=LeftShift)*
	//;
	public SubstractionElements getSubstractionAccess() {
		return pSubstraction;
	}
	
	public ParserRule getSubstractionRule() {
		return getSubstractionAccess().getRule();
	}
	
	//LeftShift returns Expression:
	//    RigthShift ({LeftShift.left=current} '<<' right=RigthShift)*
	//;
	public LeftShiftElements getLeftShiftAccess() {
		return pLeftShift;
	}
	
	public ParserRule getLeftShiftRule() {
		return getLeftShiftAccess().getRule();
	}
	
	//RigthShift returns Expression:
	//    Negate ({RigthShift.left=current} '>>' Negate=Primary)*
	//;
	public RigthShiftElements getRigthShiftAccess() {
		return pRigthShift;
	}
	
	public ParserRule getRigthShiftRule() {
		return getRigthShiftAccess().getRule();
	}
	
	//Negate returns Expression:
	//    And ({Negate.left=current} '~' right=And)*
	//;
	public NegateElements getNegateAccess() {
		return pNegate;
	}
	
	public ParserRule getNegateRule() {
		return getNegateAccess().getRule();
	}
	
	//And returns Expression:
	//    Or ({And.left=current} '&&' right=Or)*
	//;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Or returns Expression:
	//    Xor ({Or.left=current} '||' right=Xor)*
	//;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//Xor returns Expression:
	//    Primary ({Or.left=current} '^' right=Primary)*
	//;
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Primary returns Expression:
	//            value=DecimalValue
	//      |    value=HexaDecimalValue
	//      |    value=OctalValue
	//      |   value=BinaryValue
	//      |   value=CharacterValue
	//       |    value=IdentifierValue
	//      |  '(' Multiplication ')'
	// ;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//IdentifierValue:
	//    value = ID
	//;
	public IdentifierValueElements getIdentifierValueAccess() {
		return pIdentifierValue;
	}
	
	public ParserRule getIdentifierValueRule() {
		return getIdentifierValueAccess().getRule();
	}
	
	//StringValue:
	//    value = STRING
	//;
	public StringValueElements getStringValueAccess() {
		return pStringValue;
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}
	
	//DecimalValue:
	//    value = INT
	//;
	public DecimalValueElements getDecimalValueAccess() {
		return pDecimalValue;
	}
	
	public ParserRule getDecimalValueRule() {
		return getDecimalValueAccess().getRule();
	}
	
	//HexaDecimalValue:
	//    value = HEXA
	//;
	public HexaDecimalValueElements getHexaDecimalValueAccess() {
		return pHexaDecimalValue;
	}
	
	public ParserRule getHexaDecimalValueRule() {
		return getHexaDecimalValueAccess().getRule();
	}
	
	//OctalValue:
	//    value = OCTAL
	//;
	public OctalValueElements getOctalValueAccess() {
		return pOctalValue;
	}
	
	public ParserRule getOctalValueRule() {
		return getOctalValueAccess().getRule();
	}
	
	//BinaryValue:
	//    value = BINARY
	//;
	public BinaryValueElements getBinaryValueAccess() {
		return pBinaryValue;
	}
	
	public ParserRule getBinaryValueRule() {
		return getBinaryValueAccess().getRule();
	}
	
	//CharacterValue:
	//    value = CHARACTER
	//;
	public CharacterValueElements getCharacterValueAccess() {
		return pCharacterValue;
	}
	
	public ParserRule getCharacterValueRule() {
		return getCharacterValueAccess().getRule();
	}
	
	//terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
	public TerminalRule getHEXARule() {
		return tHEXA;
	}
	
	//terminal BINARY 							: '%' ('0'..'1')+;
	public TerminalRule getBINARYRule() {
		return tBINARY;
	}
	
	//terminal OCTAL 								: '@' ('0'..'7')+;
	public TerminalRule getOCTALRule() {
		return tOCTAL;
	}
	
	//terminal CHARACTER							: '\'' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') ) '\'';
	public TerminalRule getCHARACTERRule() {
		return tCHARACTER;
	}
	
	//terminal INT returns ecore::EInt			: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//EndOfLine: CR | END_OF_FILE;
	public EndOfLineElements getEndOfLineAccess() {
		return pEndOfLine;
	}
	
	public ParserRule getEndOfLineRule() {
		return getEndOfLineAccess().getRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
	public TerminalRule getANY_EXCEPT_COMMENT_END_OF_LINERule() {
		return tANY_EXCEPT_COMMENT_END_OF_LINE;
	}
	
	//terminal WS         						: (' '|'\t')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal CR          						: '\r'? '\n';
	public TerminalRule getCRRule() {
		return tCR;
	}
	
	//terminal END_OF_FILE 						: EOF;
	public TerminalRule getEND_OF_FILERule() {
		return tEND_OF_FILE;
	}
}

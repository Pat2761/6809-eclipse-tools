/*
 * generated by Xtext 2.28.0
 */
package org.bpy.electronics.mc6809.assembler.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class AssemblerGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Model");
		private final Assignment cSourceLinesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSourceLinesSourceLineParserRuleCall_0 = (RuleCall)cSourceLinesAssignment.eContents().get(0);
		
		///*
		// * Entry point of an as9 file
		// */
		//Model:
		//    sourceLines += SourceLine*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sourceLines += SourceLine*
		public Assignment getSourceLinesAssignment() { return cSourceLinesAssignment; }
		
		//SourceLine
		public RuleCall getSourceLinesSourceLineParserRuleCall_0() { return cSourceLinesSourceLineParserRuleCall_0; }
	}
	public class SourceLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SourceLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLineContentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cLineContentBlankLineParserRuleCall_0_0 = (RuleCall)cLineContentAssignment_0.eContents().get(0);
		private final Assignment cLineContentAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLineContentCommentLineParserRuleCall_1_0 = (RuleCall)cLineContentAssignment_1.eContents().get(0);
		private final Assignment cLineContentAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cLineContentDirectiveLineParserRuleCall_2_0 = (RuleCall)cLineContentAssignment_2.eContents().get(0);
		private final Assignment cLineContentAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cLineContentInstructionLineParserRuleCall_3_0 = (RuleCall)cLineContentAssignment_3.eContents().get(0);
		
		///*
		// * Description of an assembler line.
		// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
		// */
		//SourceLine:
		//    (
		//          (lineContent = BlankLine)
		//        | (lineContent = CommentLine)
		//        | (lineContent = DirectiveLine)
		//        | (lineContent = InstructionLine)
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//      (lineContent = BlankLine)
		//    | (lineContent = CommentLine)
		//    | (lineContent = DirectiveLine)
		//    | (lineContent = InstructionLine)
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(lineContent = BlankLine)
		public Assignment getLineContentAssignment_0() { return cLineContentAssignment_0; }
		
		//BlankLine
		public RuleCall getLineContentBlankLineParserRuleCall_0_0() { return cLineContentBlankLineParserRuleCall_0_0; }
		
		//(lineContent = CommentLine)
		public Assignment getLineContentAssignment_1() { return cLineContentAssignment_1; }
		
		//CommentLine
		public RuleCall getLineContentCommentLineParserRuleCall_1_0() { return cLineContentCommentLineParserRuleCall_1_0; }
		
		//(lineContent = DirectiveLine)
		public Assignment getLineContentAssignment_2() { return cLineContentAssignment_2; }
		
		//DirectiveLine
		public RuleCall getLineContentDirectiveLineParserRuleCall_2_0() { return cLineContentDirectiveLineParserRuleCall_2_0; }
		
		//(lineContent = InstructionLine)
		public Assignment getLineContentAssignment_3() { return cLineContentAssignment_3; }
		
		//InstructionLine
		public RuleCall getLineContentInstructionLineParserRuleCall_3_0() { return cLineContentInstructionLineParserRuleCall_3_0; }
	}
	public class BlankLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BlankLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlankLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBlankLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlankLineWSTerminalRuleCall_1_0 = (RuleCall)cBlankLineAssignment_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		///*
		// * Blanck line is an empty line or a set of space or tabs followed by a end of line
		// */
		//BlankLine:
		//    {BlankLine} (blankLine = WS)? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{BlankLine} (blankLine = WS)? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//{BlankLine}
		public Action getBlankLineAction_0() { return cBlankLineAction_0; }
		
		//(blankLine = WS)?
		public Assignment getBlankLineAssignment_1() { return cBlankLineAssignment_1; }
		
		//WS
		public RuleCall getBlankLineWSTerminalRuleCall_1_0() { return cBlankLineWSTerminalRuleCall_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_2() { return cEndOfLineParserRuleCall_2; }
	}
	public class CommentLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CommentLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCommentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0 = (RuleCall)cCommentAssignment_0.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		///*
		// * definition of a comment line
		// * A comment line start with a ; following by anything and finish with a end of line
		// */
		//CommentLine:
		//    comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
		public Group getGroup() { return cGroup; }
		
		//comment = ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_0() { return cCommentAssignment_0; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_0_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_1() { return cEndOfLineParserRuleCall_1; }
	}
	public class InstructionLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.InstructionLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstructionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cInstructionAbxInstructionParserRuleCall_0_0 = (RuleCall)cInstructionAssignment_0.eContents().get(0);
		private final Assignment cInstructionAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cInstructionAdcInstructionParserRuleCall_1_0 = (RuleCall)cInstructionAssignment_1.eContents().get(0);
		private final Assignment cInstructionAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cInstructionAddInstructionParserRuleCall_2_0 = (RuleCall)cInstructionAssignment_2.eContents().get(0);
		private final Assignment cInstructionAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cInstructionAdddInstructionParserRuleCall_3_0 = (RuleCall)cInstructionAssignment_3.eContents().get(0);
		private final Assignment cInstructionAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cInstructionAndInstructionParserRuleCall_4_0 = (RuleCall)cInstructionAssignment_4.eContents().get(0);
		private final Assignment cInstructionAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cInstructionAndCCInstructionParserRuleCall_5_0 = (RuleCall)cInstructionAssignment_5.eContents().get(0);
		private final Assignment cInstructionAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cInstructionAslInstructionParserRuleCall_6_0 = (RuleCall)cInstructionAssignment_6.eContents().get(0);
		private final Assignment cInstructionAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cInstructionAsrInstructionParserRuleCall_7_0 = (RuleCall)cInstructionAssignment_7.eContents().get(0);
		
		///*
		// * Definition of the list possible instructions
		// */
		//InstructionLine:
		//    instruction = AbxInstruction            |
		//    instruction = AdcInstruction            |
		//    instruction = AddInstruction            |
		//    instruction = AdddInstruction           |
		//    instruction = AndInstruction            |
		//    instruction = AndCCInstruction          |
		//    instruction = AslInstruction            |
		//    instruction = AsrInstruction
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//instruction = AbxInstruction            |
		//instruction = AdcInstruction            |
		//instruction = AddInstruction            |
		//instruction = AdddInstruction           |
		//instruction = AndInstruction            |
		//instruction = AndCCInstruction          |
		//instruction = AslInstruction            |
		//instruction = AsrInstruction
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//instruction = AbxInstruction
		public Assignment getInstructionAssignment_0() { return cInstructionAssignment_0; }
		
		//AbxInstruction
		public RuleCall getInstructionAbxInstructionParserRuleCall_0_0() { return cInstructionAbxInstructionParserRuleCall_0_0; }
		
		//instruction = AdcInstruction
		public Assignment getInstructionAssignment_1() { return cInstructionAssignment_1; }
		
		//AdcInstruction
		public RuleCall getInstructionAdcInstructionParserRuleCall_1_0() { return cInstructionAdcInstructionParserRuleCall_1_0; }
		
		//instruction = AddInstruction
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//AddInstruction
		public RuleCall getInstructionAddInstructionParserRuleCall_2_0() { return cInstructionAddInstructionParserRuleCall_2_0; }
		
		//instruction = AdddInstruction
		public Assignment getInstructionAssignment_3() { return cInstructionAssignment_3; }
		
		//AdddInstruction
		public RuleCall getInstructionAdddInstructionParserRuleCall_3_0() { return cInstructionAdddInstructionParserRuleCall_3_0; }
		
		//instruction = AndInstruction
		public Assignment getInstructionAssignment_4() { return cInstructionAssignment_4; }
		
		//AndInstruction
		public RuleCall getInstructionAndInstructionParserRuleCall_4_0() { return cInstructionAndInstructionParserRuleCall_4_0; }
		
		//instruction = AndCCInstruction
		public Assignment getInstructionAssignment_5() { return cInstructionAssignment_5; }
		
		//AndCCInstruction
		public RuleCall getInstructionAndCCInstructionParserRuleCall_5_0() { return cInstructionAndCCInstructionParserRuleCall_5_0; }
		
		//instruction = AslInstruction
		public Assignment getInstructionAssignment_6() { return cInstructionAssignment_6; }
		
		//AslInstruction
		public RuleCall getInstructionAslInstructionParserRuleCall_6_0() { return cInstructionAslInstructionParserRuleCall_6_0; }
		
		//instruction = AsrInstruction
		public Assignment getInstructionAssignment_7() { return cInstructionAssignment_7; }
		
		//AsrInstruction
		public RuleCall getInstructionAsrInstructionParserRuleCall_7_0() { return cInstructionAsrInstructionParserRuleCall_7_0; }
	}
	public class AsrInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AsrInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cInstructionAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Alternatives cInstructionAlternatives_2_0_0 = (Alternatives)cInstructionAssignment_2_0.eContents().get(0);
		private final Keyword cInstructionASRAKeyword_2_0_0_0 = (Keyword)cInstructionAlternatives_2_0_0.eContents().get(0);
		private final Keyword cInstructionASRBKeyword_2_0_0_1 = (Keyword)cInstructionAlternatives_2_0_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cInstructionAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Keyword cInstructionASRKeyword_2_1_0_0 = (Keyword)cInstructionAssignment_2_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Assignment cOperandAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_1_2_0 = (Alternatives)cOperandAssignment_2_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_1_2_0_0 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_1_2_0_1 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_1_2_0_2 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(3);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * ASR
		// *
		// * Arithmetic Shift Right
		// * Source Form        : ASR Q, ASLA; ASLB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Not affected
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
		// * Addressing Mode    : Inherent
		// *                       Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AsrInstruction:
		//    (name = IdentifierValue)? WS
		//       (
		//               (
		//                   instruction = ('ASRA' | 'ASRB')
		//               )
		//            |
		//               (
		//                     instruction = ('ASR')
		//                WS operand = (
		//                    DirectOperand  |
		//                    IndexedOperand |
		//                    ExtendedOperand |
		//                    ExtendedIndirectOperand
		//                )
		//               )
		//       )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS
		//   (
		//           (
		//               instruction = ('ASRA' | 'ASRB')
		//           )
		//        |
		//           (
		//                 instruction = ('ASR')
		//            WS operand = (
		//                DirectOperand  |
		//                IndexedOperand |
		//                ExtendedOperand |
		//                ExtendedIndirectOperand
		//            )
		//           )
		//   )
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//        (
		//            instruction = ('ASRA' | 'ASRB')
		//        )
		//     |
		//        (
		//              instruction = ('ASR')
		//         WS operand = (
		//             DirectOperand  |
		//             IndexedOperand |
		//             ExtendedOperand |
		//             ExtendedIndirectOperand
		//         )
		//        )
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(
		//    instruction = ('ASRA' | 'ASRB')
		//)
		public Assignment getInstructionAssignment_2_0() { return cInstructionAssignment_2_0; }
		
		//('ASRA' | 'ASRB')
		public Alternatives getInstructionAlternatives_2_0_0() { return cInstructionAlternatives_2_0_0; }
		
		//'ASRA'
		public Keyword getInstructionASRAKeyword_2_0_0_0() { return cInstructionASRAKeyword_2_0_0_0; }
		
		//'ASRB'
		public Keyword getInstructionASRBKeyword_2_0_0_1() { return cInstructionASRBKeyword_2_0_0_1; }
		
		//(
		//      instruction = ('ASR')
		// WS operand = (
		//     DirectOperand  |
		//     IndexedOperand |
		//     ExtendedOperand |
		//     ExtendedIndirectOperand
		// )
		//)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//instruction = ('ASR')
		public Assignment getInstructionAssignment_2_1_0() { return cInstructionAssignment_2_1_0; }
		
		//('ASR')
		public Keyword getInstructionASRKeyword_2_1_0_0() { return cInstructionASRKeyword_2_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_2_1_1() { return cWSTerminalRuleCall_2_1_1; }
		
		//operand = (
		//                   DirectOperand  |
		//                   IndexedOperand |
		//                   ExtendedOperand |
		//                   ExtendedIndirectOperand
		//               )
		public Assignment getOperandAssignment_2_1_2() { return cOperandAssignment_2_1_2; }
		
		//(
		//                   DirectOperand  |
		//                   IndexedOperand |
		//                   ExtendedOperand |
		//                   ExtendedIndirectOperand
		//               )
		public Alternatives getOperandAlternatives_2_1_2_0() { return cOperandAlternatives_2_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_1_2_0_0() { return cOperandDirectOperandParserRuleCall_2_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class AslInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AslInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cInstructionAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Alternatives cInstructionAlternatives_2_0_0 = (Alternatives)cInstructionAssignment_2_0.eContents().get(0);
		private final Keyword cInstructionASLAKeyword_2_0_0_0 = (Keyword)cInstructionAlternatives_2_0_0.eContents().get(0);
		private final Keyword cInstructionASLBKeyword_2_0_0_1 = (Keyword)cInstructionAlternatives_2_0_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cInstructionAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Keyword cInstructionASLKeyword_2_1_0_0 = (Keyword)cInstructionAssignment_2_1_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Assignment cOperandAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final Alternatives cOperandAlternatives_2_1_2_0 = (Alternatives)cOperandAssignment_2_1_2.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_2_1_2_0_0 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(0);
		private final RuleCall cOperandIndexedOperandParserRuleCall_2_1_2_0_1 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(1);
		private final RuleCall cOperandExtendedOperandParserRuleCall_2_1_2_0_2 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(2);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3 = (RuleCall)cOperandAlternatives_2_1_2_0.eContents().get(3);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * ASL
		// *
		// * Arithmetic Shift Left
		// * Source Form        : ASL Q, ASLA; ASLB
		// * Operation        :
		// * Condition Codes    : H - Undefined
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
		// *                       C - Loaded with bit seven of the original operand.
		// * Description        : Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is
		// *                    shifted into the C (carry) bit.
		// * Addressing Mode    : Inherent
		// */
		//AslInstruction:
		//    (name = IdentifierValue)? WS
		//       (
		//               (
		//                   instruction = ('ASLA' | 'ASLB')
		//               )
		//            |
		//               (
		//                     instruction = ('ASL')
		//                WS operand = (
		//                    DirectOperand  |
		//                    IndexedOperand |
		//                    ExtendedOperand |
		//                    ExtendedIndirectOperand
		//                )
		//               )
		//       )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS
		//   (
		//           (
		//               instruction = ('ASLA' | 'ASLB')
		//           )
		//        |
		//           (
		//                 instruction = ('ASL')
		//            WS operand = (
		//                DirectOperand  |
		//                IndexedOperand |
		//                ExtendedOperand |
		//                ExtendedIndirectOperand
		//            )
		//           )
		//   )
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(
		//        (
		//            instruction = ('ASLA' | 'ASLB')
		//        )
		//     |
		//        (
		//              instruction = ('ASL')
		//         WS operand = (
		//             DirectOperand  |
		//             IndexedOperand |
		//             ExtendedOperand |
		//             ExtendedIndirectOperand
		//         )
		//        )
		//)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(
		//    instruction = ('ASLA' | 'ASLB')
		//)
		public Assignment getInstructionAssignment_2_0() { return cInstructionAssignment_2_0; }
		
		//('ASLA' | 'ASLB')
		public Alternatives getInstructionAlternatives_2_0_0() { return cInstructionAlternatives_2_0_0; }
		
		//'ASLA'
		public Keyword getInstructionASLAKeyword_2_0_0_0() { return cInstructionASLAKeyword_2_0_0_0; }
		
		//'ASLB'
		public Keyword getInstructionASLBKeyword_2_0_0_1() { return cInstructionASLBKeyword_2_0_0_1; }
		
		//(
		//      instruction = ('ASL')
		// WS operand = (
		//     DirectOperand  |
		//     IndexedOperand |
		//     ExtendedOperand |
		//     ExtendedIndirectOperand
		// )
		//)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//instruction = ('ASL')
		public Assignment getInstructionAssignment_2_1_0() { return cInstructionAssignment_2_1_0; }
		
		//('ASL')
		public Keyword getInstructionASLKeyword_2_1_0_0() { return cInstructionASLKeyword_2_1_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_2_1_1() { return cWSTerminalRuleCall_2_1_1; }
		
		//operand = (
		//                   DirectOperand  |
		//                   IndexedOperand |
		//                   ExtendedOperand |
		//                   ExtendedIndirectOperand
		//               )
		public Assignment getOperandAssignment_2_1_2() { return cOperandAssignment_2_1_2; }
		
		//(
		//                   DirectOperand  |
		//                   IndexedOperand |
		//                   ExtendedOperand |
		//                   ExtendedIndirectOperand
		//               )
		public Alternatives getOperandAlternatives_2_1_2_0() { return cOperandAlternatives_2_1_2_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_2_1_2_0_0() { return cOperandDirectOperandParserRuleCall_2_1_2_0_0; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_2_1_2_0_1() { return cOperandIndexedOperandParserRuleCall_2_1_2_0_1; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_2_1_2_0_2() { return cOperandExtendedOperandParserRuleCall_2_1_2_0_2; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3() { return cOperandExtendedIndirectOperandParserRuleCall_2_1_2_0_3; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class AndCCInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AndCCInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cInstructionANDCCKeyword_2_0 = (Keyword)cInstructionAssignment_2.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOperandImmediatOperandParserRuleCall_4_0 = (RuleCall)cOperandAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * ANDCC
		// *
		// * Logical AND Immediate Memory into Condition Code Register
		// * Source Form        : ANDOG #xx
		// * Operation        : R'— R A Ml
		// * Condition Codes    : Affected according to the operation.
		// * Description        : PPerforms a logical AND between the condition code register and the Immediate byte specified In
		// *                    the instruction and places the result in the condition code register.
		// * Addressing Mode    : Immediate
		// */
		//AndCCInstruction:
		//    (name = IdentifierValue)? WS (instruction = ('ANDCC'))
		//    WS operand = (
		//        ImmediatOperand
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = ('ANDCC'))
		//WS operand = (
		//    ImmediatOperand
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = ('ANDCC'))
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//('ANDCC')
		public Keyword getInstructionANDCCKeyword_2_0() { return cInstructionANDCCKeyword_2_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//operand = (
		//       ImmediatOperand
		//   )
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//(
		//       ImmediatOperand
		//   )
		public RuleCall getOperandImmediatOperandParserRuleCall_4_0() { return cOperandImmediatOperandParserRuleCall_4_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_6() { return cWSTerminalRuleCall_6; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class AndInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AndInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cInstructionAlternatives_2_0 = (Alternatives)cInstructionAssignment_2.eContents().get(0);
		private final Keyword cInstructionANDAKeyword_2_0_0 = (Keyword)cInstructionAlternatives_2_0.eContents().get(0);
		private final Keyword cInstructionANDBKeyword_2_0_1 = (Keyword)cInstructionAlternatives_2_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cOperandAlternatives_4_0 = (Alternatives)cOperandAssignment_4.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_4_0_0 = (RuleCall)cOperandAlternatives_4_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_4_0_1 = (RuleCall)cOperandAlternatives_4_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_4_0_2 = (RuleCall)cOperandAlternatives_4_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_4_0_3 = (RuleCall)cOperandAlternatives_4_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_4_0_4 = (RuleCall)cOperandAlternatives_4_0.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * AND
		// *
		// * Logical AND Memory into Register
		// * Source Form        : ANDA P; ANDB P
		// * Operation        : R'— RAM
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Always cleared.
		// *                       C - Not affected.
		// * Description        : Performs the logical AND operation between the contents of an accumulator and the contents
		// *                       of memory location M and the result is stored in the accumulator.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AndInstruction:
		//    (name = IdentifierValue)? WS (instruction = ('ANDA' | 'ANDB'))
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = ('ANDA' | 'ANDB'))
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = ('ANDA' | 'ANDB'))
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//('ANDA' | 'ANDB')
		public Alternatives getInstructionAlternatives_2_0() { return cInstructionAlternatives_2_0; }
		
		//'ANDA'
		public Keyword getInstructionANDAKeyword_2_0_0() { return cInstructionANDAKeyword_2_0_0; }
		
		//'ANDB'
		public Keyword getInstructionANDBKeyword_2_0_1() { return cInstructionANDBKeyword_2_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_4_0() { return cOperandAlternatives_4_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_4_0_0() { return cOperandImmediatOperandParserRuleCall_4_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_4_0_1() { return cOperandDirectOperandParserRuleCall_4_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_4_0_2() { return cOperandIndexedOperandParserRuleCall_4_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_4_0_3() { return cOperandExtendedOperandParserRuleCall_4_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_4_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_4_0_4; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_6() { return cWSTerminalRuleCall_6; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class AdddInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AdddInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cInstructionADDDKeyword_2_0 = (Keyword)cInstructionAssignment_2.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cOperandAlternatives_4_0 = (Alternatives)cOperandAssignment_4.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_4_0_0 = (RuleCall)cOperandAlternatives_4_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_4_0_1 = (RuleCall)cOperandAlternatives_4_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_4_0_2 = (RuleCall)cOperandAlternatives_4_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_4_0_3 = (RuleCall)cOperandAlternatives_4_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_4_0_4 = (RuleCall)cOperandAlternatives_4_0.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * ADDD
		// *
		// * Add Memory into Register
		// * Source Form        : ADDD P
		// * Operation        : R'— R + M:M + 1
		// * Condition Codes    : H - Not affected.
		// *                       N - Set if the result is negative; cleared otherwise.
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if an overflow is generated; cleared otherwise,
		// *                       C - Set if a carry is generated; cleared otherwise.
		// * Description        : Adds the 16-bit memory value into the 16-bit accumulator
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AdddInstruction:
		//    (name = IdentifierValue)? WS (instruction = ('ADDD'))
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = ('ADDD'))
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = ('ADDD'))
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//('ADDD')
		public Keyword getInstructionADDDKeyword_2_0() { return cInstructionADDDKeyword_2_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_4_0() { return cOperandAlternatives_4_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_4_0_0() { return cOperandImmediatOperandParserRuleCall_4_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_4_0_1() { return cOperandDirectOperandParserRuleCall_4_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_4_0_2() { return cOperandIndexedOperandParserRuleCall_4_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_4_0_3() { return cOperandExtendedOperandParserRuleCall_4_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_4_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_4_0_4; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_6() { return cWSTerminalRuleCall_6; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class AddInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AddInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cInstructionAlternatives_2_0 = (Alternatives)cInstructionAssignment_2.eContents().get(0);
		private final Keyword cInstructionADDAKeyword_2_0_0 = (Keyword)cInstructionAlternatives_2_0.eContents().get(0);
		private final Keyword cInstructionADDBKeyword_2_0_1 = (Keyword)cInstructionAlternatives_2_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cOperandAlternatives_4_0 = (Alternatives)cOperandAssignment_4.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_4_0_0 = (RuleCall)cOperandAlternatives_4_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_4_0_1 = (RuleCall)cOperandAlternatives_4_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_4_0_2 = (RuleCall)cOperandAlternatives_4_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_4_0_3 = (RuleCall)cOperandAlternatives_4_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_4_0_4 = (RuleCall)cOperandAlternatives_4_0.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * ADD
		// *
		// * Add Memory into Register
		// * Source Form        : ADDA P; ADDB P
		// * Operation        : R'— R + M
		// * Condition Codes    : H - Set if a half-carry is generated; cleared otherwise,
		// *                       N - Set if the result Is negative; cleared otherwise,
		// *                       Z - Set if the result Is zero; cleared otherwise,
		// *                    V - Set if an overflow is generated; cleared otherwise,
		// *                       C - Set if a carry is generated; cleared otherwise.
		// * Description        : Adds the memory byte into an 8-bit accumulator.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AddInstruction:
		//    (name = IdentifierValue)? WS (instruction = ('ADDA' | 'ADDB'))
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = ('ADDA' | 'ADDB'))
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = ('ADDA' | 'ADDB'))
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//('ADDA' | 'ADDB')
		public Alternatives getInstructionAlternatives_2_0() { return cInstructionAlternatives_2_0; }
		
		//'ADDA'
		public Keyword getInstructionADDAKeyword_2_0_0() { return cInstructionADDAKeyword_2_0_0; }
		
		//'ADDB'
		public Keyword getInstructionADDBKeyword_2_0_1() { return cInstructionADDBKeyword_2_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_4_0() { return cOperandAlternatives_4_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_4_0_0() { return cOperandImmediatOperandParserRuleCall_4_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_4_0_1() { return cOperandDirectOperandParserRuleCall_4_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_4_0_2() { return cOperandIndexedOperandParserRuleCall_4_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_4_0_3() { return cOperandExtendedOperandParserRuleCall_4_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_4_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_4_0_4; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_6() { return cWSTerminalRuleCall_6; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class AdcInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AdcInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cInstructionAlternatives_2_0 = (Alternatives)cInstructionAssignment_2.eContents().get(0);
		private final Keyword cInstructionADCAKeyword_2_0_0 = (Keyword)cInstructionAlternatives_2_0.eContents().get(0);
		private final Keyword cInstructionADCBKeyword_2_0_1 = (Keyword)cInstructionAlternatives_2_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cOperandAlternatives_4_0 = (Alternatives)cOperandAssignment_4.eContents().get(0);
		private final RuleCall cOperandImmediatOperandParserRuleCall_4_0_0 = (RuleCall)cOperandAlternatives_4_0.eContents().get(0);
		private final RuleCall cOperandDirectOperandParserRuleCall_4_0_1 = (RuleCall)cOperandAlternatives_4_0.eContents().get(1);
		private final RuleCall cOperandIndexedOperandParserRuleCall_4_0_2 = (RuleCall)cOperandAlternatives_4_0.eContents().get(2);
		private final RuleCall cOperandExtendedOperandParserRuleCall_4_0_3 = (RuleCall)cOperandAlternatives_4_0.eContents().get(3);
		private final RuleCall cOperandExtendedIndirectOperandParserRuleCall_4_0_4 = (RuleCall)cOperandAlternatives_4_0.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * ADC
		// *
		// * Add with Carry into Register
		// * Source Form        : ADCA P; ADCB P
		// * Operation        : R'*-R + M + C
		// * Condition Codes    : H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
		// *                       N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
		// *                       Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
		// *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
		// *                       C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
		// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
		// * Addressing Mode    : Immediate
		// *                    Extended
		// *                    Direct
		// *                    Indexed
		// */
		//AdcInstruction:
		//    (name = IdentifierValue)? WS (instruction = ('ADCA' | 'ADCB'))
		//    WS operand = (
		//        ImmediatOperand |
		//        DirectOperand  |
		//        IndexedOperand |
		//        ExtendedOperand |
		//        ExtendedIndirectOperand
		//    )
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = ('ADCA' | 'ADCB'))
		//WS operand = (
		//    ImmediatOperand |
		//    DirectOperand  |
		//    IndexedOperand |
		//    ExtendedOperand |
		//    ExtendedIndirectOperand
		//)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = ('ADCA' | 'ADCB'))
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//('ADCA' | 'ADCB')
		public Alternatives getInstructionAlternatives_2_0() { return cInstructionAlternatives_2_0; }
		
		//'ADCA'
		public Keyword getInstructionADCAKeyword_2_0_0() { return cInstructionADCAKeyword_2_0_0; }
		
		//'ADCB'
		public Keyword getInstructionADCBKeyword_2_0_1() { return cInstructionADCBKeyword_2_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//operand = (
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//(
		//       ImmediatOperand |
		//       DirectOperand  |
		//       IndexedOperand |
		//       ExtendedOperand |
		//       ExtendedIndirectOperand
		//   )
		public Alternatives getOperandAlternatives_4_0() { return cOperandAlternatives_4_0; }
		
		//ImmediatOperand
		public RuleCall getOperandImmediatOperandParserRuleCall_4_0_0() { return cOperandImmediatOperandParserRuleCall_4_0_0; }
		
		//DirectOperand
		public RuleCall getOperandDirectOperandParserRuleCall_4_0_1() { return cOperandDirectOperandParserRuleCall_4_0_1; }
		
		//IndexedOperand
		public RuleCall getOperandIndexedOperandParserRuleCall_4_0_2() { return cOperandIndexedOperandParserRuleCall_4_0_2; }
		
		//ExtendedOperand
		public RuleCall getOperandExtendedOperandParserRuleCall_4_0_3() { return cOperandExtendedOperandParserRuleCall_4_0_3; }
		
		//ExtendedIndirectOperand
		public RuleCall getOperandExtendedIndirectOperandParserRuleCall_4_0_4() { return cOperandExtendedIndirectOperandParserRuleCall_4_0_4; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_6() { return cWSTerminalRuleCall_6; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class AbxInstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AbxInstruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cInstructionABXKeyword_2_0 = (Keyword)cInstructionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * ABX
		// *
		// * Add Accumulator B into Index Register X
		// * Source Form        : ABX
		// * Operation        : IX'— IX + ACCB
		// * Condition Codes    : Not affected.
		// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
		// * Addressing Mode    : Inherent
		// */
		//AbxInstruction:
		//    (name = IdentifierValue)? WS (instruction = 'ABX')
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (instruction = 'ABX')
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(instruction = 'ABX')
		public Assignment getInstructionAssignment_2() { return cInstructionAssignment_2; }
		
		//'ABX'
		public Keyword getInstructionABXKeyword_2_0() { return cInstructionABXKeyword_2_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class ExtendedIndirectOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ExtendedIndirectOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///*
		// * Extended Indirect
		// *
		// * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to
		// * two bytes in memory which are used as the effective address.
		// *
		// * Example:
		// * LDA [$A012] loads A from the address stored at locations $A012 and $A013
		// */
		//ExtendedIndirectOperand:
		//    '[' operand=Expression ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'[' operand=Expression ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ExtendedOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ExtendedOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		///*
		// * Extended
		// *
		// * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
		// * memory address value.
		// *
		// * Example:
		// * LDA $1000 load A from memory location 1000 hex
		// */
		//ExtendedOperand:
		//    ('>'?) operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//('>'?) operand=Expression
		public Group getGroup() { return cGroup; }
		
		//('>'?)
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class DirectOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DirectOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		////
		////IndexedOperand:
		////
		////;
		///*
		// * Direct
		// * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
		// * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
		// * found in the Direct Page register. Thus, the effective address is a concatenation of the
		// * Direct Page register as the most significant half and the byte following the opcode as the
		// * least significant half.
		// *
		// * Example:
		// * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register
		// */
		//DirectOperand:
		//    '<' operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<' operand=Expression
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class ImmediatOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ImmediatOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		///*
		// * Immediate
		// * In Immediate addressing the byte or bytes following the opcode are the information being
		// * addressed. These byte or bytes are specified as part of the instruction.
		// *
		// * Example:
		// * LDA #8 load immediate value (8) into A
		// */
		//ImmediatOperand:
		//    '#' operand=Expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'#' operand=Expression
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_1_0() { return cOperandExpressionParserRuleCall_1_0; }
	}
	public class IndexedOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IndexedOperand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cModeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cModeAutoIncDecModeParserRuleCall_0_0 = (RuleCall)cModeAssignment_0.eContents().get(0);
		private final Assignment cModeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cModeConstantIndexedModeParserRuleCall_1_0 = (RuleCall)cModeAssignment_1.eContents().get(0);
		private final Assignment cModeAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cModeAccumulatorMovingModeParserRuleCall_2_0 = (RuleCall)cModeAssignment_2.eContents().get(0);
		private final Assignment cModeAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cModeRelatifToPCModeParserRuleCall_3_0 = (RuleCall)cModeAssignment_3.eContents().get(0);
		private final Assignment cModeAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cModeConstantIndexedMovingIndirectModeParserRuleCall_4_0 = (RuleCall)cModeAssignment_4.eContents().get(0);
		private final Assignment cModeAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cModeAutoIncDecIndirectModeParserRuleCall_5_0 = (RuleCall)cModeAssignment_5.eContents().get(0);
		private final Assignment cModeAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cModeAccumulatorMovingIndirectModeParserRuleCall_6_0 = (RuleCall)cModeAssignment_6.eContents().get(0);
		private final Assignment cModeAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cModeRelatifToPCIndirectModeParserRuleCall_7_0 = (RuleCall)cModeAssignment_7.eContents().get(0);
		
		//IndexedOperand:
		//    mode=AutoIncDecMode  |
		//    mode=ConstantIndexedMode |
		//    mode=AccumulatorMovingMode |
		//    mode=RelatifToPCMode |
		//    mode=ConstantIndexedMovingIndirectMode |
		//    mode=AutoIncDecIndirectMode  |
		//    mode=AccumulatorMovingIndirectMode |
		//    mode=RelatifToPCIndirectMode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//mode=AutoIncDecMode  |
		//mode=ConstantIndexedMode |
		//mode=AccumulatorMovingMode |
		//mode=RelatifToPCMode |
		//mode=ConstantIndexedMovingIndirectMode |
		//mode=AutoIncDecIndirectMode  |
		//mode=AccumulatorMovingIndirectMode |
		//mode=RelatifToPCIndirectMode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//mode=AutoIncDecMode
		public Assignment getModeAssignment_0() { return cModeAssignment_0; }
		
		//AutoIncDecMode
		public RuleCall getModeAutoIncDecModeParserRuleCall_0_0() { return cModeAutoIncDecModeParserRuleCall_0_0; }
		
		//mode=ConstantIndexedMode
		public Assignment getModeAssignment_1() { return cModeAssignment_1; }
		
		//ConstantIndexedMode
		public RuleCall getModeConstantIndexedModeParserRuleCall_1_0() { return cModeConstantIndexedModeParserRuleCall_1_0; }
		
		//mode=AccumulatorMovingMode
		public Assignment getModeAssignment_2() { return cModeAssignment_2; }
		
		//AccumulatorMovingMode
		public RuleCall getModeAccumulatorMovingModeParserRuleCall_2_0() { return cModeAccumulatorMovingModeParserRuleCall_2_0; }
		
		//mode=RelatifToPCMode
		public Assignment getModeAssignment_3() { return cModeAssignment_3; }
		
		//RelatifToPCMode
		public RuleCall getModeRelatifToPCModeParserRuleCall_3_0() { return cModeRelatifToPCModeParserRuleCall_3_0; }
		
		//mode=ConstantIndexedMovingIndirectMode
		public Assignment getModeAssignment_4() { return cModeAssignment_4; }
		
		//ConstantIndexedMovingIndirectMode
		public RuleCall getModeConstantIndexedMovingIndirectModeParserRuleCall_4_0() { return cModeConstantIndexedMovingIndirectModeParserRuleCall_4_0; }
		
		//mode=AutoIncDecIndirectMode
		public Assignment getModeAssignment_5() { return cModeAssignment_5; }
		
		//AutoIncDecIndirectMode
		public RuleCall getModeAutoIncDecIndirectModeParserRuleCall_5_0() { return cModeAutoIncDecIndirectModeParserRuleCall_5_0; }
		
		//mode=AccumulatorMovingIndirectMode
		public Assignment getModeAssignment_6() { return cModeAssignment_6; }
		
		//AccumulatorMovingIndirectMode
		public RuleCall getModeAccumulatorMovingIndirectModeParserRuleCall_6_0() { return cModeAccumulatorMovingIndirectModeParserRuleCall_6_0; }
		
		//mode=RelatifToPCIndirectMode
		public Assignment getModeAssignment_7() { return cModeAssignment_7; }
		
		//RelatifToPCIndirectMode
		public RuleCall getModeRelatifToPCIndirectModeParserRuleCall_7_0() { return cModeRelatifToPCIndirectModeParserRuleCall_7_0; }
	}
	public class ConstantIndexedModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ConstantIndexedMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cRegisterAlternatives_2_0 = (Alternatives)cRegisterAssignment_2.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_0 = (Keyword)cRegisterAlternatives_2_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1 = (Keyword)cRegisterAlternatives_2_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_2 = (Keyword)cRegisterAlternatives_2_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_3 = (Keyword)cRegisterAlternatives_2_0.eContents().get(3);
		
		//ConstantIndexedMode:
		//    deplacement=NumericalValue?
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0() { return cRegisterAlternatives_2_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_0() { return cRegisterSKeyword_2_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1() { return cRegisterUKeyword_2_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_2() { return cRegisterXKeyword_2_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_3() { return cRegisterYKeyword_2_0_3; }
	}
	public class ConstantIndexedMovingIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ConstantIndexedMovingIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRegisterAlternatives_3_0 = (Alternatives)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_0 = (Keyword)cRegisterAlternatives_3_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1 = (Keyword)cRegisterAlternatives_3_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_2 = (Keyword)cRegisterAlternatives_3_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_3 = (Keyword)cRegisterAlternatives_3_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstantIndexedMovingIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0() { return cRegisterAlternatives_3_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_0() { return cRegisterSKeyword_3_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1() { return cRegisterUKeyword_3_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_2() { return cRegisterXKeyword_3_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_3() { return cRegisterYKeyword_3_0_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AccumulatorMovingModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AccumulatorMovingMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cDeplacementAlternatives_0_0 = (Alternatives)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cDeplacementAKeyword_0_0_0 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(0);
		private final Keyword cDeplacementBKeyword_0_0_1 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(1);
		private final Keyword cDeplacementDKeyword_0_0_2 = (Keyword)cDeplacementAlternatives_0_0.eContents().get(2);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cRegisterAlternatives_2_0 = (Alternatives)cRegisterAssignment_2.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_0 = (Keyword)cRegisterAlternatives_2_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1 = (Keyword)cRegisterAlternatives_2_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_2 = (Keyword)cRegisterAlternatives_2_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_3 = (Keyword)cRegisterAlternatives_2_0.eContents().get(3);
		
		//AccumulatorMovingMode:
		//    deplacement=('A' | 'B' | 'D')
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=('A' | 'B' | 'D')
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup() { return cGroup; }
		
		//deplacement=('A' | 'B' | 'D')
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//('A' | 'B' | 'D')
		public Alternatives getDeplacementAlternatives_0_0() { return cDeplacementAlternatives_0_0; }
		
		//'A'
		public Keyword getDeplacementAKeyword_0_0_0() { return cDeplacementAKeyword_0_0_0; }
		
		//'B'
		public Keyword getDeplacementBKeyword_0_0_1() { return cDeplacementBKeyword_0_0_1; }
		
		//'D'
		public Keyword getDeplacementDKeyword_0_0_2() { return cDeplacementDKeyword_0_0_2; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0() { return cRegisterAlternatives_2_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_0() { return cRegisterSKeyword_2_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1() { return cRegisterUKeyword_2_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_2() { return cRegisterXKeyword_2_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_3() { return cRegisterYKeyword_2_0_3; }
	}
	public class AccumulatorMovingIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AccumulatorMovingIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDeplacementAlternatives_1_0 = (Alternatives)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cDeplacementAKeyword_1_0_0 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(0);
		private final Keyword cDeplacementBKeyword_1_0_1 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(1);
		private final Keyword cDeplacementDKeyword_1_0_2 = (Keyword)cDeplacementAlternatives_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRegisterAlternatives_3_0 = (Alternatives)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_0 = (Keyword)cRegisterAlternatives_3_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1 = (Keyword)cRegisterAlternatives_3_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_2 = (Keyword)cRegisterAlternatives_3_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_3 = (Keyword)cRegisterAlternatives_3_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//AccumulatorMovingIndirectMode:
		//    '['
		//    deplacement=('A' | 'B' | 'D')
		//    ','
		//    register=('S' | 'U' | 'X' | 'Y')
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=('A' | 'B' | 'D')
		//','
		//register=('S' | 'U' | 'X' | 'Y')
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=('A' | 'B' | 'D')
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//('A' | 'B' | 'D')
		public Alternatives getDeplacementAlternatives_1_0() { return cDeplacementAlternatives_1_0; }
		
		//'A'
		public Keyword getDeplacementAKeyword_1_0_0() { return cDeplacementAKeyword_1_0_0; }
		
		//'B'
		public Keyword getDeplacementBKeyword_1_0_1() { return cDeplacementBKeyword_1_0_1; }
		
		//'D'
		public Keyword getDeplacementDKeyword_1_0_2() { return cDeplacementDKeyword_1_0_2; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0() { return cRegisterAlternatives_3_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_0() { return cRegisterSKeyword_3_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1() { return cRegisterUKeyword_3_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_2() { return cRegisterXKeyword_3_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_3() { return cRegisterYKeyword_3_0_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AutoIncDecModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AutoIncDecMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Alternatives cAlternatives_2_0_0 = (Alternatives)cGroup_2_0.eContents().get(0);
		private final Assignment cDecrementAssignment_2_0_0_0 = (Assignment)cAlternatives_2_0_0.eContents().get(0);
		private final Keyword cDecrementHyphenMinusKeyword_2_0_0_0_0 = (Keyword)cDecrementAssignment_2_0_0_0.eContents().get(0);
		private final Assignment cDecrementAssignment_2_0_0_1 = (Assignment)cAlternatives_2_0_0.eContents().get(1);
		private final Keyword cDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0 = (Keyword)cDecrementAssignment_2_0_0_1.eContents().get(0);
		private final Assignment cRegisterAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final Alternatives cRegisterAlternatives_2_0_1_0 = (Alternatives)cRegisterAssignment_2_0_1.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_0_1_0_0 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_0_1_0_1 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_0_1_0_2 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_0_1_0_3 = (Keyword)cRegisterAlternatives_2_0_1_0.eContents().get(3);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cRegisterAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Alternatives cRegisterAlternatives_2_1_0_0 = (Alternatives)cRegisterAssignment_2_1_0.eContents().get(0);
		private final Keyword cRegisterSKeyword_2_1_0_0_0 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_2_1_0_0_1 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_2_1_0_0_2 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_2_1_0_0_3 = (Keyword)cRegisterAlternatives_2_1_0_0.eContents().get(3);
		private final Alternatives cAlternatives_2_1_1 = (Alternatives)cGroup_2_1.eContents().get(1);
		private final Assignment cIncrementAssignment_2_1_1_0 = (Assignment)cAlternatives_2_1_1.eContents().get(0);
		private final Keyword cIncrementPlusSignKeyword_2_1_1_0_0 = (Keyword)cIncrementAssignment_2_1_1_0.eContents().get(0);
		private final Assignment cIncrementAssignment_2_1_1_1 = (Assignment)cAlternatives_2_1_1.eContents().get(1);
		private final Keyword cIncrementPlusSignPlusSignKeyword_2_1_1_1_0 = (Keyword)cIncrementAssignment_2_1_1_1.eContents().get(0);
		
		//AutoIncDecMode:
		//    deplacement=NumericalValue?
		//    ','
		//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//(decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//(decrement='-' | decrement='--')
		public Alternatives getAlternatives_2_0_0() { return cAlternatives_2_0_0; }
		
		//decrement='-'
		public Assignment getDecrementAssignment_2_0_0_0() { return cDecrementAssignment_2_0_0_0; }
		
		//'-'
		public Keyword getDecrementHyphenMinusKeyword_2_0_0_0_0() { return cDecrementHyphenMinusKeyword_2_0_0_0_0; }
		
		//decrement='--'
		public Assignment getDecrementAssignment_2_0_0_1() { return cDecrementAssignment_2_0_0_1; }
		
		//'--'
		public Keyword getDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0() { return cDecrementHyphenMinusHyphenMinusKeyword_2_0_0_1_0; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2_0_1() { return cRegisterAssignment_2_0_1; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_0_1_0() { return cRegisterAlternatives_2_0_1_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_0_1_0_0() { return cRegisterSKeyword_2_0_1_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_0_1_0_1() { return cRegisterUKeyword_2_0_1_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_0_1_0_2() { return cRegisterXKeyword_2_0_1_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_0_1_0_3() { return cRegisterYKeyword_2_0_1_0_3; }
		
		//register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++')
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_2_1_0() { return cRegisterAssignment_2_1_0; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_2_1_0_0() { return cRegisterAlternatives_2_1_0_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_2_1_0_0_0() { return cRegisterSKeyword_2_1_0_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_2_1_0_0_1() { return cRegisterUKeyword_2_1_0_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_2_1_0_0_2() { return cRegisterXKeyword_2_1_0_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_2_1_0_0_3() { return cRegisterYKeyword_2_1_0_0_3; }
		
		//(increment='+' | increment='++')
		public Alternatives getAlternatives_2_1_1() { return cAlternatives_2_1_1; }
		
		//increment='+'
		public Assignment getIncrementAssignment_2_1_1_0() { return cIncrementAssignment_2_1_1_0; }
		
		//'+'
		public Keyword getIncrementPlusSignKeyword_2_1_1_0_0() { return cIncrementPlusSignKeyword_2_1_1_0_0; }
		
		//increment='++'
		public Assignment getIncrementAssignment_2_1_1_1() { return cIncrementAssignment_2_1_1_1; }
		
		//'++'
		public Keyword getIncrementPlusSignPlusSignKeyword_2_1_1_1_0() { return cIncrementPlusSignPlusSignKeyword_2_1_1_1_0; }
	}
	public class AutoIncDecIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AutoIncDecIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Alternatives cAlternatives_3_0_0 = (Alternatives)cGroup_3_0.eContents().get(0);
		private final Assignment cDecrementAssignment_3_0_0_0 = (Assignment)cAlternatives_3_0_0.eContents().get(0);
		private final Keyword cDecrementHyphenMinusKeyword_3_0_0_0_0 = (Keyword)cDecrementAssignment_3_0_0_0.eContents().get(0);
		private final Assignment cDecrementAssignment_3_0_0_1 = (Assignment)cAlternatives_3_0_0.eContents().get(1);
		private final Keyword cDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0 = (Keyword)cDecrementAssignment_3_0_0_1.eContents().get(0);
		private final Assignment cRegisterAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final Alternatives cRegisterAlternatives_3_0_1_0 = (Alternatives)cRegisterAssignment_3_0_1.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_0_1_0_0 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_0_1_0_1 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_0_1_0_2 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_0_1_0_3 = (Keyword)cRegisterAlternatives_3_0_1_0.eContents().get(3);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Assignment cRegisterAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final Alternatives cRegisterAlternatives_3_1_0_0 = (Alternatives)cRegisterAssignment_3_1_0.eContents().get(0);
		private final Keyword cRegisterSKeyword_3_1_0_0_0 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(0);
		private final Keyword cRegisterUKeyword_3_1_0_0_1 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(1);
		private final Keyword cRegisterXKeyword_3_1_0_0_2 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(2);
		private final Keyword cRegisterYKeyword_3_1_0_0_3 = (Keyword)cRegisterAlternatives_3_1_0_0.eContents().get(3);
		private final Alternatives cAlternatives_3_1_1 = (Alternatives)cGroup_3_1.eContents().get(1);
		private final Assignment cIncrementAssignment_3_1_1_0 = (Assignment)cAlternatives_3_1_1.eContents().get(0);
		private final Keyword cIncrementPlusSignKeyword_3_1_1_0_0 = (Keyword)cIncrementAssignment_3_1_1_0.eContents().get(0);
		private final Assignment cIncrementAssignment_3_1_1_1 = (Assignment)cAlternatives_3_1_1.eContents().get(1);
		private final Keyword cIncrementPlusSignPlusSignKeyword_3_1_1_1_0 = (Keyword)cIncrementAssignment_3_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//AutoIncDecIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
		// register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//(decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y')
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//(decrement='-' | decrement='--')
		public Alternatives getAlternatives_3_0_0() { return cAlternatives_3_0_0; }
		
		//decrement='-'
		public Assignment getDecrementAssignment_3_0_0_0() { return cDecrementAssignment_3_0_0_0; }
		
		//'-'
		public Keyword getDecrementHyphenMinusKeyword_3_0_0_0_0() { return cDecrementHyphenMinusKeyword_3_0_0_0_0; }
		
		//decrement='--'
		public Assignment getDecrementAssignment_3_0_0_1() { return cDecrementAssignment_3_0_0_1; }
		
		//'--'
		public Keyword getDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0() { return cDecrementHyphenMinusHyphenMinusKeyword_3_0_0_1_0; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3_0_1() { return cRegisterAssignment_3_0_1; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_0_1_0() { return cRegisterAlternatives_3_0_1_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_0_1_0_0() { return cRegisterSKeyword_3_0_1_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_0_1_0_1() { return cRegisterUKeyword_3_0_1_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_0_1_0_2() { return cRegisterXKeyword_3_0_1_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_0_1_0_3() { return cRegisterYKeyword_3_0_1_0_3; }
		
		//register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++')
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//register=('S' | 'U' | 'X' | 'Y')
		public Assignment getRegisterAssignment_3_1_0() { return cRegisterAssignment_3_1_0; }
		
		//('S' | 'U' | 'X' | 'Y')
		public Alternatives getRegisterAlternatives_3_1_0_0() { return cRegisterAlternatives_3_1_0_0; }
		
		//'S'
		public Keyword getRegisterSKeyword_3_1_0_0_0() { return cRegisterSKeyword_3_1_0_0_0; }
		
		//'U'
		public Keyword getRegisterUKeyword_3_1_0_0_1() { return cRegisterUKeyword_3_1_0_0_1; }
		
		//'X'
		public Keyword getRegisterXKeyword_3_1_0_0_2() { return cRegisterXKeyword_3_1_0_0_2; }
		
		//'Y'
		public Keyword getRegisterYKeyword_3_1_0_0_3() { return cRegisterYKeyword_3_1_0_0_3; }
		
		//(increment='+' | increment='++')
		public Alternatives getAlternatives_3_1_1() { return cAlternatives_3_1_1; }
		
		//increment='+'
		public Assignment getIncrementAssignment_3_1_1_0() { return cIncrementAssignment_3_1_1_0; }
		
		//'+'
		public Keyword getIncrementPlusSignKeyword_3_1_1_0_0() { return cIncrementPlusSignKeyword_3_1_1_0_0; }
		
		//increment='++'
		public Assignment getIncrementAssignment_3_1_1_1() { return cIncrementAssignment_3_1_1_1; }
		
		//'++'
		public Keyword getIncrementPlusSignPlusSignKeyword_3_1_1_1_0() { return cIncrementPlusSignPlusSignKeyword_3_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class RelatifToPCModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RelatifToPCMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeplacementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_0_0 = (RuleCall)cDeplacementAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRegisterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cRegisterPCRKeyword_2_0 = (Keyword)cRegisterAssignment_2.eContents().get(0);
		
		//RelatifToPCMode:
		//    deplacement=NumericalValue?
		//    ','
		//    (register='PCR' )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//deplacement=NumericalValue?
		//','
		//(register='PCR' )
		public Group getGroup() { return cGroup; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_0() { return cDeplacementAssignment_0; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_0_0() { return cDeplacementNumericalValueParserRuleCall_0_0; }
		
		//','
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
		
		//(register='PCR' )
		public Assignment getRegisterAssignment_2() { return cRegisterAssignment_2; }
		
		//'PCR'
		public Keyword getRegisterPCRKeyword_2_0() { return cRegisterPCRKeyword_2_0; }
	}
	public class RelatifToPCIndirectModeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RelatifToPCIndirectMode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeplacementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeplacementNumericalValueParserRuleCall_1_0 = (RuleCall)cDeplacementAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRegisterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cRegisterPCRKeyword_3_0 = (Keyword)cRegisterAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//RelatifToPCIndirectMode:
		//    '['
		//    deplacement=NumericalValue?
		//    ','
		//    (register='PCR' )
		//    ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		//deplacement=NumericalValue?
		//','
		//(register='PCR' )
		//']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//deplacement=NumericalValue?
		public Assignment getDeplacementAssignment_1() { return cDeplacementAssignment_1; }
		
		//NumericalValue
		public RuleCall getDeplacementNumericalValueParserRuleCall_1_0() { return cDeplacementNumericalValueParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//(register='PCR' )
		public Assignment getRegisterAssignment_3() { return cRegisterAssignment_3; }
		
		//'PCR'
		public Keyword getRegisterPCRKeyword_3_0() { return cRegisterPCRKeyword_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class DirectiveLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DirectiveLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDirectiveAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDirectiveEquDirectiveParserRuleCall_0_0 = (RuleCall)cDirectiveAssignment_0.eContents().get(0);
		private final Assignment cDirectiveAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDirectiveOrgDirectiveParserRuleCall_1_0 = (RuleCall)cDirectiveAssignment_1.eContents().get(0);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cDirectiveBszDirectiveParserRuleCall_2_0 = (RuleCall)cDirectiveAssignment_2.eContents().get(0);
		private final Assignment cDirectiveAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cDirectiveEndDirectiveParserRuleCall_3_0 = (RuleCall)cDirectiveAssignment_3.eContents().get(0);
		private final Assignment cDirectiveAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cDirectiveFailDirectiveParserRuleCall_4_0 = (RuleCall)cDirectiveAssignment_4.eContents().get(0);
		private final Assignment cDirectiveAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cDirectiveFillDirectiveParserRuleCall_5_0 = (RuleCall)cDirectiveAssignment_5.eContents().get(0);
		private final Assignment cDirectiveAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cDirectiveOptDirectiveParserRuleCall_6_0 = (RuleCall)cDirectiveAssignment_6.eContents().get(0);
		private final Assignment cDirectiveAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cDirectivePagDirectiveParserRuleCall_7_0 = (RuleCall)cDirectiveAssignment_7.eContents().get(0);
		private final Assignment cDirectiveAssignment_8 = (Assignment)cAlternatives.eContents().get(8);
		private final RuleCall cDirectiveNamDirectiveParserRuleCall_8_0 = (RuleCall)cDirectiveAssignment_8.eContents().get(0);
		private final Assignment cDirectiveAssignment_9 = (Assignment)cAlternatives.eContents().get(9);
		private final RuleCall cDirectiveSetDirectiveParserRuleCall_9_0 = (RuleCall)cDirectiveAssignment_9.eContents().get(0);
		private final Assignment cDirectiveAssignment_10 = (Assignment)cAlternatives.eContents().get(10);
		private final RuleCall cDirectiveSpcDirectiveParserRuleCall_10_0 = (RuleCall)cDirectiveAssignment_10.eContents().get(0);
		private final Assignment cDirectiveAssignment_11 = (Assignment)cAlternatives.eContents().get(11);
		private final RuleCall cDirectiveRegDirectiveParserRuleCall_11_0 = (RuleCall)cDirectiveAssignment_11.eContents().get(0);
		private final Assignment cDirectiveAssignment_12 = (Assignment)cAlternatives.eContents().get(12);
		private final RuleCall cDirectiveFcbDirectiveParserRuleCall_12_0 = (RuleCall)cDirectiveAssignment_12.eContents().get(0);
		private final Assignment cDirectiveAssignment_13 = (Assignment)cAlternatives.eContents().get(13);
		private final RuleCall cDirectiveFdbDirectiveParserRuleCall_13_0 = (RuleCall)cDirectiveAssignment_13.eContents().get(0);
		private final Assignment cDirectiveAssignment_14 = (Assignment)cAlternatives.eContents().get(14);
		private final RuleCall cDirectiveFccDirectiveParserRuleCall_14_0 = (RuleCall)cDirectiveAssignment_14.eContents().get(0);
		private final Assignment cDirectiveAssignment_15 = (Assignment)cAlternatives.eContents().get(15);
		private final RuleCall cDirectiveRmbDirectiveParserRuleCall_15_0 = (RuleCall)cDirectiveAssignment_15.eContents().get(0);
		
		///*
		// * Definition of the list possible directives
		// */
		//DirectiveLine:
		//       directive = EquDirective
		//    |  directive = OrgDirective
		//    |  directive = BszDirective
		//    |  directive = EndDirective
		//    |  directive = FailDirective
		//    |  directive = FillDirective
		//    |  directive = OptDirective
		//    |  directive = PagDirective
		//    |  directive = NamDirective
		//    |  directive = SetDirective
		//    |  directive = SpcDirective
		//    |  directive = RegDirective
		//    |  directive = FcbDirective
		//    |  directive = FdbDirective
		//    |  directive = FccDirective
		//    |  directive = RmbDirective
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//   directive = EquDirective
		//|  directive = OrgDirective
		//|  directive = BszDirective
		//|  directive = EndDirective
		//|  directive = FailDirective
		//|  directive = FillDirective
		//|  directive = OptDirective
		//|  directive = PagDirective
		//|  directive = NamDirective
		//|  directive = SetDirective
		//|  directive = SpcDirective
		//|  directive = RegDirective
		//|  directive = FcbDirective
		//|  directive = FdbDirective
		//|  directive = FccDirective
		//|  directive = RmbDirective
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//directive = EquDirective
		public Assignment getDirectiveAssignment_0() { return cDirectiveAssignment_0; }
		
		//EquDirective
		public RuleCall getDirectiveEquDirectiveParserRuleCall_0_0() { return cDirectiveEquDirectiveParserRuleCall_0_0; }
		
		//directive = OrgDirective
		public Assignment getDirectiveAssignment_1() { return cDirectiveAssignment_1; }
		
		//OrgDirective
		public RuleCall getDirectiveOrgDirectiveParserRuleCall_1_0() { return cDirectiveOrgDirectiveParserRuleCall_1_0; }
		
		//directive = BszDirective
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//BszDirective
		public RuleCall getDirectiveBszDirectiveParserRuleCall_2_0() { return cDirectiveBszDirectiveParserRuleCall_2_0; }
		
		//directive = EndDirective
		public Assignment getDirectiveAssignment_3() { return cDirectiveAssignment_3; }
		
		//EndDirective
		public RuleCall getDirectiveEndDirectiveParserRuleCall_3_0() { return cDirectiveEndDirectiveParserRuleCall_3_0; }
		
		//directive = FailDirective
		public Assignment getDirectiveAssignment_4() { return cDirectiveAssignment_4; }
		
		//FailDirective
		public RuleCall getDirectiveFailDirectiveParserRuleCall_4_0() { return cDirectiveFailDirectiveParserRuleCall_4_0; }
		
		//directive = FillDirective
		public Assignment getDirectiveAssignment_5() { return cDirectiveAssignment_5; }
		
		//FillDirective
		public RuleCall getDirectiveFillDirectiveParserRuleCall_5_0() { return cDirectiveFillDirectiveParserRuleCall_5_0; }
		
		//directive = OptDirective
		public Assignment getDirectiveAssignment_6() { return cDirectiveAssignment_6; }
		
		//OptDirective
		public RuleCall getDirectiveOptDirectiveParserRuleCall_6_0() { return cDirectiveOptDirectiveParserRuleCall_6_0; }
		
		//directive = PagDirective
		public Assignment getDirectiveAssignment_7() { return cDirectiveAssignment_7; }
		
		//PagDirective
		public RuleCall getDirectivePagDirectiveParserRuleCall_7_0() { return cDirectivePagDirectiveParserRuleCall_7_0; }
		
		//directive = NamDirective
		public Assignment getDirectiveAssignment_8() { return cDirectiveAssignment_8; }
		
		//NamDirective
		public RuleCall getDirectiveNamDirectiveParserRuleCall_8_0() { return cDirectiveNamDirectiveParserRuleCall_8_0; }
		
		//directive = SetDirective
		public Assignment getDirectiveAssignment_9() { return cDirectiveAssignment_9; }
		
		//SetDirective
		public RuleCall getDirectiveSetDirectiveParserRuleCall_9_0() { return cDirectiveSetDirectiveParserRuleCall_9_0; }
		
		//directive = SpcDirective
		public Assignment getDirectiveAssignment_10() { return cDirectiveAssignment_10; }
		
		//SpcDirective
		public RuleCall getDirectiveSpcDirectiveParserRuleCall_10_0() { return cDirectiveSpcDirectiveParserRuleCall_10_0; }
		
		//directive = RegDirective
		public Assignment getDirectiveAssignment_11() { return cDirectiveAssignment_11; }
		
		//RegDirective
		public RuleCall getDirectiveRegDirectiveParserRuleCall_11_0() { return cDirectiveRegDirectiveParserRuleCall_11_0; }
		
		//directive = FcbDirective
		public Assignment getDirectiveAssignment_12() { return cDirectiveAssignment_12; }
		
		//FcbDirective
		public RuleCall getDirectiveFcbDirectiveParserRuleCall_12_0() { return cDirectiveFcbDirectiveParserRuleCall_12_0; }
		
		//directive = FdbDirective
		public Assignment getDirectiveAssignment_13() { return cDirectiveAssignment_13; }
		
		//FdbDirective
		public RuleCall getDirectiveFdbDirectiveParserRuleCall_13_0() { return cDirectiveFdbDirectiveParserRuleCall_13_0; }
		
		//directive = FccDirective
		public Assignment getDirectiveAssignment_14() { return cDirectiveAssignment_14; }
		
		//FccDirective
		public RuleCall getDirectiveFccDirectiveParserRuleCall_14_0() { return cDirectiveFccDirectiveParserRuleCall_14_0; }
		
		//directive = RmbDirective
		public Assignment getDirectiveAssignment_15() { return cDirectiveAssignment_15; }
		
		//RmbDirective
		public RuleCall getDirectiveRmbDirectiveParserRuleCall_15_0() { return cDirectiveRmbDirectiveParserRuleCall_15_0; }
	}
	public class FccDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FccDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveFCCKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cStringAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cStringSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cStringAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
		// * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will
		// * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid
		// * examples follow:
		// *
		// * LABEL1 FCC 'THIS IS AN FCC STRING'
		// * LABEL2 FCC .SO IS THIS.
		// * FCC /LABELS ARE NOT REQUIRED./
		// *
		// * There is another method of using FCC which is a deviation from the standard Motorola definition of this
		// * directive. This allows you to place certain expressions on the same line as the standard FCC delimited
		// * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
		// * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter,
		// * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111
		// * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
		// * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
		// * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
		// * inserted along with strings. Some examples follow:
		// *
		// * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
		// * FCC 'STRING 1',0,'STRING 2'
		// * FCC $04,LABEL,/DELIMITED STRING/
		// *
		// * Note that more than one delimited string may be placed on a line as in the second example.
		// */
		//FccDirective:
		//    (name = IdentifierValue)? WS (directive = 'FCC')
		//    (WS string=STRING)
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'FCC')
		//(WS string=STRING)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'FCC')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'FCC'
		public Keyword getDirectiveFCCKeyword_2_0() { return cDirectiveFCCKeyword_2_0; }
		
		//(WS string=STRING)
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//string=STRING
		public Assignment getStringAssignment_3_1() { return cStringAssignment_3_1; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_3_1_0() { return cStringSTRINGTerminalRuleCall_3_1_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class RegDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RegDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveREGKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOptionsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOptionsRegisterEnumRuleCall_3_1_0 = (RuleCall)cOptionsAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cOptionsAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cOptionsRegisterEnumRuleCall_3_2_1_0 = (RuleCall)cOptionsAssignment_3_2_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// *  REG
		// *
		// * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
		// * This list is represented by a value and the value is equated to the label supplied. In this respect,
		// * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
		// *
		// * <label> REG <register list>
		// *
		// * As an example, suppose a program has a large number of occurences of the following instructions:
		// *
		// * PSHS A,B,Y,U,DP
		// * PULS A,B,Y,U,DP
		// *
		// * To make things more convenient and less error prone the REG directive could be used as shown here:
		// *
		// * RLIST2 REG A,B,Y,U,DP
		// *
		// * Now all the pushes and pulls referred to above could be accomplished with the statements:
		// *
		// * PSHS #RLIST2
		// * PULS #RLIST2
		// *
		// * Of course, the register list may still be typed out on push and pull instructions or an immediate value
		// * (with the desired bit pattern) may be specified.
		// */
		//RegDirective:
		//    (name = IdentifierValue)? WS (directive = 'REG')
		//    (WS options+=Register ( ',' options+=Register)*)?
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'REG')
		//(WS options+=Register ( ',' options+=Register)*)?
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'REG')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'REG'
		public Keyword getDirectiveREGKeyword_2_0() { return cDirectiveREGKeyword_2_0; }
		
		//(WS options+=Register ( ',' options+=Register)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//options+=Register
		public Assignment getOptionsAssignment_3_1() { return cOptionsAssignment_3_1; }
		
		//Register
		public RuleCall getOptionsRegisterEnumRuleCall_3_1_0() { return cOptionsRegisterEnumRuleCall_3_1_0; }
		
		//( ',' options+=Register)*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//','
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//options+=Register
		public Assignment getOptionsAssignment_3_2_1() { return cOptionsAssignment_3_2_1; }
		
		//Register
		public RuleCall getOptionsRegisterEnumRuleCall_3_2_1_0() { return cOptionsRegisterEnumRuleCall_3_2_1_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class SpcDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SpcDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveSPCKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cSpaceCountAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cSpaceCountExpressionParserRuleCall_3_1_0 = (RuleCall)cSpaceCountAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cKeepCountAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cKeepCountExpressionParserRuleCall_3_2_1_0 = (RuleCall)cKeepCountAssignment_3_2_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  SPC
		// *
		// * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
		// *  listing. The general form is:
		// *
		// * SPC [<space count>[,<keep count>]]
		// *
		// * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
		// * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
		// * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
		// * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
		// *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
		// *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing.
		// */
		//SpcDirective:
		//    (name = IdentifierValue)? WS (directive = 'SPC')
		//    (WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'SPC')
		//(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'SPC')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'SPC'
		public Keyword getDirectiveSPCKeyword_2_0() { return cDirectiveSPCKeyword_2_0; }
		
		//(WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(spaceCount=Expression)
		public Assignment getSpaceCountAssignment_3_1() { return cSpaceCountAssignment_3_1; }
		
		//Expression
		public RuleCall getSpaceCountExpressionParserRuleCall_3_1_0() { return cSpaceCountExpressionParserRuleCall_3_1_0; }
		
		//( ',' keepCount=Expression)?
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//','
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//keepCount=Expression
		public Assignment getKeepCountAssignment_3_2_1() { return cKeepCountAssignment_3_2_1; }
		
		//Expression
		public RuleCall getKeepCountExpressionParserRuleCall_3_2_1_0() { return cKeepCountExpressionParserRuleCall_3_2_1_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class NamDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NamDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cDirectiveAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Keyword cDirectiveNAMKeyword_2_0_0 = (Keyword)cDirectiveAssignment_2_0.eContents().get(0);
		private final Assignment cDirectiveAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cDirectiveTTLKeyword_2_1_0 = (Keyword)cDirectiveAssignment_2_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cOperandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOperandIdentifierValueParserRuleCall_4_0 = (RuleCall)cOperandAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cWSTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cCommentAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0 = (RuleCall)cCommentAssignment_5_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  TTL or NAM
		// *
		// * The TTL or NAM directive allows the user to specify a title or name to the program being assembled.
		// * This title is then printed in the header at the top of each output listing page if the page option is
		// * selected. If the page option is not selected, this directive is ignored. The proper form is:
		// *
		// * TTL <text for the title>
		// * or
		// * NAM <text for the title>
		// *
		// * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer.
		// * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL
		// * or NAM directives in a source program. The latest one encountered will always be the one used for printing
		// * at the top of the following page(s).
		// */
		//NamDirective:
		//    (name = IdentifierValue)? WS (directive = 'NAM'|directive = 'TTL')
		//    WS (operand=IdentifierValue)
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'NAM'|directive = 'TTL')
		//WS (operand=IdentifierValue)
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'NAM'|directive = 'TTL')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//directive = 'NAM'
		public Assignment getDirectiveAssignment_2_0() { return cDirectiveAssignment_2_0; }
		
		//'NAM'
		public Keyword getDirectiveNAMKeyword_2_0_0() { return cDirectiveNAMKeyword_2_0_0; }
		
		//directive = 'TTL'
		public Assignment getDirectiveAssignment_2_1() { return cDirectiveAssignment_2_1; }
		
		//'TTL'
		public Keyword getDirectiveTTLKeyword_2_1_0() { return cDirectiveTTLKeyword_2_1_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//(operand=IdentifierValue)
		public Assignment getOperandAssignment_4() { return cOperandAssignment_4; }
		
		//IdentifierValue
		public RuleCall getOperandIdentifierValueParserRuleCall_4_0() { return cOperandIdentifierValueParserRuleCall_4_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_5() { return cGroup_5; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_5_0() { return cWSTerminalRuleCall_5_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_5_1() { return cCommentAssignment_5_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class PagDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.PagDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectivePAGKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOperandAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_3_1_0 = (RuleCall)cOperandAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// *  PAG
		// *
		// * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page.
		// * Note that the 'PAG' option must have been previously selected in order for this directive to take effect.
		// * It is possible to assign a new number to the new page by specifying such in the operand field. If no page
		// * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
		// *  The PAG operator itself will not appear in the listing unless some sort of error is encountered.
		// * The proper form is:
		// *
		// * PAG [<expression>]
		// *
		// * Where the expression is optional. The first page of a listing does not have the header printed on it and
		// * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and
		// * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title,
		// * or subtitle instructions being in the way.
		// */
		//PagDirective:
		//    (name = IdentifierValue)? WS (directive = 'PAG')
		//    (WS (operand=Expression)?)?
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'PAG')
		//(WS (operand=Expression)?)?
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'PAG')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'PAG'
		public Keyword getDirectivePAGKeyword_2_0() { return cDirectivePAGKeyword_2_0; }
		
		//(WS (operand=Expression)?)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(operand=Expression)?
		public Assignment getOperandAssignment_3_1() { return cOperandAssignment_3_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_1_0() { return cOperandExpressionParserRuleCall_3_1_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class OptDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OptDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveOPTKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOptionsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOptionsAssemblyOptionEnumRuleCall_3_1_0 = (RuleCall)cOptionsAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cOptionsAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cOptionsAssemblyOptionEnumRuleCall_3_2_1_0 = (RuleCall)cOptionsAssignment_3_2_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * OPT
		// *
		// *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
		// *  These options are generally related to the format of the output listing and object code. The options which
		// *  may be set with this command are listed below. There are several options not listed here which may be set
		// *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper
		// * form of this instruction is:
		// *
		// * OPT <option 1>,<option 2>,...,<option n>
		// *
		// * Note that any number of options may be given on one line if separated by commas. No label is allowed and no
		// * spaces may be embedded in the option list. The options are all set during pass one only although the
		// * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are
		// * specified, the last one appearing takes precedence. If a particular option is not specified, the default
		// * case for that option takes effect. The default cases are signified below by an asterisk.
		// *
		// * The allowable options are:
		// *
		// * PAG enable page formatting and numbering
		// * NOP* disable pagination
		// *
		// * CON print conditionally skipped code
		// * NOC* suppress conditional code printing
		// *
		// * MAC* print macro calling lines
		// * NOM suppress printing of macro calls
		// *
		// * EXP print macro expansion lines
		// * NOE* Suppress macro expansion printing
		// *
		// * * denotes default option and is not part of option name
		// */
		//OptDirective:
		//    (name = IdentifierValue)? WS (directive = 'OPT')
		//    (WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'OPT')
		//(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'OPT')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'OPT'
		public Keyword getDirectiveOPTKeyword_2_0() { return cDirectiveOPTKeyword_2_0; }
		
		//(WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//options+=AssemblyOption
		public Assignment getOptionsAssignment_3_1() { return cOptionsAssignment_3_1; }
		
		//AssemblyOption
		public RuleCall getOptionsAssemblyOptionEnumRuleCall_3_1_0() { return cOptionsAssemblyOptionEnumRuleCall_3_1_0; }
		
		//( ',' options+=AssemblyOption)*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//','
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//options+=AssemblyOption
		public Assignment getOptionsAssignment_3_2_1() { return cOptionsAssignment_3_2_1; }
		
		//AssemblyOption
		public RuleCall getOptionsAssemblyOptionEnumRuleCall_3_2_1_0() { return cOptionsAssemblyOptionEnumRuleCall_3_2_1_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class FailDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FailDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveFAILKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		///*
		// * FAIL
		// *
		// *
		// */
		//FailDirective:
		//    (name = IdentifierValue)? WS (directive = 'FAIL')
		//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'FAIL')
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'FAIL')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'FAIL'
		public Keyword getDirectiveFAILKeyword_2_0() { return cDirectiveFAILKeyword_2_0; }
		
		//(WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_4() { return cEndOfLineParserRuleCall_4; }
	}
	public class SetDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.SetDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveSETKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_4_0_0 = (Assignment)cGroup_4_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_4_0_0_0 = (Keyword)cIsRelativeToPCAssignment_4_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_4_0_1_0 = (RuleCall)cOperandAssignment_4_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_4_1_0 = (Keyword)cIsRelativeToPCAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cCommentAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0 = (RuleCall)cCommentAssignment_6.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * SET
		// *
		// * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
		// * The difference is that a symbol may be SET several times within the source (to different values) while
		// * a symbol may be Equated only once.
		// * If a symbol is SET to several values within the source, the current value of the symbol will be
		// * the value last SET. The statement form is:
		// *
		// * <label> SET <expression>
		// *
		// * The label is strictly required and no code is generated.
		// */
		//SetDirective:
		//    (name = IdentifierValue)? WS (directive = 'SET')
		//    WS (
		//        ( isRelativeToPC?='*'? operand=Expression) |
		//        ( isRelativeToPC?='*' )
		//        )
		//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'SET')
		//WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    )
		//WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'SET')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'SET'
		public Keyword getDirectiveSETKeyword_2_0() { return cDirectiveSETKeyword_2_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//(
		//       ( isRelativeToPC?='*'? operand=Expression) |
		//       ( isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//( isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_4_0_0() { return cIsRelativeToPCAssignment_4_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_4_0_0_0() { return cIsRelativeToPCAsteriskKeyword_4_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_4_0_1() { return cOperandAssignment_4_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_4_0_1_0() { return cOperandExpressionParserRuleCall_4_0_1_0; }
		
		//( isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_4_1() { return cIsRelativeToPCAssignment_4_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_4_1_0() { return cIsRelativeToPCAsteriskKeyword_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_6() { return cCommentAssignment_6; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class FillDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FillDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cDirectiveAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cDirectiveFILLKeyword_1_1_0 = (Keyword)cDirectiveAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cWSTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Keyword cCommaKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cNumberAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cNumberExpressionParserRuleCall_2_3_0 = (RuleCall)cNumberAssignment_2_3.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cCommentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0 = (RuleCall)cCommentAssignment_3_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEndOfLineParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///*
		// * FILL
		// *
		// * FILL allow to initialize a memory area with a value
		// * the first value define the value to set, the seconfd value define the number of byte to set
		// */
		//FillDirective:
		//    (name = IdentifierValue)?
		//    (WS (directive = 'FILL'))
		//    (WS value=Expression ',' number=Expression)
		//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)?
		//(WS (directive = 'FILL'))
		//(WS value=Expression ',' number=Expression)
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//(WS (directive = 'FILL'))
		public Group getGroup_1() { return cGroup_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_0() { return cWSTerminalRuleCall_1_0; }
		
		//(directive = 'FILL')
		public Assignment getDirectiveAssignment_1_1() { return cDirectiveAssignment_1_1; }
		
		//'FILL'
		public Keyword getDirectiveFILLKeyword_1_1_0() { return cDirectiveFILLKeyword_1_1_0; }
		
		//(WS value=Expression ',' number=Expression)
		public Group getGroup_2() { return cGroup_2; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_2_0() { return cWSTerminalRuleCall_2_0; }
		
		//value=Expression
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_1_0() { return cValueExpressionParserRuleCall_2_1_0; }
		
		//','
		public Keyword getCommaKeyword_2_2() { return cCommaKeyword_2_2; }
		
		//number=Expression
		public Assignment getNumberAssignment_2_3() { return cNumberAssignment_2_3; }
		
		//Expression
		public RuleCall getNumberExpressionParserRuleCall_2_3_0() { return cNumberExpressionParserRuleCall_2_3_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_3_1() { return cCommentAssignment_3_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_3_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_5() { return cEndOfLineParserRuleCall_5; }
	}
	public class BszDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BszDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cDirectiveAlternatives_2_0 = (Alternatives)cDirectiveAssignment_2.eContents().get(0);
		private final Keyword cDirectiveBSZKeyword_2_0_0 = (Keyword)cDirectiveAlternatives_2_0.eContents().get(0);
		private final Keyword cDirectiveZMBKeyword_2_0_1 = (Keyword)cDirectiveAlternatives_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOperandAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_3_1_0 = (RuleCall)cOperandAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// * BSZ
		// *
		// * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
		// * The operand define the number on byte to reserve
		// */
		//BszDirective:
		//    (name = IdentifierValue)? WS (directive = ('BSZ'|'ZMB'))
		//    (WS operand=Expression)
		//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = ('BSZ'|'ZMB'))
		//(WS operand=Expression)
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = ('BSZ'|'ZMB'))
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//('BSZ'|'ZMB')
		public Alternatives getDirectiveAlternatives_2_0() { return cDirectiveAlternatives_2_0; }
		
		//'BSZ'
		public Keyword getDirectiveBSZKeyword_2_0_0() { return cDirectiveBSZKeyword_2_0_0; }
		
		//'ZMB'
		public Keyword getDirectiveZMBKeyword_2_0_1() { return cDirectiveZMBKeyword_2_0_1; }
		
		//(WS operand=Expression)
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_3_1() { return cOperandAssignment_3_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_1_0() { return cOperandExpressionParserRuleCall_3_1_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class FdbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FdbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveFDBKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOperandAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOperandListOfExpressionParserRuleCall_3_1_0 = (RuleCall)cOperandAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  FDB
		// *
		// * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
		// * It is exactly like the FCB directive except that 16 bit quantities are evaluated
		// * and stored in memory for each expression given.
		// * The form of the statement is:
		// *
		// * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
		// *
		// * Again, the label field is optional.
		// */
		//FdbDirective:
		//    (name = IdentifierValue)? WS (directive = 'FDB')
		//    (WS (operand = ListOfExpression))?
		//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//    WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'FDB')
		//(WS (operand = ListOfExpression))?
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'FDB')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'FDB'
		public Keyword getDirectiveFDBKeyword_2_0() { return cDirectiveFDBKeyword_2_0; }
		
		//(WS (operand = ListOfExpression))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(operand = ListOfExpression)
		public Assignment getOperandAssignment_3_1() { return cOperandAssignment_3_1; }
		
		//ListOfExpression
		public RuleCall getOperandListOfExpressionParserRuleCall_3_1_0() { return cOperandListOfExpressionParserRuleCall_3_1_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class FcbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.FcbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveFCBKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOperandAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOperandListOfExpressionParserRuleCall_3_1_0 = (RuleCall)cOperandAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  The FCB or Form Constant Byte directive is used to set associated memory bytes
		// * to some value as determined by the operand.
		// * FCB may be used to set any number of bytes as shown below:
		// *
		// * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
		// *
		// * Where <expr. x> stands for some expression.
		// * Each expression given (separated by commas) is evaluated to 8 bits
		// * and the resulting quantities are stored in successive memory locations.
		// * The label is optional.
		// */
		//FcbDirective:
		//    (name = IdentifierValue)? WS (directive = 'FCB') (WS (operand = ListOfExpression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'FCB') (WS (operand = ListOfExpression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'FCB')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'FCB'
		public Keyword getDirectiveFCBKeyword_2_0() { return cDirectiveFCBKeyword_2_0; }
		
		//(WS (operand = ListOfExpression))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(operand = ListOfExpression)
		public Assignment getOperandAssignment_3_1() { return cOperandAssignment_3_1; }
		
		//ListOfExpression
		public RuleCall getOperandListOfExpressionParserRuleCall_3_1_0() { return cOperandListOfExpressionParserRuleCall_3_1_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class RmbDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RmbDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveRMBKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Assignment cIsRelativeToPCAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_3_1_0_0 = (Keyword)cIsRelativeToPCAssignment_3_1_0.eContents().get(0);
		private final Assignment cOperandAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_3_1_1_0 = (RuleCall)cOperandAssignment_3_1_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  RMB
		// *
		// * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
		// * The number of bytes specified by the expression in the operand are skipped during assembly.
		// * No code is produced in those memory location and therefore the contents are undefined at run time.
		// *  The proper useage is shown here:
		// *
		// * [<label>] RMB <expression>
		// *
		// * The label is optional, and the expression is a 16 bit quantity.
		// */
		//RmbDirective:
		//    (name = IdentifierValue)? WS (directive = 'RMB') (WS (isRelativeToPC?='*'? operand = Expression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'RMB') (WS (isRelativeToPC?='*'? operand = Expression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'RMB')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'RMB'
		public Keyword getDirectiveRMBKeyword_2_0() { return cDirectiveRMBKeyword_2_0; }
		
		//(WS (isRelativeToPC?='*'? operand = Expression))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(isRelativeToPC?='*'? operand = Expression)
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_3_1_0() { return cIsRelativeToPCAssignment_3_1_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_3_1_0_0() { return cIsRelativeToPCAsteriskKeyword_3_1_0_0; }
		
		//operand = Expression
		public Assignment getOperandAssignment_3_1_1() { return cOperandAssignment_3_1_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_1_1_0() { return cOperandExpressionParserRuleCall_3_1_1_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class EndDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EndDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveENDKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final Group cGroup_3_1_0 = (Group)cAlternatives_3_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_3_1_0_0 = (Assignment)cGroup_3_1_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_3_1_0_0_0 = (Keyword)cIsRelativeToPCAssignment_3_1_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_3_1_0_1 = (Assignment)cGroup_3_1_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_3_1_0_1_0 = (RuleCall)cOperandAssignment_3_1_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_3_1_1 = (Assignment)cAlternatives_3_1.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_3_1_1_0 = (Keyword)cIsRelativeToPCAssignment_3_1_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cWSTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cCommentAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0 = (RuleCall)cCommentAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// * The END pseudo-op is used to signal the assembler that the end of the source input has occurred.
		// * This terminates whatever pass is currently being executed. No label is allowed and no code is generated.
		// * An expression may be given (as shown below) as the transfer address to be placed in a binary file.
		// * It is optional, and if supplied when no binary file is being produced, will be ignored.
		// *
		// *  END [<expression>]
		// *
		// * Note that an end statement is not strictly required,
		// * but is the only means of getting a transfer address appended to a binary output file.
		// */
		//EndDirective:
		//    (name = IdentifierValue)? WS (directive = 'END')
		//    (WS (
		//        ( isRelativeToPC?='*'? operand=Expression) |
		//        ( isRelativeToPC?='*' )
		//        ))?
		//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'END')
		//(WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    ))?
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'END')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'END'
		public Keyword getDirectiveENDKeyword_2_0() { return cDirectiveENDKeyword_2_0; }
		
		//(WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    ))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(
		//       ( isRelativeToPC?='*'? operand=Expression) |
		//       ( isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }
		
		//( isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_3_1_0() { return cGroup_3_1_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_3_1_0_0() { return cIsRelativeToPCAssignment_3_1_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_3_1_0_0_0() { return cIsRelativeToPCAsteriskKeyword_3_1_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_3_1_0_1() { return cOperandAssignment_3_1_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_1_0_1_0() { return cOperandExpressionParserRuleCall_3_1_0_1_0; }
		
		//( isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_3_1_1() { return cIsRelativeToPCAssignment_3_1_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_3_1_1_0() { return cIsRelativeToPCAsteriskKeyword_3_1_1_0; }
		
		//(WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Group getGroup_4() { return cGroup_4; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_4_0() { return cWSTerminalRuleCall_4_0; }
		
		//comment=ANY_EXCEPT_COMMENT_END_OF_LINE
		public Assignment getCommentAssignment_4_1() { return cCommentAssignment_4_1; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class OrgDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OrgDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveORGKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final Group cGroup_3_1_0 = (Group)cAlternatives_3_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_3_1_0_0 = (Assignment)cGroup_3_1_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_3_1_0_0_0 = (Keyword)cIsRelativeToPCAssignment_3_1_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_3_1_0_1 = (Assignment)cGroup_3_1_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_3_1_0_1_0 = (RuleCall)cOperandAssignment_3_1_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_3_1_1 = (Assignment)cAlternatives_3_1.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_3_1_1_0 = (Keyword)cIsRelativeToPCAssignment_3_1_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cCommentAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_0 = (RuleCall)cCommentAssignment_5.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		///*
		// *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
		// *
		// *         ORG <expression>
		// *
		// *    No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed.
		// */
		//OrgDirective:
		//    (name = IdentifierValue)? WS (directive = 'ORG')
		//    (WS (
		//        (isRelativeToPC?='*'? operand=Expression) |
		//        (isRelativeToPC?='*' )
		//        ))?
		//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'ORG')
		//(WS (
		//    (isRelativeToPC?='*'? operand=Expression) |
		//    (isRelativeToPC?='*' )
		//    ))?
		//WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'ORG')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'ORG'
		public Keyword getDirectiveORGKeyword_2_0() { return cDirectiveORGKeyword_2_0; }
		
		//(WS (
		//    (isRelativeToPC?='*'? operand=Expression) |
		//    (isRelativeToPC?='*' )
		//    ))?
		public Group getGroup_3() { return cGroup_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3_0() { return cWSTerminalRuleCall_3_0; }
		
		//(
		//       (isRelativeToPC?='*'? operand=Expression) |
		//       (isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }
		
		//(isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_3_1_0() { return cGroup_3_1_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_3_1_0_0() { return cIsRelativeToPCAssignment_3_1_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_3_1_0_0_0() { return cIsRelativeToPCAsteriskKeyword_3_1_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_3_1_0_1() { return cOperandAssignment_3_1_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_1_0_1_0() { return cOperandExpressionParserRuleCall_3_1_0_1_0; }
		
		//(isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_3_1_1() { return cIsRelativeToPCAssignment_3_1_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_3_1_1_0() { return cIsRelativeToPCAsteriskKeyword_3_1_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_4() { return cWSTerminalRuleCall_4; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_5() { return cCommentAssignment_5; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_5_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_6() { return cEndOfLineParserRuleCall_6; }
	}
	public class EquDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EquDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierValueParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDirectiveEQUKeyword_2_0 = (Keyword)cDirectiveAssignment_2.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_4_0_0 = (Assignment)cGroup_4_0.eContents().get(0);
		private final Keyword cIsRelativeToPCAsteriskKeyword_4_0_0_0 = (Keyword)cIsRelativeToPCAssignment_4_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cOperandExpressionParserRuleCall_4_0_1_0 = (RuleCall)cOperandAssignment_4_0_1.eContents().get(0);
		private final Assignment cIsRelativeToPCAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final Keyword cIsRelativeToPCAsteriskKeyword_4_1_0 = (Keyword)cIsRelativeToPCAssignment_4_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cCommentAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0 = (RuleCall)cCommentAssignment_6.eContents().get(0);
		private final RuleCall cEndOfLineParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		///*
		// * Description of an EQU directive
		// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
		// */
		//EquDirective:
		//    (name = IdentifierValue)? WS (directive = 'EQU')
		//    WS (
		//        ( isRelativeToPC?='*'? operand=Expression) |
		//        ( isRelativeToPC?='*' )
		//        )
		//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//    EndOfLine
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(name = IdentifierValue)? WS (directive = 'EQU')
		//WS (
		//    ( isRelativeToPC?='*'? operand=Expression) |
		//    ( isRelativeToPC?='*' )
		//    )
		//WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		//EndOfLine
		public Group getGroup() { return cGroup; }
		
		//(name = IdentifierValue)?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierValue
		public RuleCall getNameIdentifierValueParserRuleCall_0_0() { return cNameIdentifierValueParserRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }
		
		//(directive = 'EQU')
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//'EQU'
		public Keyword getDirectiveEQUKeyword_2_0() { return cDirectiveEQUKeyword_2_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_3() { return cWSTerminalRuleCall_3; }
		
		//(
		//       ( isRelativeToPC?='*'? operand=Expression) |
		//       ( isRelativeToPC?='*' )
		//       )
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//( isRelativeToPC?='*'? operand=Expression)
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//isRelativeToPC?='*'?
		public Assignment getIsRelativeToPCAssignment_4_0_0() { return cIsRelativeToPCAssignment_4_0_0; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_4_0_0_0() { return cIsRelativeToPCAsteriskKeyword_4_0_0_0; }
		
		//operand=Expression
		public Assignment getOperandAssignment_4_0_1() { return cOperandAssignment_4_0_1; }
		
		//Expression
		public RuleCall getOperandExpressionParserRuleCall_4_0_1_0() { return cOperandExpressionParserRuleCall_4_0_1_0; }
		
		//( isRelativeToPC?='*' )
		public Assignment getIsRelativeToPCAssignment_4_1() { return cIsRelativeToPCAssignment_4_1; }
		
		//'*'
		public Keyword getIsRelativeToPCAsteriskKeyword_4_1_0() { return cIsRelativeToPCAsteriskKeyword_4_1_0; }
		
		//WS?
		public RuleCall getWSTerminalRuleCall_5() { return cWSTerminalRuleCall_5; }
		
		//(comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
		public Assignment getCommentAssignment_6() { return cCommentAssignment_6; }
		
		//ANY_EXCEPT_COMMENT_END_OF_LINE
		public RuleCall getCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0() { return cCommentANY_EXCEPT_COMMENT_END_OF_LINETerminalRuleCall_6_0; }
		
		//EndOfLine
		public RuleCall getEndOfLineParserRuleCall_7() { return cEndOfLineParserRuleCall_7; }
	}
	public class ListOfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ListOfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//ListOfExpression:
		//    expressions+=Expression (',' expressions+=Expression)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//expressions+=Expression (',' expressions+=Expression)*
		public Group getGroup() { return cGroup; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }
		
		//(',' expressions+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Expression");
		private final Assignment cOperandAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOperandMultiplicationParserRuleCall_0 = (RuleCall)cOperandAssignment.eContents().get(0);
		
		//Expression:
		//        operand = Multiplication;
		@Override public ParserRule getRule() { return rule; }
		
		//operand = Multiplication
		public Assignment getOperandAssignment() { return cOperandAssignment; }
		
		//Multiplication
		public RuleCall getOperandMultiplicationParserRuleCall_0() { return cOperandMultiplicationParserRuleCall_0; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivisionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperationAsteriskKeyword_1_1_0 = (Keyword)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivisionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//      Division ({Multiplication.left=current} operation='*' right=Division)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Division ({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup() { return cGroup; }
		
		//Division
		public RuleCall getDivisionParserRuleCall_0() { return cDivisionParserRuleCall_0; }
		
		//({Multiplication.left=current} operation='*' right=Division)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }
		
		//operation='*'
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//'*'
		public Keyword getOperationAsteriskKeyword_1_1_0() { return cOperationAsteriskKeyword_1_1_0; }
		
		//right=Division
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Division
		public RuleCall getRightDivisionParserRuleCall_1_2_0() { return cRightDivisionParserRuleCall_1_2_0; }
	}
	public class DivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Division");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModuloParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivisionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationSolidusKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModuloParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Division returns Expression:
		//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Modulo ({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup() { return cGroup; }
		
		//Modulo
		public RuleCall getModuloParserRuleCall_0() { return cModuloParserRuleCall_0; }
		
		//({Division.left=current} opretation='/' right=Modulo)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Division.left=current}
		public Action getDivisionLeftAction_1_0() { return cDivisionLeftAction_1_0; }
		
		//opretation='/'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'/'
		public Keyword getOpretationSolidusKeyword_1_1_0() { return cOpretationSolidusKeyword_1_1_0; }
		
		//right=Modulo
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Modulo
		public RuleCall getRightModuloParserRuleCall_1_2_0() { return cRightModuloParserRuleCall_1_2_0; }
	}
	public class ModuloElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Modulo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModuloLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpretationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpretationPercentSignKeyword_1_1_0 = (Keyword)cOpretationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Modulo returns Expression:
		//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Addition ({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup() { return cGroup; }
		
		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }
		
		//({Modulo.left=current} opretation='%' right=Addition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Modulo.left=current}
		public Action getModuloLeftAction_1_0() { return cModuloLeftAction_1_0; }
		
		//opretation='%'
		public Assignment getOpretationAssignment_1_1() { return cOpretationAssignment_1_1; }
		
		//'%'
		public Keyword getOpretationPercentSignKeyword_1_1_0() { return cOpretationPercentSignKeyword_1_1_0; }
		
		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}
	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubstractionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSubstractionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns Expression:
		//    Substraction ({Addition.left=current} '+' right=Substraction)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Substraction ({Addition.left=current} '+' right=Substraction)*
		public Group getGroup() { return cGroup; }
		
		//Substraction
		public RuleCall getSubstractionParserRuleCall_0() { return cSubstractionParserRuleCall_0; }
		
		//({Addition.left=current} '+' right=Substraction)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0() { return cAdditionLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Substraction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Substraction
		public RuleCall getRightSubstractionParserRuleCall_1_2_0() { return cRightSubstractionParserRuleCall_1_2_0; }
	}
	public class SubstractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Substraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLeftShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSubstractionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightLeftShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Substraction returns Expression:
		//    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
		public Group getGroup() { return cGroup; }
		
		//LeftShift
		public RuleCall getLeftShiftParserRuleCall_0() { return cLeftShiftParserRuleCall_0; }
		
		//({Substraction.left=current} -> '-' right=LeftShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Substraction.left=current}
		public Action getSubstractionLeftAction_1_0() { return cSubstractionLeftAction_1_0; }
		
		//-> '-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=LeftShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//LeftShift
		public RuleCall getRightLeftShiftParserRuleCall_1_2_0() { return cRightLeftShiftParserRuleCall_1_2_0; }
	}
	public class LeftShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.LeftShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRightShiftParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLeftShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRightShiftParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//LeftShift returns Expression:
		//    RightShift ({LeftShift.left=current} '<<' right=RightShift)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//RightShift ({LeftShift.left=current} '<<' right=RightShift)*
		public Group getGroup() { return cGroup; }
		
		//RightShift
		public RuleCall getRightShiftParserRuleCall_0() { return cRightShiftParserRuleCall_0; }
		
		//({LeftShift.left=current} '<<' right=RightShift)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{LeftShift.left=current}
		public Action getLeftShiftLeftAction_1_0() { return cLeftShiftLeftAction_1_0; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_1_1() { return cLessThanSignLessThanSignKeyword_1_1; }
		
		//right=RightShift
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RightShift
		public RuleCall getRightRightShiftParserRuleCall_1_2_0() { return cRightRightShiftParserRuleCall_1_2_0; }
	}
	public class RightShiftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.RightShift");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRightShiftLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RightShift returns Expression:
		//    And ({RightShift.left=current} '>>' right=And)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({RightShift.left=current} '>>' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({RightShift.left=current} '>>' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{RightShift.left=current}
		public Action getRightShiftLeftAction_1_0() { return cRightShiftLeftAction_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_1_1() { return cGreaterThanSignGreaterThanSignKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And returns Expression:
		//    Or ({And.left=current} '&&' right=Or)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({And.left=current} '&&' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({And.left=current} '&&' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or returns Expression:
		//    Xor ({Or.left=current} '||' right=Xor)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({Or.left=current} '||' right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({Or.left=current} '||' right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor returns Expression:
		//    Primary ({Xor.left=current} '^' right=Primary)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Xor.left=current} '^' right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Xor.left=current} '^' right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueDecimalValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueHexaDecimalValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueOctalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueBinaryValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cValueCharacterValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Assignment cValueAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cValueIdentifierValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cNotAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cValueAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cValuePrimaryParserRuleCall_6_2_0 = (RuleCall)cValueAssignment_6_2.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final RuleCall cMultiplicationParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		
		//Primary returns Expression:
		//            value=DecimalValue
		//      |    value=HexaDecimalValue
		//      |    value=OctalValue
		//      |   value=BinaryValue
		//      |   value=CharacterValue
		//       |    value=IdentifierValue
		//       |   {Not} '!' value=Primary
		//      |  '(' Multiplication ')'
		// ;
		@Override public ParserRule getRule() { return rule; }
		
		//      value=DecimalValue
		//|    value=HexaDecimalValue
		//|    value=OctalValue
		//|   value=BinaryValue
		//|   value=CharacterValue
		// |    value=IdentifierValue
		// |   {Not} '!' value=Primary
		//|  '(' Multiplication ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=DecimalValue
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DecimalValue
		public RuleCall getValueDecimalValueParserRuleCall_0_0() { return cValueDecimalValueParserRuleCall_0_0; }
		
		//value=HexaDecimalValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HexaDecimalValue
		public RuleCall getValueHexaDecimalValueParserRuleCall_1_0() { return cValueHexaDecimalValueParserRuleCall_1_0; }
		
		//value=OctalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//OctalValue
		public RuleCall getValueOctalValueParserRuleCall_2_0() { return cValueOctalValueParserRuleCall_2_0; }
		
		//value=BinaryValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BinaryValue
		public RuleCall getValueBinaryValueParserRuleCall_3_0() { return cValueBinaryValueParserRuleCall_3_0; }
		
		//value=CharacterValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//CharacterValue
		public RuleCall getValueCharacterValueParserRuleCall_4_0() { return cValueCharacterValueParserRuleCall_4_0; }
		
		//value=IdentifierValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//IdentifierValue
		public RuleCall getValueIdentifierValueParserRuleCall_5_0() { return cValueIdentifierValueParserRuleCall_5_0; }
		
		//{Not} '!' value=Primary
		public Group getGroup_6() { return cGroup_6; }
		
		//{Not}
		public Action getNotAction_6_0() { return cNotAction_6_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_6_1() { return cExclamationMarkKeyword_6_1; }
		
		//value=Primary
		public Assignment getValueAssignment_6_2() { return cValueAssignment_6_2; }
		
		//Primary
		public RuleCall getValuePrimaryParserRuleCall_6_2_0() { return cValuePrimaryParserRuleCall_6_2_0; }
		
		//'(' Multiplication ')'
		public Group getGroup_7() { return cGroup_7; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_0() { return cLeftParenthesisKeyword_7_0; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_7_1() { return cMultiplicationParserRuleCall_7_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_2() { return cRightParenthesisKeyword_7_2; }
	}
	public class NumericalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.NumericalValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueDecimalValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueHexaDecimalValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueOctalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueBinaryValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cValueCharacterValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Assignment cValueAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cValueIdentifierValueParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		
		//NumericalValue:
		//            value=DecimalValue
		//      |    value=HexaDecimalValue
		//      |    value=OctalValue
		//      |   value=BinaryValue
		//      |   value=CharacterValue
		//       |    value=IdentifierValue
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//      value=DecimalValue
		//|    value=HexaDecimalValue
		//|    value=OctalValue
		//|   value=BinaryValue
		//|   value=CharacterValue
		// |    value=IdentifierValue
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=DecimalValue
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DecimalValue
		public RuleCall getValueDecimalValueParserRuleCall_0_0() { return cValueDecimalValueParserRuleCall_0_0; }
		
		//value=HexaDecimalValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HexaDecimalValue
		public RuleCall getValueHexaDecimalValueParserRuleCall_1_0() { return cValueHexaDecimalValueParserRuleCall_1_0; }
		
		//value=OctalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//OctalValue
		public RuleCall getValueOctalValueParserRuleCall_2_0() { return cValueOctalValueParserRuleCall_2_0; }
		
		//value=BinaryValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BinaryValue
		public RuleCall getValueBinaryValueParserRuleCall_3_0() { return cValueBinaryValueParserRuleCall_3_0; }
		
		//value=CharacterValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//CharacterValue
		public RuleCall getValueCharacterValueParserRuleCall_4_0() { return cValueCharacterValueParserRuleCall_4_0; }
		
		//value=IdentifierValue
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//IdentifierValue
		public RuleCall getValueIdentifierValueParserRuleCall_5_0() { return cValueIdentifierValueParserRuleCall_5_0; }
	}
	public class IdentifierValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.IdentifierValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IdentifierValue:
		//    value = ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = ID
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//ID
		public RuleCall getValueIDTerminalRuleCall_0() { return cValueIDTerminalRuleCall_0; }
	}
	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.StringValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringValue:
		//    value = STRING
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class DecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.DecimalValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cSignAlternatives_0_0 = (Alternatives)cSignAssignment_0.eContents().get(0);
		private final Keyword cSignHyphenMinusKeyword_0_0_0 = (Keyword)cSignAlternatives_0_0.eContents().get(0);
		private final Keyword cSignPlusSignKeyword_0_0_1 = (Keyword)cSignAlternatives_0_0.eContents().get(1);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//DecimalValue:
		//    sign=('-'|'+')? value = INT
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sign=('-'|'+')? value = INT
		public Group getGroup() { return cGroup; }
		
		//sign=('-'|'+')?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }
		
		//('-'|'+')
		public Alternatives getSignAlternatives_0_0() { return cSignAlternatives_0_0; }
		
		//'-'
		public Keyword getSignHyphenMinusKeyword_0_0_0() { return cSignHyphenMinusKeyword_0_0_0; }
		
		//'+'
		public Keyword getSignPlusSignKeyword_0_0_1() { return cSignPlusSignKeyword_0_0_1; }
		
		//value = INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}
	public class HexaDecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HexaDecimalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueHEXATerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//HexaDecimalValue:
		//    value = HEXA
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = HEXA
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//HEXA
		public RuleCall getValueHEXATerminalRuleCall_0() { return cValueHEXATerminalRuleCall_0; }
	}
	public class OctalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OctalValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueOCTALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//OctalValue:
		//    value = OCTAL
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = OCTAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//OCTAL
		public RuleCall getValueOCTALTerminalRuleCall_0() { return cValueOCTALTerminalRuleCall_0; }
	}
	public class BinaryValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BinaryValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBINARYTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BinaryValue:
		//    value = BINARY
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = BINARY
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BINARY
		public RuleCall getValueBINARYTerminalRuleCall_0() { return cValueBINARYTerminalRuleCall_0; }
	}
	public class CharacterValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CharacterValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueCHARACTERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//CharacterValue:
		//    value = CHARACTER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value = CHARACTER
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//CHARACTER
		public RuleCall getValueCHARACTERTerminalRuleCall_0() { return cValueCHARACTERTerminalRuleCall_0; }
	}
	public class EndOfLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.EndOfLine");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCRTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEND_OF_FILETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EndOfLine: CR | END_OF_FILE;
		@Override public ParserRule getRule() { return rule; }
		
		//CR | END_OF_FILE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CR
		public RuleCall getCRTerminalRuleCall_0() { return cCRTerminalRuleCall_0; }
		
		//END_OF_FILE
		public RuleCall getEND_OF_FILETerminalRuleCall_1() { return cEND_OF_FILETerminalRuleCall_1; }
	}
	
	public class AssemblyOptionElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.AssemblyOption");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPAGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPAGPAGKeyword_0_0 = (Keyword)cPAGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOPEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOPNOPKeyword_1_0 = (Keyword)cNOPEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCONEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCONCONKeyword_2_0 = (Keyword)cCONEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNOCEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNOCNOCKeyword_3_0 = (Keyword)cNOCEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMACEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMACMACKeyword_4_0 = (Keyword)cMACEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNOMEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNOMNOMKeyword_5_0 = (Keyword)cNOMEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cEXPEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cEXPEXPKeyword_6_0 = (Keyword)cEXPEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cNOEEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cNOENOEKeyword_7_0 = (Keyword)cNOEEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum AssemblyOption:
		//    PAG= 'PAG' |
		//    NOP= 'NOP' |
		//    CON= 'CON' |
		//    NOC= 'NOC' |
		//    MAC= 'MAC' |
		//    NOM= 'NOM' |
		//    EXP= 'EXP' |
		//    NOE= 'NOE'
		//    ;
		public EnumRule getRule() { return rule; }
		
		//PAG= 'PAG' |
		//NOP= 'NOP' |
		//CON= 'CON' |
		//NOC= 'NOC' |
		//MAC= 'MAC' |
		//NOM= 'NOM' |
		//EXP= 'EXP' |
		//NOE= 'NOE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PAG= 'PAG'
		public EnumLiteralDeclaration getPAGEnumLiteralDeclaration_0() { return cPAGEnumLiteralDeclaration_0; }
		
		//'PAG'
		public Keyword getPAGPAGKeyword_0_0() { return cPAGPAGKeyword_0_0; }
		
		//NOP= 'NOP'
		public EnumLiteralDeclaration getNOPEnumLiteralDeclaration_1() { return cNOPEnumLiteralDeclaration_1; }
		
		//'NOP'
		public Keyword getNOPNOPKeyword_1_0() { return cNOPNOPKeyword_1_0; }
		
		//CON= 'CON'
		public EnumLiteralDeclaration getCONEnumLiteralDeclaration_2() { return cCONEnumLiteralDeclaration_2; }
		
		//'CON'
		public Keyword getCONCONKeyword_2_0() { return cCONCONKeyword_2_0; }
		
		//NOC= 'NOC'
		public EnumLiteralDeclaration getNOCEnumLiteralDeclaration_3() { return cNOCEnumLiteralDeclaration_3; }
		
		//'NOC'
		public Keyword getNOCNOCKeyword_3_0() { return cNOCNOCKeyword_3_0; }
		
		//MAC= 'MAC'
		public EnumLiteralDeclaration getMACEnumLiteralDeclaration_4() { return cMACEnumLiteralDeclaration_4; }
		
		//'MAC'
		public Keyword getMACMACKeyword_4_0() { return cMACMACKeyword_4_0; }
		
		//NOM= 'NOM'
		public EnumLiteralDeclaration getNOMEnumLiteralDeclaration_5() { return cNOMEnumLiteralDeclaration_5; }
		
		//'NOM'
		public Keyword getNOMNOMKeyword_5_0() { return cNOMNOMKeyword_5_0; }
		
		//EXP= 'EXP'
		public EnumLiteralDeclaration getEXPEnumLiteralDeclaration_6() { return cEXPEnumLiteralDeclaration_6; }
		
		//'EXP'
		public Keyword getEXPEXPKeyword_6_0() { return cEXPEXPKeyword_6_0; }
		
		//NOE= 'NOE'
		public EnumLiteralDeclaration getNOEEnumLiteralDeclaration_7() { return cNOEEnumLiteralDeclaration_7; }
		
		//'NOE'
		public Keyword getNOENOEKeyword_7_0() { return cNOENOEKeyword_7_0; }
	}
	public class RegisterElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.Register");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAAKeyword_0_0 = (Keyword)cAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBBKeyword_1_0 = (Keyword)cBEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDDKeyword_2_0 = (Keyword)cDEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cXEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cXXKeyword_3_0 = (Keyword)cXEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cYEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cYYKeyword_4_0 = (Keyword)cYEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cUEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cUUKeyword_5_0 = (Keyword)cUEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cSEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cSSKeyword_6_0 = (Keyword)cSEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cDPEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cDPDPKeyword_7_0 = (Keyword)cDPEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cCCEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cCCCCKeyword_8_0 = (Keyword)cCCEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cPCEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cPCPCKeyword_9_0 = (Keyword)cPCEnumLiteralDeclaration_9.eContents().get(0);
		
		//enum Register:
		//    A = 'A'    |
		//    B = 'B'       |
		//    D = 'D'       |
		//    X = 'X'       |
		//    Y = 'Y'       |
		//    U = 'U'       |
		//    S = 'S'       |
		//    DP = 'DP'  |
		//    CC = 'CC'  |
		//    PC = 'PC'
		//;
		public EnumRule getRule() { return rule; }
		
		//A = 'A'    |
		//B = 'B'       |
		//D = 'D'       |
		//X = 'X'       |
		//Y = 'Y'       |
		//U = 'U'       |
		//S = 'S'       |
		//DP = 'DP'  |
		//CC = 'CC'  |
		//PC = 'PC'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//A = 'A'
		public EnumLiteralDeclaration getAEnumLiteralDeclaration_0() { return cAEnumLiteralDeclaration_0; }
		
		//'A'
		public Keyword getAAKeyword_0_0() { return cAAKeyword_0_0; }
		
		//B = 'B'
		public EnumLiteralDeclaration getBEnumLiteralDeclaration_1() { return cBEnumLiteralDeclaration_1; }
		
		//'B'
		public Keyword getBBKeyword_1_0() { return cBBKeyword_1_0; }
		
		//D = 'D'
		public EnumLiteralDeclaration getDEnumLiteralDeclaration_2() { return cDEnumLiteralDeclaration_2; }
		
		//'D'
		public Keyword getDDKeyword_2_0() { return cDDKeyword_2_0; }
		
		//X = 'X'
		public EnumLiteralDeclaration getXEnumLiteralDeclaration_3() { return cXEnumLiteralDeclaration_3; }
		
		//'X'
		public Keyword getXXKeyword_3_0() { return cXXKeyword_3_0; }
		
		//Y = 'Y'
		public EnumLiteralDeclaration getYEnumLiteralDeclaration_4() { return cYEnumLiteralDeclaration_4; }
		
		//'Y'
		public Keyword getYYKeyword_4_0() { return cYYKeyword_4_0; }
		
		//U = 'U'
		public EnumLiteralDeclaration getUEnumLiteralDeclaration_5() { return cUEnumLiteralDeclaration_5; }
		
		//'U'
		public Keyword getUUKeyword_5_0() { return cUUKeyword_5_0; }
		
		//S = 'S'
		public EnumLiteralDeclaration getSEnumLiteralDeclaration_6() { return cSEnumLiteralDeclaration_6; }
		
		//'S'
		public Keyword getSSKeyword_6_0() { return cSSKeyword_6_0; }
		
		//DP = 'DP'
		public EnumLiteralDeclaration getDPEnumLiteralDeclaration_7() { return cDPEnumLiteralDeclaration_7; }
		
		//'DP'
		public Keyword getDPDPKeyword_7_0() { return cDPDPKeyword_7_0; }
		
		//CC = 'CC'
		public EnumLiteralDeclaration getCCEnumLiteralDeclaration_8() { return cCCEnumLiteralDeclaration_8; }
		
		//'CC'
		public Keyword getCCCCKeyword_8_0() { return cCCCCKeyword_8_0; }
		
		//PC = 'PC'
		public EnumLiteralDeclaration getPCEnumLiteralDeclaration_9() { return cPCEnumLiteralDeclaration_9; }
		
		//'PC'
		public Keyword getPCPCKeyword_9_0() { return cPCPCKeyword_9_0; }
	}
	
	private final ModelElements pModel;
	private final SourceLineElements pSourceLine;
	private final BlankLineElements pBlankLine;
	private final CommentLineElements pCommentLine;
	private final InstructionLineElements pInstructionLine;
	private final AsrInstructionElements pAsrInstruction;
	private final AslInstructionElements pAslInstruction;
	private final AndCCInstructionElements pAndCCInstruction;
	private final AndInstructionElements pAndInstruction;
	private final AdddInstructionElements pAdddInstruction;
	private final AddInstructionElements pAddInstruction;
	private final AdcInstructionElements pAdcInstruction;
	private final AbxInstructionElements pAbxInstruction;
	private final ExtendedIndirectOperandElements pExtendedIndirectOperand;
	private final ExtendedOperandElements pExtendedOperand;
	private final DirectOperandElements pDirectOperand;
	private final ImmediatOperandElements pImmediatOperand;
	private final IndexedOperandElements pIndexedOperand;
	private final ConstantIndexedModeElements pConstantIndexedMode;
	private final ConstantIndexedMovingIndirectModeElements pConstantIndexedMovingIndirectMode;
	private final AccumulatorMovingModeElements pAccumulatorMovingMode;
	private final AccumulatorMovingIndirectModeElements pAccumulatorMovingIndirectMode;
	private final AutoIncDecModeElements pAutoIncDecMode;
	private final AutoIncDecIndirectModeElements pAutoIncDecIndirectMode;
	private final RelatifToPCModeElements pRelatifToPCMode;
	private final RelatifToPCIndirectModeElements pRelatifToPCIndirectMode;
	private final DirectiveLineElements pDirectiveLine;
	private final FccDirectiveElements pFccDirective;
	private final RegDirectiveElements pRegDirective;
	private final SpcDirectiveElements pSpcDirective;
	private final NamDirectiveElements pNamDirective;
	private final PagDirectiveElements pPagDirective;
	private final OptDirectiveElements pOptDirective;
	private final FailDirectiveElements pFailDirective;
	private final SetDirectiveElements pSetDirective;
	private final FillDirectiveElements pFillDirective;
	private final BszDirectiveElements pBszDirective;
	private final FdbDirectiveElements pFdbDirective;
	private final FcbDirectiveElements pFcbDirective;
	private final RmbDirectiveElements pRmbDirective;
	private final EndDirectiveElements pEndDirective;
	private final OrgDirectiveElements pOrgDirective;
	private final EquDirectiveElements pEquDirective;
	private final ListOfExpressionElements pListOfExpression;
	private final ExpressionElements pExpression;
	private final MultiplicationElements pMultiplication;
	private final DivisionElements pDivision;
	private final ModuloElements pModulo;
	private final AdditionElements pAddition;
	private final SubstractionElements pSubstraction;
	private final LeftShiftElements pLeftShift;
	private final RightShiftElements pRightShift;
	private final AndElements pAnd;
	private final OrElements pOr;
	private final XorElements pXor;
	private final PrimaryElements pPrimary;
	private final NumericalValueElements pNumericalValue;
	private final IdentifierValueElements pIdentifierValue;
	private final StringValueElements pStringValue;
	private final DecimalValueElements pDecimalValue;
	private final HexaDecimalValueElements pHexaDecimalValue;
	private final OctalValueElements pOctalValue;
	private final BinaryValueElements pBinaryValue;
	private final CharacterValueElements pCharacterValue;
	private final AssemblyOptionElements eAssemblyOption;
	private final RegisterElements eRegister;
	private final TerminalRule tID;
	private final TerminalRule tHEXA;
	private final TerminalRule tINT;
	private final TerminalRule tOCTAL;
	private final TerminalRule tBINARY;
	private final TerminalRule tCHARACTER;
	private final EndOfLineElements pEndOfLine;
	private final TerminalRule tSTRING;
	private final TerminalRule tANY_EXCEPT_COMMENT_END_OF_LINE;
	private final TerminalRule tWS;
	private final TerminalRule tCR;
	private final TerminalRule tEND_OF_FILE;
	
	private final Grammar grammar;

	@Inject
	public AssemblerGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pSourceLine = new SourceLineElements();
		this.pBlankLine = new BlankLineElements();
		this.pCommentLine = new CommentLineElements();
		this.pInstructionLine = new InstructionLineElements();
		this.pAsrInstruction = new AsrInstructionElements();
		this.pAslInstruction = new AslInstructionElements();
		this.pAndCCInstruction = new AndCCInstructionElements();
		this.pAndInstruction = new AndInstructionElements();
		this.pAdddInstruction = new AdddInstructionElements();
		this.pAddInstruction = new AddInstructionElements();
		this.pAdcInstruction = new AdcInstructionElements();
		this.pAbxInstruction = new AbxInstructionElements();
		this.pExtendedIndirectOperand = new ExtendedIndirectOperandElements();
		this.pExtendedOperand = new ExtendedOperandElements();
		this.pDirectOperand = new DirectOperandElements();
		this.pImmediatOperand = new ImmediatOperandElements();
		this.pIndexedOperand = new IndexedOperandElements();
		this.pConstantIndexedMode = new ConstantIndexedModeElements();
		this.pConstantIndexedMovingIndirectMode = new ConstantIndexedMovingIndirectModeElements();
		this.pAccumulatorMovingMode = new AccumulatorMovingModeElements();
		this.pAccumulatorMovingIndirectMode = new AccumulatorMovingIndirectModeElements();
		this.pAutoIncDecMode = new AutoIncDecModeElements();
		this.pAutoIncDecIndirectMode = new AutoIncDecIndirectModeElements();
		this.pRelatifToPCMode = new RelatifToPCModeElements();
		this.pRelatifToPCIndirectMode = new RelatifToPCIndirectModeElements();
		this.pDirectiveLine = new DirectiveLineElements();
		this.pFccDirective = new FccDirectiveElements();
		this.pRegDirective = new RegDirectiveElements();
		this.pSpcDirective = new SpcDirectiveElements();
		this.pNamDirective = new NamDirectiveElements();
		this.pPagDirective = new PagDirectiveElements();
		this.pOptDirective = new OptDirectiveElements();
		this.pFailDirective = new FailDirectiveElements();
		this.pSetDirective = new SetDirectiveElements();
		this.pFillDirective = new FillDirectiveElements();
		this.pBszDirective = new BszDirectiveElements();
		this.pFdbDirective = new FdbDirectiveElements();
		this.pFcbDirective = new FcbDirectiveElements();
		this.pRmbDirective = new RmbDirectiveElements();
		this.pEndDirective = new EndDirectiveElements();
		this.pOrgDirective = new OrgDirectiveElements();
		this.pEquDirective = new EquDirectiveElements();
		this.pListOfExpression = new ListOfExpressionElements();
		this.pExpression = new ExpressionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pDivision = new DivisionElements();
		this.pModulo = new ModuloElements();
		this.pAddition = new AdditionElements();
		this.pSubstraction = new SubstractionElements();
		this.pLeftShift = new LeftShiftElements();
		this.pRightShift = new RightShiftElements();
		this.pAnd = new AndElements();
		this.pOr = new OrElements();
		this.pXor = new XorElements();
		this.pPrimary = new PrimaryElements();
		this.pNumericalValue = new NumericalValueElements();
		this.pIdentifierValue = new IdentifierValueElements();
		this.pStringValue = new StringValueElements();
		this.pDecimalValue = new DecimalValueElements();
		this.pHexaDecimalValue = new HexaDecimalValueElements();
		this.pOctalValue = new OctalValueElements();
		this.pBinaryValue = new BinaryValueElements();
		this.pCharacterValue = new CharacterValueElements();
		this.eAssemblyOption = new AssemblyOptionElements();
		this.eRegister = new RegisterElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ID");
		this.tHEXA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.HEXA");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.INT");
		this.tOCTAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.OCTAL");
		this.tBINARY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.BINARY");
		this.tCHARACTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CHARACTER");
		this.pEndOfLine = new EndOfLineElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.STRING");
		this.tANY_EXCEPT_COMMENT_END_OF_LINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.ANY_EXCEPT_COMMENT_END_OF_LINE");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.WS");
		this.tCR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.CR");
		this.tEND_OF_FILE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.bpy.electronics.mc6809.assembler.Assembler.END_OF_FILE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.bpy.electronics.mc6809.assembler.Assembler".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	///*
	// * Entry point of an as9 file
	// */
	//Model:
	//    sourceLines += SourceLine*
	//;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///*
	// * Description of an assembler line.
	// * an assembleur may be a comment, a blank line, a directive or an 6809 instruction
	// */
	//SourceLine:
	//    (
	//          (lineContent = BlankLine)
	//        | (lineContent = CommentLine)
	//        | (lineContent = DirectiveLine)
	//        | (lineContent = InstructionLine)
	//    )
	//;
	public SourceLineElements getSourceLineAccess() {
		return pSourceLine;
	}
	
	public ParserRule getSourceLineRule() {
		return getSourceLineAccess().getRule();
	}
	
	///*
	// * Blanck line is an empty line or a set of space or tabs followed by a end of line
	// */
	//BlankLine:
	//    {BlankLine} (blankLine = WS)? EndOfLine
	//;
	public BlankLineElements getBlankLineAccess() {
		return pBlankLine;
	}
	
	public ParserRule getBlankLineRule() {
		return getBlankLineAccess().getRule();
	}
	
	///*
	// * definition of a comment line
	// * A comment line start with a ; following by anything and finish with a end of line
	// */
	//CommentLine:
	//    comment = ANY_EXCEPT_COMMENT_END_OF_LINE EndOfLine
	//;
	public CommentLineElements getCommentLineAccess() {
		return pCommentLine;
	}
	
	public ParserRule getCommentLineRule() {
		return getCommentLineAccess().getRule();
	}
	
	///*
	// * Definition of the list possible instructions
	// */
	//InstructionLine:
	//    instruction = AbxInstruction            |
	//    instruction = AdcInstruction            |
	//    instruction = AddInstruction            |
	//    instruction = AdddInstruction           |
	//    instruction = AndInstruction            |
	//    instruction = AndCCInstruction          |
	//    instruction = AslInstruction            |
	//    instruction = AsrInstruction
	//;
	public InstructionLineElements getInstructionLineAccess() {
		return pInstructionLine;
	}
	
	public ParserRule getInstructionLineRule() {
		return getInstructionLineAccess().getRule();
	}
	
	///*
	// * ASR
	// *
	// * Arithmetic Shift Right
	// * Source Form        : ASR Q, ASLA; ASLB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Not affected
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Shifts all bits of the operand one place to the right. Bit seven is held constant. Bit zero is shifted into the C (carry) bit.
	// * Addressing Mode    : Inherent
	// *                       Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AsrInstruction:
	//    (name = IdentifierValue)? WS
	//       (
	//               (
	//                   instruction = ('ASRA' | 'ASRB')
	//               )
	//            |
	//               (
	//                     instruction = ('ASR')
	//                WS operand = (
	//                    DirectOperand  |
	//                    IndexedOperand |
	//                    ExtendedOperand |
	//                    ExtendedIndirectOperand
	//                )
	//               )
	//       )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AsrInstructionElements getAsrInstructionAccess() {
		return pAsrInstruction;
	}
	
	public ParserRule getAsrInstructionRule() {
		return getAsrInstructionAccess().getRule();
	}
	
	///*
	// * ASL
	// *
	// * Arithmetic Shift Left
	// * Source Form        : ASL Q, ASLA; ASLB
	// * Operation        :
	// * Condition Codes    : H - Undefined
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Loaded with the result of the exclusive OR of bits six and seven of the original operand.
	// *                       C - Loaded with bit seven of the original operand.
	// * Description        : Shifts all bits of the operand one place to the left. Bit zero is loaded with a zero. Bit seven is
	// *                    shifted into the C (carry) bit.
	// * Addressing Mode    : Inherent
	// */
	//AslInstruction:
	//    (name = IdentifierValue)? WS
	//       (
	//               (
	//                   instruction = ('ASLA' | 'ASLB')
	//               )
	//            |
	//               (
	//                     instruction = ('ASL')
	//                WS operand = (
	//                    DirectOperand  |
	//                    IndexedOperand |
	//                    ExtendedOperand |
	//                    ExtendedIndirectOperand
	//                )
	//               )
	//       )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AslInstructionElements getAslInstructionAccess() {
		return pAslInstruction;
	}
	
	public ParserRule getAslInstructionRule() {
		return getAslInstructionAccess().getRule();
	}
	
	///*
	// * ANDCC
	// *
	// * Logical AND Immediate Memory into Condition Code Register
	// * Source Form        : ANDOG #xx
	// * Operation        : R'— R A Ml
	// * Condition Codes    : Affected according to the operation.
	// * Description        : PPerforms a logical AND between the condition code register and the Immediate byte specified In
	// *                    the instruction and places the result in the condition code register.
	// * Addressing Mode    : Immediate
	// */
	//AndCCInstruction:
	//    (name = IdentifierValue)? WS (instruction = ('ANDCC'))
	//    WS operand = (
	//        ImmediatOperand
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AndCCInstructionElements getAndCCInstructionAccess() {
		return pAndCCInstruction;
	}
	
	public ParserRule getAndCCInstructionRule() {
		return getAndCCInstructionAccess().getRule();
	}
	
	///*
	// * AND
	// *
	// * Logical AND Memory into Register
	// * Source Form        : ANDA P; ANDB P
	// * Operation        : R'— RAM
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Always cleared.
	// *                       C - Not affected.
	// * Description        : Performs the logical AND operation between the contents of an accumulator and the contents
	// *                       of memory location M and the result is stored in the accumulator.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AndInstruction:
	//    (name = IdentifierValue)? WS (instruction = ('ANDA' | 'ANDB'))
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AndInstructionElements getAndInstructionAccess() {
		return pAndInstruction;
	}
	
	public ParserRule getAndInstructionRule() {
		return getAndInstructionAccess().getRule();
	}
	
	///*
	// * ADDD
	// *
	// * Add Memory into Register
	// * Source Form        : ADDD P
	// * Operation        : R'— R + M:M + 1
	// * Condition Codes    : H - Not affected.
	// *                       N - Set if the result is negative; cleared otherwise.
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if an overflow is generated; cleared otherwise,
	// *                       C - Set if a carry is generated; cleared otherwise.
	// * Description        : Adds the 16-bit memory value into the 16-bit accumulator
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AdddInstruction:
	//    (name = IdentifierValue)? WS (instruction = ('ADDD'))
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AdddInstructionElements getAdddInstructionAccess() {
		return pAdddInstruction;
	}
	
	public ParserRule getAdddInstructionRule() {
		return getAdddInstructionAccess().getRule();
	}
	
	///*
	// * ADD
	// *
	// * Add Memory into Register
	// * Source Form        : ADDA P; ADDB P
	// * Operation        : R'— R + M
	// * Condition Codes    : H - Set if a half-carry is generated; cleared otherwise,
	// *                       N - Set if the result Is negative; cleared otherwise,
	// *                       Z - Set if the result Is zero; cleared otherwise,
	// *                    V - Set if an overflow is generated; cleared otherwise,
	// *                       C - Set if a carry is generated; cleared otherwise.
	// * Description        : Adds the memory byte into an 8-bit accumulator.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AddInstruction:
	//    (name = IdentifierValue)? WS (instruction = ('ADDA' | 'ADDB'))
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AddInstructionElements getAddInstructionAccess() {
		return pAddInstruction;
	}
	
	public ParserRule getAddInstructionRule() {
		return getAddInstructionAccess().getRule();
	}
	
	///*
	// * ADC
	// *
	// * Add with Carry into Register
	// * Source Form        : ADCA P; ADCB P
	// * Operation        : R'*-R + M + C
	// * Condition Codes    : H - The Half-Carry flag is set if a carry into bit 4 occurred; cleared otherwise.
	// *                       N - The Negative flag is set equal to the new value of bit 7 of the accumulator.
	// *                       Z - The Zero flag is set if the new accumulator value is zero; cleared otherwise.
	// *                    V - The Overflow flag is set if an overflow occurred; cleared otherwise.
	// *                       C - The Carry flag is set if a carry out of bit 7 occurred; cleared otherwise.
	// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
	// * Addressing Mode    : Immediate
	// *                    Extended
	// *                    Direct
	// *                    Indexed
	// */
	//AdcInstruction:
	//    (name = IdentifierValue)? WS (instruction = ('ADCA' | 'ADCB'))
	//    WS operand = (
	//        ImmediatOperand |
	//        DirectOperand  |
	//        IndexedOperand |
	//        ExtendedOperand |
	//        ExtendedIndirectOperand
	//    )
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AdcInstructionElements getAdcInstructionAccess() {
		return pAdcInstruction;
	}
	
	public ParserRule getAdcInstructionRule() {
		return getAdcInstructionAccess().getRule();
	}
	
	///*
	// * ABX
	// *
	// * Add Accumulator B into Index Register X
	// * Source Form        : ABX
	// * Operation        : IX'— IX + ACCB
	// * Condition Codes    : Not affected.
	// * Description        : Add the 8-bit unsigned value in accumulator B into index register X.
	// * Addressing Mode    : Inherent
	// */
	//AbxInstruction:
	//    (name = IdentifierValue)? WS (instruction = 'ABX')
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public AbxInstructionElements getAbxInstructionAccess() {
		return pAbxInstruction;
	}
	
	public ParserRule getAbxInstructionRule() {
		return getAbxInstructionAccess().getRule();
	}
	
	///*
	// * Extended Indirect
	// *
	// * In Extended Indirect addressing, the 16-bit value following the opcode is used to point to
	// * two bytes in memory which are used as the effective address.
	// *
	// * Example:
	// * LDA [$A012] loads A from the address stored at locations $A012 and $A013
	// */
	//ExtendedIndirectOperand:
	//    '[' operand=Expression ']'
	//;
	public ExtendedIndirectOperandElements getExtendedIndirectOperandAccess() {
		return pExtendedIndirectOperand;
	}
	
	public ParserRule getExtendedIndirectOperandRule() {
		return getExtendedIndirectOperandAccess().getRule();
	}
	
	///*
	// * Extended
	// *
	// * In Extended addressing, the two bytes (16-bits) following the opcode are used as an absolute
	// * memory address value.
	// *
	// * Example:
	// * LDA $1000 load A from memory location 1000 hex
	// */
	//ExtendedOperand:
	//    ('>'?) operand=Expression
	//;
	public ExtendedOperandElements getExtendedOperandAccess() {
		return pExtendedOperand;
	}
	
	public ParserRule getExtendedOperandRule() {
		return getExtendedOperandAccess().getRule();
	}
	
	////
	////IndexedOperand:
	////
	////;
	///*
	// * Direct
	// * In Direct addressing, the single byte (8-bits) following the opcode is used as a pointer into
	// * a 256-byte window or "page" of memory. The page used for this purpose is the one currently
	// * found in the Direct Page register. Thus, the effective address is a concatenation of the
	// * Direct Page register as the most significant half and the byte following the opcode as the
	// * least significant half.
	// *
	// * Example:
	// * LDA $22 load A from memory location $XX22 where XX represents the contents of the DP register
	// */
	//DirectOperand:
	//    '<' operand=Expression
	//;
	public DirectOperandElements getDirectOperandAccess() {
		return pDirectOperand;
	}
	
	public ParserRule getDirectOperandRule() {
		return getDirectOperandAccess().getRule();
	}
	
	///*
	// * Immediate
	// * In Immediate addressing the byte or bytes following the opcode are the information being
	// * addressed. These byte or bytes are specified as part of the instruction.
	// *
	// * Example:
	// * LDA #8 load immediate value (8) into A
	// */
	//ImmediatOperand:
	//    '#' operand=Expression
	//;
	public ImmediatOperandElements getImmediatOperandAccess() {
		return pImmediatOperand;
	}
	
	public ParserRule getImmediatOperandRule() {
		return getImmediatOperandAccess().getRule();
	}
	
	//IndexedOperand:
	//    mode=AutoIncDecMode  |
	//    mode=ConstantIndexedMode |
	//    mode=AccumulatorMovingMode |
	//    mode=RelatifToPCMode |
	//    mode=ConstantIndexedMovingIndirectMode |
	//    mode=AutoIncDecIndirectMode  |
	//    mode=AccumulatorMovingIndirectMode |
	//    mode=RelatifToPCIndirectMode
	//;
	public IndexedOperandElements getIndexedOperandAccess() {
		return pIndexedOperand;
	}
	
	public ParserRule getIndexedOperandRule() {
		return getIndexedOperandAccess().getRule();
	}
	
	//ConstantIndexedMode:
	//    deplacement=NumericalValue?
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//;
	public ConstantIndexedModeElements getConstantIndexedModeAccess() {
		return pConstantIndexedMode;
	}
	
	public ParserRule getConstantIndexedModeRule() {
		return getConstantIndexedModeAccess().getRule();
	}
	
	//ConstantIndexedMovingIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//    ']'
	//;
	public ConstantIndexedMovingIndirectModeElements getConstantIndexedMovingIndirectModeAccess() {
		return pConstantIndexedMovingIndirectMode;
	}
	
	public ParserRule getConstantIndexedMovingIndirectModeRule() {
		return getConstantIndexedMovingIndirectModeAccess().getRule();
	}
	
	//AccumulatorMovingMode:
	//    deplacement=('A' | 'B' | 'D')
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//;
	public AccumulatorMovingModeElements getAccumulatorMovingModeAccess() {
		return pAccumulatorMovingMode;
	}
	
	public ParserRule getAccumulatorMovingModeRule() {
		return getAccumulatorMovingModeAccess().getRule();
	}
	
	//AccumulatorMovingIndirectMode:
	//    '['
	//    deplacement=('A' | 'B' | 'D')
	//    ','
	//    register=('S' | 'U' | 'X' | 'Y')
	//    ']'
	//;
	public AccumulatorMovingIndirectModeElements getAccumulatorMovingIndirectModeAccess() {
		return pAccumulatorMovingIndirectMode;
	}
	
	public ParserRule getAccumulatorMovingIndirectModeRule() {
		return getAccumulatorMovingIndirectModeAccess().getRule();
	}
	
	//AutoIncDecMode:
	//    deplacement=NumericalValue?
	//    ','
	//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	//;
	public AutoIncDecModeElements getAutoIncDecModeAccess() {
		return pAutoIncDecMode;
	}
	
	public ParserRule getAutoIncDecModeRule() {
		return getAutoIncDecModeAccess().getRule();
	}
	
	//AutoIncDecIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    ((decrement='-' | decrement='--') register=('S' | 'U' | 'X' | 'Y') |
	//     register=('S' | 'U' | 'X' | 'Y') (increment='+' | increment='++'))
	//    ']'
	//;
	public AutoIncDecIndirectModeElements getAutoIncDecIndirectModeAccess() {
		return pAutoIncDecIndirectMode;
	}
	
	public ParserRule getAutoIncDecIndirectModeRule() {
		return getAutoIncDecIndirectModeAccess().getRule();
	}
	
	//RelatifToPCMode:
	//    deplacement=NumericalValue?
	//    ','
	//    (register='PCR' )
	//;
	public RelatifToPCModeElements getRelatifToPCModeAccess() {
		return pRelatifToPCMode;
	}
	
	public ParserRule getRelatifToPCModeRule() {
		return getRelatifToPCModeAccess().getRule();
	}
	
	//RelatifToPCIndirectMode:
	//    '['
	//    deplacement=NumericalValue?
	//    ','
	//    (register='PCR' )
	//    ']'
	//;
	public RelatifToPCIndirectModeElements getRelatifToPCIndirectModeAccess() {
		return pRelatifToPCIndirectMode;
	}
	
	public ParserRule getRelatifToPCIndirectModeRule() {
		return getRelatifToPCIndirectModeAccess().getRule();
	}
	
	///*
	// * Definition of the list possible directives
	// */
	//DirectiveLine:
	//       directive = EquDirective
	//    |  directive = OrgDirective
	//    |  directive = BszDirective
	//    |  directive = EndDirective
	//    |  directive = FailDirective
	//    |  directive = FillDirective
	//    |  directive = OptDirective
	//    |  directive = PagDirective
	//    |  directive = NamDirective
	//    |  directive = SetDirective
	//    |  directive = SpcDirective
	//    |  directive = RegDirective
	//    |  directive = FcbDirective
	//    |  directive = FdbDirective
	//    |  directive = FccDirective
	//    |  directive = RmbDirective
	//;
	public DirectiveLineElements getDirectiveLineAccess() {
		return pDirectiveLine;
	}
	
	public ParserRule getDirectiveLineRule() {
		return getDirectiveLineAccess().getRule();
	}
	
	///*
	// * The FCC or Form Constant Character directive allows the programmer to specify a string of ASCII characters
	// * delimited by some non-alphanumeric character such as a single quote. All the characters in the string will
	// * be converted to their respective ASCII values and stored in memory, one byte per character. Some valid
	// * examples follow:
	// *
	// * LABEL1 FCC 'THIS IS AN FCC STRING'
	// * LABEL2 FCC .SO IS THIS.
	// * FCC /LABELS ARE NOT REQUIRED./
	// *
	// * There is another method of using FCC which is a deviation from the standard Motorola definition of this
	// * directive. This allows you to place certain expressions on the same line as the standard FCC delimited
	// * string. The items are separated by commas and are evaluated to 8 bit results. In some respects this is like
	// * the FCB directive. The difference is that in the FCC directive, expressions must begin with a letter,
	// * number or dollar-sign whereas in the FCB directive any valid expression will work. For example, %10101111
	// * would be a valid expression for an FCB but not for an FCC since the percent-sign would look like a delimiter
	// * and the assembler would attempt to produce 8 bytes of data from the 8 ASCII characters which follow
	// * (an FCC string). The dollar-sign is an exception to allow hex values such as $0D (carriage return) to be
	// * inserted along with strings. Some examples follow:
	// *
	// * INTRO FCC 'THIS STRING HAS CR & LF',$D,$A
	// * FCC 'STRING 1',0,'STRING 2'
	// * FCC $04,LABEL,/DELIMITED STRING/
	// *
	// * Note that more than one delimited string may be placed on a line as in the second example.
	// */
	//FccDirective:
	//    (name = IdentifierValue)? WS (directive = 'FCC')
	//    (WS string=STRING)
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public FccDirectiveElements getFccDirectiveAccess() {
		return pFccDirective;
	}
	
	public ParserRule getFccDirectiveRule() {
		return getFccDirectiveAccess().getRule();
	}
	
	///*
	// *  REG
	// *
	// * The REG directive allows the user to setup a list of registers for use by the push and pull instructions.
	// * This list is represented by a value and the value is equated to the label supplied. In this respect,
	// * the REG directive is similar to the EQU directive. The correct form of the REG directive is:
	// *
	// * <label> REG <register list>
	// *
	// * As an example, suppose a program has a large number of occurences of the following instructions:
	// *
	// * PSHS A,B,Y,U,DP
	// * PULS A,B,Y,U,DP
	// *
	// * To make things more convenient and less error prone the REG directive could be used as shown here:
	// *
	// * RLIST2 REG A,B,Y,U,DP
	// *
	// * Now all the pushes and pulls referred to above could be accomplished with the statements:
	// *
	// * PSHS #RLIST2
	// * PULS #RLIST2
	// *
	// * Of course, the register list may still be typed out on push and pull instructions or an immediate value
	// * (with the desired bit pattern) may be specified.
	// */
	//RegDirective:
	//    (name = IdentifierValue)? WS (directive = 'REG')
	//    (WS options+=Register ( ',' options+=Register)*)?
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	//    EndOfLine
	//;
	public RegDirectiveElements getRegDirectiveAccess() {
		return pRegDirective;
	}
	
	public ParserRule getRegDirectiveRule() {
		return getRegDirectiveAccess().getRule();
	}
	
	///*
	// *  SPC
	// *
	// * The SPC or Space directive causes the specified number of spaces (line feeds) to be inserted into the output
	// *  listing. The general form is:
	// *
	// * SPC [<space count>[,<keep count>]]
	// *
	// * The space count can be any number from 0 to 255. If the page option is selected, SPC will not cause spacing
	// * past the top of a new page. The <keep count> is optional and is the number of lines which the user wishes
	// * to keep together on a page. If there are not enough lines left on the current page, a page eject is performed.
	// * If there are <keep count> lines left on the page (after printing <space count> spaces), output will continue
	// *  on the current page. If the page option is not selected, the <keep count> will be ignored. If no operand
	// *  is given (ie. just the directive SPC), the assembler will default to one blank line in the output listing.
	// */
	//SpcDirective:
	//    (name = IdentifierValue)? WS (directive = 'SPC')
	//    (WS (spaceCount=Expression) ( ',' keepCount=Expression)?)?
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    WS? EndOfLine
	//;
	public SpcDirectiveElements getSpcDirectiveAccess() {
		return pSpcDirective;
	}
	
	public ParserRule getSpcDirectiveRule() {
		return getSpcDirectiveAccess().getRule();
	}
	
	///*
	// *  TTL or NAM
	// *
	// * The TTL or NAM directive allows the user to specify a title or name to the program being assembled.
	// * This title is then printed in the header at the top of each output listing page if the page option is
	// * selected. If the page option is not selected, this directive is ignored. The proper form is:
	// *
	// * TTL <text for the title>
	// * or
	// * NAM <text for the title>
	// *
	// * All the text following the TTL or NAM directive (excluding leading spaces) is placed in the title buffer.
	// * Up to 32 characters are allowed with any excess being ignored. It is possible to have any number of TTL
	// * or NAM directives in a source program. The latest one encountered will always be the one used for printing
	// * at the top of the following page(s).
	// */
	//NamDirective:
	//    (name = IdentifierValue)? WS (directive = 'NAM'|directive = 'TTL')
	//    WS (operand=IdentifierValue)
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    EndOfLine
	//;
	public NamDirectiveElements getNamDirectiveAccess() {
		return pNamDirective;
	}
	
	public ParserRule getNamDirectiveRule() {
		return getNamDirectiveAccess().getRule();
	}
	
	///*
	// *  PAG
	// *
	// * The PAG directive causes a page eject in the output listing and prints a header at the top of the new page.
	// * Note that the 'PAG' option must have been previously selected in order for this directive to take effect.
	// * It is possible to assign a new number to the new page by specifying such in the operand field. If no page
	// * number is specified, the next consecutive number will be used. No label is allowed and no code is produced.
	// *  The PAG operator itself will not appear in the listing unless some sort of error is encountered.
	// * The proper form is:
	// *
	// * PAG [<expression>]
	// *
	// * Where the expression is optional. The first page of a listing does not have the header printed on it and
	// * is considered to be page 0. The intention here is that all options, title, and subtitle may be setup and
	// * followed by a PAG directive to start the assembled listing at the top of page 1 without the option, title,
	// * or subtitle instructions being in the way.
	// */
	//PagDirective:
	//    (name = IdentifierValue)? WS (directive = 'PAG')
	//    (WS (operand=Expression)?)?
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE))?
	//    EndOfLine
	//;
	public PagDirectiveElements getPagDirectiveAccess() {
		return pPagDirective;
	}
	
	public ParserRule getPagDirectiveRule() {
		return getPagDirectiveAccess().getRule();
	}
	
	///*
	// * OPT
	// *
	// *  The OPT or Option directive allows the user to choose from several different assembly options which are available to him.
	// *  These options are generally related to the format of the output listing and object code. The options which
	// *  may be set with this command are listed below. There are several options not listed here which may be set
	// *  from the FLEX command line. See the appropriate section earlier in the manual for these options. The proper
	// * form of this instruction is:
	// *
	// * OPT <option 1>,<option 2>,...,<option n>
	// *
	// * Note that any number of options may be given on one line if separated by commas. No label is allowed and no
	// * spaces may be embedded in the option list. The options are all set during pass one only although the
	// * instruction is parsed in pass two as well for error reporting purposes. If contradicting options are
	// * specified, the last one appearing takes precedence. If a particular option is not specified, the default
	// * case for that option takes effect. The default cases are signified below by an asterisk.
	// *
	// * The allowable options are:
	// *
	// * PAG enable page formatting and numbering
	// * NOP* disable pagination
	// *
	// * CON print conditionally skipped code
	// * NOC* suppress conditional code printing
	// *
	// * MAC* print macro calling lines
	// * NOM suppress printing of macro calls
	// *
	// * EXP print macro expansion lines
	// * NOE* Suppress macro expansion printing
	// *
	// * * denotes default option and is not part of option name
	// */
	//OptDirective:
	//    (name = IdentifierValue)? WS (directive = 'OPT')
	//    (WS options+=AssemblyOption ( ',' options+=AssemblyOption)*)?
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	//    EndOfLine
	//;
	public OptDirectiveElements getOptDirectiveAccess() {
		return pOptDirective;
	}
	
	public ParserRule getOptDirectiveRule() {
		return getOptDirectiveAccess().getRule();
	}
	
	///*
	// * FAIL
	// *
	// *
	// */
	//FailDirective:
	//    (name = IdentifierValue)? WS (directive = 'FAIL')
	//    (WS (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?)?
	//    EndOfLine
	//;
	public FailDirectiveElements getFailDirectiveAccess() {
		return pFailDirective;
	}
	
	public ParserRule getFailDirectiveRule() {
		return getFailDirectiveAccess().getRule();
	}
	
	///*
	// * SET
	// *
	// * The SET directive is used to set a symbol to the value of some expression, much as an EQU directive.
	// * The difference is that a symbol may be SET several times within the source (to different values) while
	// * a symbol may be Equated only once.
	// * If a symbol is SET to several values within the source, the current value of the symbol will be
	// * the value last SET. The statement form is:
	// *
	// * <label> SET <expression>
	// *
	// * The label is strictly required and no code is generated.
	// */
	//SetDirective:
	//    (name = IdentifierValue)? WS (directive = 'SET')
	//    WS (
	//        ( isRelativeToPC?='*'? operand=Expression) |
	//        ( isRelativeToPC?='*' )
	//        )
	//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
	//    EndOfLine
	//;
	public SetDirectiveElements getSetDirectiveAccess() {
		return pSetDirective;
	}
	
	public ParserRule getSetDirectiveRule() {
		return getSetDirectiveAccess().getRule();
	}
	
	///*
	// * FILL
	// *
	// * FILL allow to initialize a memory area with a value
	// * the first value define the value to set, the seconfd value define the number of byte to set
	// */
	//FillDirective:
	//    (name = IdentifierValue)?
	//    (WS (directive = 'FILL'))
	//    (WS value=Expression ',' number=Expression)
	//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
	//;
	public FillDirectiveElements getFillDirectiveAccess() {
		return pFillDirective;
	}
	
	public ParserRule getFillDirectiveRule() {
		return getFillDirectiveAccess().getRule();
	}
	
	///*
	// * BSZ
	// *
	// * The BSZ directive allow to reserve a bloc of byte and set this bloc to 0
	// * The operand define the number on byte to reserve
	// */
	//BszDirective:
	//    (name = IdentifierValue)? WS (directive = ('BSZ'|'ZMB'))
	//    (WS operand=Expression)
	//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
	//;
	public BszDirectiveElements getBszDirectiveAccess() {
		return pBszDirective;
	}
	
	public ParserRule getBszDirectiveRule() {
		return getBszDirectiveAccess().getRule();
	}
	
	///*
	// *  FDB
	// *
	// * The FDB or Form Double Byte directive is used to setup 16 bit quantities in memory.
	// * It is exactly like the FCB directive except that 16 bit quantities are evaluated
	// * and stored in memory for each expression given.
	// * The form of the statement is:
	// *
	// * [<label>] FDB <expr. 1>,<expr. 2>,...,<expr. n>
	// *
	// * Again, the label field is optional.
	// */
	//FdbDirective:
	//    (name = IdentifierValue)? WS (directive = 'FDB')
	//    (WS (operand = ListOfExpression))?
	//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
	//    WS? EndOfLine
	//;
	public FdbDirectiveElements getFdbDirectiveAccess() {
		return pFdbDirective;
	}
	
	public ParserRule getFdbDirectiveRule() {
		return getFdbDirectiveAccess().getRule();
	}
	
	///*
	// *  The FCB or Form Constant Byte directive is used to set associated memory bytes
	// * to some value as determined by the operand.
	// * FCB may be used to set any number of bytes as shown below:
	// *
	// * [<label>] FCB <expr. 1>,<expr. 2>,....<expr. n>
	// *
	// * Where <expr. x> stands for some expression.
	// * Each expression given (separated by commas) is evaluated to 8 bits
	// * and the resulting quantities are stored in successive memory locations.
	// * The label is optional.
	// */
	//FcbDirective:
	//    (name = IdentifierValue)? WS (directive = 'FCB') (WS (operand = ListOfExpression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
	//;
	public FcbDirectiveElements getFcbDirectiveAccess() {
		return pFcbDirective;
	}
	
	public ParserRule getFcbDirectiveRule() {
		return getFcbDirectiveAccess().getRule();
	}
	
	///*
	// *  RMB
	// *
	// * The RMB or Reserve Memory Bytes directive is used to reserve areas of memory for data storage.
	// * The number of bytes specified by the expression in the operand are skipped during assembly.
	// * No code is produced in those memory location and therefore the contents are undefined at run time.
	// *  The proper useage is shown here:
	// *
	// * [<label>] RMB <expression>
	// *
	// * The label is optional, and the expression is a 16 bit quantity.
	// */
	//RmbDirective:
	//    (name = IdentifierValue)? WS (directive = 'RMB') (WS (isRelativeToPC?='*'? operand = Expression))? (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
	//;
	public RmbDirectiveElements getRmbDirectiveAccess() {
		return pRmbDirective;
	}
	
	public ParserRule getRmbDirectiveRule() {
		return getRmbDirectiveAccess().getRule();
	}
	
	///*
	// * The END pseudo-op is used to signal the assembler that the end of the source input has occurred.
	// * This terminates whatever pass is currently being executed. No label is allowed and no code is generated.
	// * An expression may be given (as shown below) as the transfer address to be placed in a binary file.
	// * It is optional, and if supplied when no binary file is being produced, will be ignored.
	// *
	// *  END [<expression>]
	// *
	// * Note that an end statement is not strictly required,
	// * but is the only means of getting a transfer address appended to a binary output file.
	// */
	//EndDirective:
	//    (name = IdentifierValue)? WS (directive = 'END')
	//    (WS (
	//        ( isRelativeToPC?='*'? operand=Expression) |
	//        ( isRelativeToPC?='*' )
	//        ))?
	//    (WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? WS? EndOfLine
	//;
	public EndDirectiveElements getEndDirectiveAccess() {
		return pEndDirective;
	}
	
	public ParserRule getEndDirectiveRule() {
		return getEndDirectiveAccess().getRule();
	}
	
	///*
	// *  The ORG statement is used to set a new code 'Origin'. This simply means that a new address is set into the location Counter (or program counter) so that subsequent code will be placed at the new location. The form is as follows:
	// *
	// *         ORG <expression>
	// *
	// *    No label may be placed on an ORG statement and no code is produced. If no ORG statement appears in the source, an origin of 0000 is assumed.
	// */
	//OrgDirective:
	//    (name = IdentifierValue)? WS (directive = 'ORG')
	//    (WS (
	//        (isRelativeToPC?='*'? operand=Expression) |
	//        (isRelativeToPC?='*' )
	//        ))?
	//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
	//    EndOfLine
	//;
	public OrgDirectiveElements getOrgDirectiveAccess() {
		return pOrgDirective;
	}
	
	public ParserRule getOrgDirectiveRule() {
		return getOrgDirectiveAccess().getRule();
	}
	
	///*
	// * Description of an EQU directive
	// * An EQU directive must have a label, following by EQU, an operand, and optionnaly a comment
	// */
	//EquDirective:
	//    (name = IdentifierValue)? WS (directive = 'EQU')
	//    WS (
	//        ( isRelativeToPC?='*'? operand=Expression) |
	//        ( isRelativeToPC?='*' )
	//        )
	//    WS? (comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
	//    EndOfLine
	//;
	public EquDirectiveElements getEquDirectiveAccess() {
		return pEquDirective;
	}
	
	public ParserRule getEquDirectiveRule() {
		return getEquDirectiveAccess().getRule();
	}
	
	//ListOfExpression:
	//    expressions+=Expression (',' expressions+=Expression)*
	//;
	public ListOfExpressionElements getListOfExpressionAccess() {
		return pListOfExpression;
	}
	
	public ParserRule getListOfExpressionRule() {
		return getListOfExpressionAccess().getRule();
	}
	
	//Expression:
	//        operand = Multiplication;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Multiplication returns Expression:
	//      Division ({Multiplication.left=current} operation='*' right=Division)*
	//;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	//Division returns Expression:
	//      Modulo ({Division.left=current} opretation='/' right=Modulo)*
	//;
	public DivisionElements getDivisionAccess() {
		return pDivision;
	}
	
	public ParserRule getDivisionRule() {
		return getDivisionAccess().getRule();
	}
	
	//Modulo returns Expression:
	//    Addition ({Modulo.left=current} opretation='%' right=Addition)*
	//;
	public ModuloElements getModuloAccess() {
		return pModulo;
	}
	
	public ParserRule getModuloRule() {
		return getModuloAccess().getRule();
	}
	
	//Addition returns Expression:
	//    Substraction ({Addition.left=current} '+' right=Substraction)*
	//;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}
	
	//Substraction returns Expression:
	//    LeftShift ({Substraction.left=current} -> '-' right=LeftShift)*
	//;
	public SubstractionElements getSubstractionAccess() {
		return pSubstraction;
	}
	
	public ParserRule getSubstractionRule() {
		return getSubstractionAccess().getRule();
	}
	
	//LeftShift returns Expression:
	//    RightShift ({LeftShift.left=current} '<<' right=RightShift)*
	//;
	public LeftShiftElements getLeftShiftAccess() {
		return pLeftShift;
	}
	
	public ParserRule getLeftShiftRule() {
		return getLeftShiftAccess().getRule();
	}
	
	//RightShift returns Expression:
	//    And ({RightShift.left=current} '>>' right=And)*
	//;
	public RightShiftElements getRightShiftAccess() {
		return pRightShift;
	}
	
	public ParserRule getRightShiftRule() {
		return getRightShiftAccess().getRule();
	}
	
	//And returns Expression:
	//    Or ({And.left=current} '&&' right=Or)*
	//;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Or returns Expression:
	//    Xor ({Or.left=current} '||' right=Xor)*
	//;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//Xor returns Expression:
	//    Primary ({Xor.left=current} '^' right=Primary)*
	//;
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Primary returns Expression:
	//            value=DecimalValue
	//      |    value=HexaDecimalValue
	//      |    value=OctalValue
	//      |   value=BinaryValue
	//      |   value=CharacterValue
	//       |    value=IdentifierValue
	//       |   {Not} '!' value=Primary
	//      |  '(' Multiplication ')'
	// ;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//NumericalValue:
	//            value=DecimalValue
	//      |    value=HexaDecimalValue
	//      |    value=OctalValue
	//      |   value=BinaryValue
	//      |   value=CharacterValue
	//       |    value=IdentifierValue
	//;
	public NumericalValueElements getNumericalValueAccess() {
		return pNumericalValue;
	}
	
	public ParserRule getNumericalValueRule() {
		return getNumericalValueAccess().getRule();
	}
	
	//IdentifierValue:
	//    value = ID
	//;
	public IdentifierValueElements getIdentifierValueAccess() {
		return pIdentifierValue;
	}
	
	public ParserRule getIdentifierValueRule() {
		return getIdentifierValueAccess().getRule();
	}
	
	//StringValue:
	//    value = STRING
	//;
	public StringValueElements getStringValueAccess() {
		return pStringValue;
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}
	
	//DecimalValue:
	//    sign=('-'|'+')? value = INT
	//;
	public DecimalValueElements getDecimalValueAccess() {
		return pDecimalValue;
	}
	
	public ParserRule getDecimalValueRule() {
		return getDecimalValueAccess().getRule();
	}
	
	//HexaDecimalValue:
	//    value = HEXA
	//;
	public HexaDecimalValueElements getHexaDecimalValueAccess() {
		return pHexaDecimalValue;
	}
	
	public ParserRule getHexaDecimalValueRule() {
		return getHexaDecimalValueAccess().getRule();
	}
	
	//OctalValue:
	//    value = OCTAL
	//;
	public OctalValueElements getOctalValueAccess() {
		return pOctalValue;
	}
	
	public ParserRule getOctalValueRule() {
		return getOctalValueAccess().getRule();
	}
	
	//BinaryValue:
	//    value = BINARY
	//;
	public BinaryValueElements getBinaryValueAccess() {
		return pBinaryValue;
	}
	
	public ParserRule getBinaryValueRule() {
		return getBinaryValueAccess().getRule();
	}
	
	//CharacterValue:
	//    value = CHARACTER
	//;
	public CharacterValueElements getCharacterValueAccess() {
		return pCharacterValue;
	}
	
	public ParserRule getCharacterValueRule() {
		return getCharacterValueAccess().getRule();
	}
	
	//enum AssemblyOption:
	//    PAG= 'PAG' |
	//    NOP= 'NOP' |
	//    CON= 'CON' |
	//    NOC= 'NOC' |
	//    MAC= 'MAC' |
	//    NOM= 'NOM' |
	//    EXP= 'EXP' |
	//    NOE= 'NOE'
	//    ;
	public AssemblyOptionElements getAssemblyOptionAccess() {
		return eAssemblyOption;
	}
	
	public EnumRule getAssemblyOptionRule() {
		return getAssemblyOptionAccess().getRule();
	}
	
	//enum Register:
	//    A = 'A'    |
	//    B = 'B'       |
	//    D = 'D'       |
	//    X = 'X'       |
	//    Y = 'Y'       |
	//    U = 'U'       |
	//    S = 'S'       |
	//    DP = 'DP'  |
	//    CC = 'CC'  |
	//    PC = 'PC'
	//;
	public RegisterElements getRegisterAccess() {
		return eRegister;
	}
	
	public EnumRule getRegisterRule() {
		return getRegisterAccess().getRule();
	}
	
	//terminal ID									: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal HEXA 								: '$' ('0'..'9'|'a'..'f'|'A'..'F')+;
	public TerminalRule getHEXARule() {
		return tHEXA;
	}
	
	//terminal INT returns ecore::EInt			: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal OCTAL 								: '@'('0'..'7')+;
	public TerminalRule getOCTALRule() {
		return tOCTAL;
	}
	
	//terminal BINARY 							: '0''b'('0'..'1')+;
	public TerminalRule getBINARYRule() {
		return tBINARY;
	}
	
	//terminal CHARACTER							: '\'' ('\u0020'..'\u007F');
	public TerminalRule getCHARACTERRule() {
		return tCHARACTER;
	}
	
	//EndOfLine: CR | END_OF_FILE;
	public EndOfLineElements getEndOfLineAccess() {
		return pEndOfLine;
	}
	
	public ParserRule getEndOfLineRule() {
		return getEndOfLineAccess().getRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
	//        ;
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ANY_EXCEPT_COMMENT_END_OF_LINE  	: ';' !('\n' | '\r')*;
	public TerminalRule getANY_EXCEPT_COMMENT_END_OF_LINERule() {
		return tANY_EXCEPT_COMMENT_END_OF_LINE;
	}
	
	//terminal WS         						: (' '|'\t')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal CR          						: '\r'? '\n';
	public TerminalRule getCRRule() {
		return tCR;
	}
	
	//terminal END_OF_FILE 						: EOF;
	public TerminalRule getEND_OF_FILERule() {
		return tEND_OF_FILE;
	}
}

/*
 * generated by Xtext 2.28.0
 */
package org.bpy.electronics.mc6809.assembler.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.bpy.electronics.mc6809.assembler.assembler.AbxInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AccumulatorMovingIndirectMode;
import org.bpy.electronics.mc6809.assembler.assembler.AccumulatorMovingMode;
import org.bpy.electronics.mc6809.assembler.assembler.AdcInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AddInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AdddInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Addition;
import org.bpy.electronics.mc6809.assembler.assembler.And;
import org.bpy.electronics.mc6809.assembler.assembler.AndCCInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AndInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AslInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AsrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.AssemblerPackage;
import org.bpy.electronics.mc6809.assembler.assembler.AutoIncDecIndirectMode;
import org.bpy.electronics.mc6809.assembler.assembler.AutoIncDecMode;
import org.bpy.electronics.mc6809.assembler.assembler.BccInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BcsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BeqInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BgeInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BgtInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BhiInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BhsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BinaryValue;
import org.bpy.electronics.mc6809.assembler.assembler.BitInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BlankLine;
import org.bpy.electronics.mc6809.assembler.assembler.BleInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BloInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BlsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BltInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BmiInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BneInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BplInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BraInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BrnInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BsrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BszDirective;
import org.bpy.electronics.mc6809.assembler.assembler.BvcInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.BvsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.CharacterValue;
import org.bpy.electronics.mc6809.assembler.assembler.ClrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.CmpInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.ComInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.CommaExpression;
import org.bpy.electronics.mc6809.assembler.assembler.CommentLine;
import org.bpy.electronics.mc6809.assembler.assembler.ConstantIndexedMode;
import org.bpy.electronics.mc6809.assembler.assembler.ConstantIndexedMovingIndirectMode;
import org.bpy.electronics.mc6809.assembler.assembler.CwaiInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.DaaInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.DecInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.DecimalValue;
import org.bpy.electronics.mc6809.assembler.assembler.DirectOperand;
import org.bpy.electronics.mc6809.assembler.assembler.DirectiveLine;
import org.bpy.electronics.mc6809.assembler.assembler.Division;
import org.bpy.electronics.mc6809.assembler.assembler.EndDirective;
import org.bpy.electronics.mc6809.assembler.assembler.EorInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.EquDirective;
import org.bpy.electronics.mc6809.assembler.assembler.ExgInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Expression;
import org.bpy.electronics.mc6809.assembler.assembler.ExtendedIndirectOperand;
import org.bpy.electronics.mc6809.assembler.assembler.ExtendedOperand;
import org.bpy.electronics.mc6809.assembler.assembler.FailDirective;
import org.bpy.electronics.mc6809.assembler.assembler.FcbDirective;
import org.bpy.electronics.mc6809.assembler.assembler.FccDirective;
import org.bpy.electronics.mc6809.assembler.assembler.FdbDirective;
import org.bpy.electronics.mc6809.assembler.assembler.FillDirective;
import org.bpy.electronics.mc6809.assembler.assembler.HexaDecimalValue;
import org.bpy.electronics.mc6809.assembler.assembler.IdentifierValue;
import org.bpy.electronics.mc6809.assembler.assembler.ImmediatOperand;
import org.bpy.electronics.mc6809.assembler.assembler.IncInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.IndexedOperand;
import org.bpy.electronics.mc6809.assembler.assembler.InstructionLine;
import org.bpy.electronics.mc6809.assembler.assembler.JmpInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.JsrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Label;
import org.bpy.electronics.mc6809.assembler.assembler.LabelLine;
import org.bpy.electronics.mc6809.assembler.assembler.LdInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.LeaInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.LeftShift;
import org.bpy.electronics.mc6809.assembler.assembler.ListOfExpression;
import org.bpy.electronics.mc6809.assembler.assembler.LslInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.LsrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Model;
import org.bpy.electronics.mc6809.assembler.assembler.Modulo;
import org.bpy.electronics.mc6809.assembler.assembler.MulInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Multiplication;
import org.bpy.electronics.mc6809.assembler.assembler.NamDirective;
import org.bpy.electronics.mc6809.assembler.assembler.NegInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.NopInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Not;
import org.bpy.electronics.mc6809.assembler.assembler.NumericalValue;
import org.bpy.electronics.mc6809.assembler.assembler.OctalValue;
import org.bpy.electronics.mc6809.assembler.assembler.OptDirective;
import org.bpy.electronics.mc6809.assembler.assembler.Or;
import org.bpy.electronics.mc6809.assembler.assembler.OrCCInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.OrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.OrgDirective;
import org.bpy.electronics.mc6809.assembler.assembler.PagDirective;
import org.bpy.electronics.mc6809.assembler.assembler.PshsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.PshuInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.PulsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.PuluInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.RegDirective;
import org.bpy.electronics.mc6809.assembler.assembler.RelatifToPCIndirectMode;
import org.bpy.electronics.mc6809.assembler.assembler.RelatifToPCMode;
import org.bpy.electronics.mc6809.assembler.assembler.RelativeMode;
import org.bpy.electronics.mc6809.assembler.assembler.RightShift;
import org.bpy.electronics.mc6809.assembler.assembler.RmbDirective;
import org.bpy.electronics.mc6809.assembler.assembler.RolInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.RorInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.RtiInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.RtsInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.SbcInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.SetDPDirective;
import org.bpy.electronics.mc6809.assembler.assembler.SetDirective;
import org.bpy.electronics.mc6809.assembler.assembler.SexInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.SourceLine;
import org.bpy.electronics.mc6809.assembler.assembler.SpcDirective;
import org.bpy.electronics.mc6809.assembler.assembler.StInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.StringValue;
import org.bpy.electronics.mc6809.assembler.assembler.SubInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.SubdInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Substraction;
import org.bpy.electronics.mc6809.assembler.assembler.Swi2Instruction;
import org.bpy.electronics.mc6809.assembler.assembler.Swi3Instruction;
import org.bpy.electronics.mc6809.assembler.assembler.SwiInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.SyncInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.TfrInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.TstInstruction;
import org.bpy.electronics.mc6809.assembler.assembler.Xor;
import org.bpy.electronics.mc6809.assembler.services.AssemblerGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AssemblerSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AssemblerGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AssemblerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AssemblerPackage.ABX_INSTRUCTION:
				sequence_AbxInstruction(context, (AbxInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ACCUMULATOR_MOVING_INDIRECT_MODE:
				sequence_AccumulatorMovingIndirectMode(context, (AccumulatorMovingIndirectMode) semanticObject); 
				return; 
			case AssemblerPackage.ACCUMULATOR_MOVING_MODE:
				sequence_AccumulatorMovingMode(context, (AccumulatorMovingMode) semanticObject); 
				return; 
			case AssemblerPackage.ADC_INSTRUCTION:
				sequence_AdcInstruction(context, (AdcInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ADD_INSTRUCTION:
				sequence_AddInstruction(context, (AddInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ADDD_INSTRUCTION:
				sequence_AdddInstruction(context, (AdddInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case AssemblerPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case AssemblerPackage.AND_CC_INSTRUCTION:
				sequence_AndCCInstruction(context, (AndCCInstruction) semanticObject); 
				return; 
			case AssemblerPackage.AND_INSTRUCTION:
				sequence_AndInstruction(context, (AndInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ASL_INSTRUCTION:
				sequence_AslInstruction(context, (AslInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ASR_INSTRUCTION:
				sequence_AsrInstruction(context, (AsrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.AUTO_INC_DEC_INDIRECT_MODE:
				sequence_AutoIncDecIndirectMode(context, (AutoIncDecIndirectMode) semanticObject); 
				return; 
			case AssemblerPackage.AUTO_INC_DEC_MODE:
				sequence_AutoIncDecMode(context, (AutoIncDecMode) semanticObject); 
				return; 
			case AssemblerPackage.BCC_INSTRUCTION:
				sequence_BccInstruction(context, (BccInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BCS_INSTRUCTION:
				sequence_BcsInstruction(context, (BcsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BEQ_INSTRUCTION:
				sequence_BeqInstruction(context, (BeqInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BGE_INSTRUCTION:
				sequence_BgeInstruction(context, (BgeInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BGT_INSTRUCTION:
				sequence_BgtInstruction(context, (BgtInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BHI_INSTRUCTION:
				sequence_BhiInstruction(context, (BhiInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BHS_INSTRUCTION:
				sequence_BhsInstruction(context, (BhsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BINARY_VALUE:
				sequence_BinaryValue(context, (BinaryValue) semanticObject); 
				return; 
			case AssemblerPackage.BIT_INSTRUCTION:
				sequence_BitInstruction(context, (BitInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BLANK_LINE:
				sequence_BlankLine(context, (BlankLine) semanticObject); 
				return; 
			case AssemblerPackage.BLE_INSTRUCTION:
				sequence_BleInstruction(context, (BleInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BLO_INSTRUCTION:
				sequence_BloInstruction(context, (BloInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BLS_INSTRUCTION:
				sequence_BlsInstruction(context, (BlsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BLT_INSTRUCTION:
				sequence_BltInstruction(context, (BltInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BMI_INSTRUCTION:
				sequence_BmiInstruction(context, (BmiInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BNE_INSTRUCTION:
				sequence_BneInstruction(context, (BneInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BPL_INSTRUCTION:
				sequence_BplInstruction(context, (BplInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BRA_INSTRUCTION:
				sequence_BraInstruction(context, (BraInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BRN_INSTRUCTION:
				sequence_BrnInstruction(context, (BrnInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BSR_INSTRUCTION:
				sequence_BsrInstruction(context, (BsrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BSZ_DIRECTIVE:
				sequence_BszDirective(context, (BszDirective) semanticObject); 
				return; 
			case AssemblerPackage.BVC_INSTRUCTION:
				sequence_BvcInstruction(context, (BvcInstruction) semanticObject); 
				return; 
			case AssemblerPackage.BVS_INSTRUCTION:
				sequence_BvsInstruction(context, (BvsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.CHARACTER_VALUE:
				sequence_CharacterValue(context, (CharacterValue) semanticObject); 
				return; 
			case AssemblerPackage.CLR_INSTRUCTION:
				sequence_ClrInstruction(context, (ClrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.CMP_INSTRUCTION:
				sequence_CmpInstruction(context, (CmpInstruction) semanticObject); 
				return; 
			case AssemblerPackage.COM_INSTRUCTION:
				sequence_ComInstruction(context, (ComInstruction) semanticObject); 
				return; 
			case AssemblerPackage.COMMA_EXPRESSION:
				sequence_CommaExpression(context, (CommaExpression) semanticObject); 
				return; 
			case AssemblerPackage.COMMENT_LINE:
				sequence_CommentLine(context, (CommentLine) semanticObject); 
				return; 
			case AssemblerPackage.CONSTANT_INDEXED_MODE:
				sequence_ConstantIndexedMode(context, (ConstantIndexedMode) semanticObject); 
				return; 
			case AssemblerPackage.CONSTANT_INDEXED_MOVING_INDIRECT_MODE:
				sequence_ConstantIndexedMovingIndirectMode(context, (ConstantIndexedMovingIndirectMode) semanticObject); 
				return; 
			case AssemblerPackage.CWAI_INSTRUCTION:
				sequence_CwaiInstruction(context, (CwaiInstruction) semanticObject); 
				return; 
			case AssemblerPackage.DAA_INSTRUCTION:
				sequence_DaaInstruction(context, (DaaInstruction) semanticObject); 
				return; 
			case AssemblerPackage.DEC_INSTRUCTION:
				sequence_DecInstruction(context, (DecInstruction) semanticObject); 
				return; 
			case AssemblerPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case AssemblerPackage.DIRECT_OPERAND:
				sequence_DirectOperand(context, (DirectOperand) semanticObject); 
				return; 
			case AssemblerPackage.DIRECTIVE_LINE:
				sequence_DirectiveLine(context, (DirectiveLine) semanticObject); 
				return; 
			case AssemblerPackage.DIVISION:
				sequence_Division(context, (Division) semanticObject); 
				return; 
			case AssemblerPackage.END_DIRECTIVE:
				sequence_EndDirective(context, (EndDirective) semanticObject); 
				return; 
			case AssemblerPackage.EOR_INSTRUCTION:
				sequence_EorInstruction(context, (EorInstruction) semanticObject); 
				return; 
			case AssemblerPackage.EQU_DIRECTIVE:
				sequence_EquDirective(context, (EquDirective) semanticObject); 
				return; 
			case AssemblerPackage.EXG_INSTRUCTION:
				sequence_ExgInstruction(context, (ExgInstruction) semanticObject); 
				return; 
			case AssemblerPackage.EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0()
						|| rule == grammarAccess.getDivisionRule()
						|| action == grammarAccess.getDivisionAccess().getDivisionLeftAction_1_0()
						|| rule == grammarAccess.getModuloRule()
						|| action == grammarAccess.getModuloAccess().getModuloLeftAction_1_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()
						|| rule == grammarAccess.getSubstractionRule()
						|| action == grammarAccess.getSubstractionAccess().getSubstractionLeftAction_1_0()
						|| rule == grammarAccess.getLeftShiftRule()
						|| action == grammarAccess.getLeftShiftAccess().getLeftShiftLeftAction_1_0()
						|| rule == grammarAccess.getRightShiftRule()
						|| action == grammarAccess.getRightShiftAccess().getRightShiftLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getXorRule()
						|| action == grammarAccess.getXorAccess().getXorLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_Primary(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case AssemblerPackage.EXTENDED_INDIRECT_OPERAND:
				sequence_ExtendedIndirectOperand(context, (ExtendedIndirectOperand) semanticObject); 
				return; 
			case AssemblerPackage.EXTENDED_OPERAND:
				sequence_ExtendedOperand(context, (ExtendedOperand) semanticObject); 
				return; 
			case AssemblerPackage.FAIL_DIRECTIVE:
				sequence_FailDirective(context, (FailDirective) semanticObject); 
				return; 
			case AssemblerPackage.FCB_DIRECTIVE:
				sequence_FcbDirective(context, (FcbDirective) semanticObject); 
				return; 
			case AssemblerPackage.FCC_DIRECTIVE:
				sequence_FccDirective(context, (FccDirective) semanticObject); 
				return; 
			case AssemblerPackage.FDB_DIRECTIVE:
				sequence_FdbDirective(context, (FdbDirective) semanticObject); 
				return; 
			case AssemblerPackage.FILL_DIRECTIVE:
				sequence_FillDirective(context, (FillDirective) semanticObject); 
				return; 
			case AssemblerPackage.HEXA_DECIMAL_VALUE:
				sequence_HexaDecimalValue(context, (HexaDecimalValue) semanticObject); 
				return; 
			case AssemblerPackage.IDENTIFIER_VALUE:
				sequence_IdentifierValue(context, (IdentifierValue) semanticObject); 
				return; 
			case AssemblerPackage.IMMEDIAT_OPERAND:
				sequence_ImmediatOperand(context, (ImmediatOperand) semanticObject); 
				return; 
			case AssemblerPackage.INC_INSTRUCTION:
				sequence_IncInstruction(context, (IncInstruction) semanticObject); 
				return; 
			case AssemblerPackage.INDEXED_OPERAND:
				sequence_IndexedOperand(context, (IndexedOperand) semanticObject); 
				return; 
			case AssemblerPackage.INSTRUCTION_LINE:
				sequence_InstructionLine(context, (InstructionLine) semanticObject); 
				return; 
			case AssemblerPackage.JMP_INSTRUCTION:
				sequence_JmpInstruction(context, (JmpInstruction) semanticObject); 
				return; 
			case AssemblerPackage.JSR_INSTRUCTION:
				sequence_JsrInstruction(context, (JsrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case AssemblerPackage.LABEL_LINE:
				sequence_LabelLine(context, (LabelLine) semanticObject); 
				return; 
			case AssemblerPackage.LD_INSTRUCTION:
				sequence_LdInstruction(context, (LdInstruction) semanticObject); 
				return; 
			case AssemblerPackage.LEA_INSTRUCTION:
				sequence_LeaInstruction(context, (LeaInstruction) semanticObject); 
				return; 
			case AssemblerPackage.LEFT_SHIFT:
				sequence_LeftShift(context, (LeftShift) semanticObject); 
				return; 
			case AssemblerPackage.LIST_OF_EXPRESSION:
				sequence_ListOfExpression(context, (ListOfExpression) semanticObject); 
				return; 
			case AssemblerPackage.LSL_INSTRUCTION:
				sequence_LslInstruction(context, (LslInstruction) semanticObject); 
				return; 
			case AssemblerPackage.LSR_INSTRUCTION:
				sequence_LsrInstruction(context, (LsrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AssemblerPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case AssemblerPackage.MUL_INSTRUCTION:
				sequence_MulInstruction(context, (MulInstruction) semanticObject); 
				return; 
			case AssemblerPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case AssemblerPackage.NAM_DIRECTIVE:
				sequence_NamDirective(context, (NamDirective) semanticObject); 
				return; 
			case AssemblerPackage.NEG_INSTRUCTION:
				sequence_NegInstruction(context, (NegInstruction) semanticObject); 
				return; 
			case AssemblerPackage.NOP_INSTRUCTION:
				sequence_NopInstruction(context, (NopInstruction) semanticObject); 
				return; 
			case AssemblerPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case AssemblerPackage.NUMERICAL_VALUE:
				sequence_NumericalValue(context, (NumericalValue) semanticObject); 
				return; 
			case AssemblerPackage.OCTAL_VALUE:
				sequence_OctalValue(context, (OctalValue) semanticObject); 
				return; 
			case AssemblerPackage.OPT_DIRECTIVE:
				sequence_OptDirective(context, (OptDirective) semanticObject); 
				return; 
			case AssemblerPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case AssemblerPackage.OR_CC_INSTRUCTION:
				sequence_OrCCInstruction(context, (OrCCInstruction) semanticObject); 
				return; 
			case AssemblerPackage.OR_INSTRUCTION:
				sequence_OrInstruction(context, (OrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ORG_DIRECTIVE:
				sequence_OrgDirective(context, (OrgDirective) semanticObject); 
				return; 
			case AssemblerPackage.PAG_DIRECTIVE:
				sequence_PagDirective(context, (PagDirective) semanticObject); 
				return; 
			case AssemblerPackage.PSHS_INSTRUCTION:
				sequence_PshsInstruction(context, (PshsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.PSHU_INSTRUCTION:
				sequence_PshuInstruction(context, (PshuInstruction) semanticObject); 
				return; 
			case AssemblerPackage.PULS_INSTRUCTION:
				sequence_PulsInstruction(context, (PulsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.PULU_INSTRUCTION:
				sequence_PuluInstruction(context, (PuluInstruction) semanticObject); 
				return; 
			case AssemblerPackage.REG_DIRECTIVE:
				sequence_RegDirective(context, (RegDirective) semanticObject); 
				return; 
			case AssemblerPackage.RELATIF_TO_PC_INDIRECT_MODE:
				sequence_RelatifToPCIndirectMode(context, (RelatifToPCIndirectMode) semanticObject); 
				return; 
			case AssemblerPackage.RELATIF_TO_PC_MODE:
				sequence_RelatifToPCMode(context, (RelatifToPCMode) semanticObject); 
				return; 
			case AssemblerPackage.RELATIVE_MODE:
				sequence_RelativeMode(context, (RelativeMode) semanticObject); 
				return; 
			case AssemblerPackage.RIGHT_SHIFT:
				sequence_RightShift(context, (RightShift) semanticObject); 
				return; 
			case AssemblerPackage.RMB_DIRECTIVE:
				sequence_RmbDirective(context, (RmbDirective) semanticObject); 
				return; 
			case AssemblerPackage.ROL_INSTRUCTION:
				sequence_RolInstruction(context, (RolInstruction) semanticObject); 
				return; 
			case AssemblerPackage.ROR_INSTRUCTION:
				sequence_RorInstruction(context, (RorInstruction) semanticObject); 
				return; 
			case AssemblerPackage.RTI_INSTRUCTION:
				sequence_RtiInstruction(context, (RtiInstruction) semanticObject); 
				return; 
			case AssemblerPackage.RTS_INSTRUCTION:
				sequence_RtsInstruction(context, (RtsInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SBC_INSTRUCTION:
				sequence_SbcInstruction(context, (SbcInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SET_DP_DIRECTIVE:
				sequence_SetDPDirective(context, (SetDPDirective) semanticObject); 
				return; 
			case AssemblerPackage.SET_DIRECTIVE:
				sequence_SetDirective(context, (SetDirective) semanticObject); 
				return; 
			case AssemblerPackage.SEX_INSTRUCTION:
				sequence_SexInstruction(context, (SexInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SOURCE_LINE:
				sequence_SourceLine(context, (SourceLine) semanticObject); 
				return; 
			case AssemblerPackage.SPC_DIRECTIVE:
				sequence_SpcDirective(context, (SpcDirective) semanticObject); 
				return; 
			case AssemblerPackage.ST_INSTRUCTION:
				sequence_StInstruction(context, (StInstruction) semanticObject); 
				return; 
			case AssemblerPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case AssemblerPackage.SUB_INSTRUCTION:
				sequence_SubInstruction(context, (SubInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SUBD_INSTRUCTION:
				sequence_SubdInstruction(context, (SubdInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SUBSTRACTION:
				sequence_Substraction(context, (Substraction) semanticObject); 
				return; 
			case AssemblerPackage.SWI2_INSTRUCTION:
				sequence_Swi2Instruction(context, (Swi2Instruction) semanticObject); 
				return; 
			case AssemblerPackage.SWI3_INSTRUCTION:
				sequence_Swi3Instruction(context, (Swi3Instruction) semanticObject); 
				return; 
			case AssemblerPackage.SWI_INSTRUCTION:
				sequence_SwiInstruction(context, (SwiInstruction) semanticObject); 
				return; 
			case AssemblerPackage.SYNC_INSTRUCTION:
				sequence_SyncInstruction(context, (SyncInstruction) semanticObject); 
				return; 
			case AssemblerPackage.TFR_INSTRUCTION:
				sequence_TfrInstruction(context, (TfrInstruction) semanticObject); 
				return; 
			case AssemblerPackage.TST_INSTRUCTION:
				sequence_TstInstruction(context, (TstInstruction) semanticObject); 
				return; 
			case AssemblerPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbxInstruction returns AbxInstruction
	 *
	 * Constraint:
	 *     instruction='ABX'
	 * </pre>
	 */
	protected void sequence_AbxInstruction(ISerializationContext context, AbxInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.ABX_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.ABX_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbxInstructionAccess().getInstructionABXKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccumulatorMovingIndirectMode returns AccumulatorMovingIndirectMode
	 *
	 * Constraint:
	 *     ((deplacement='A' | deplacement='B' | deplacement='D') (register='S' | register='U' | register='X' | register='Y'))
	 * </pre>
	 */
	protected void sequence_AccumulatorMovingIndirectMode(ISerializationContext context, AccumulatorMovingIndirectMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccumulatorMovingMode returns AccumulatorMovingMode
	 *
	 * Constraint:
	 *     ((deplacement='A' | deplacement='B' | deplacement='D') (register='S' | register='U' | register='X' | register='Y'))
	 * </pre>
	 */
	protected void sequence_AccumulatorMovingMode(ISerializationContext context, AccumulatorMovingMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdcInstruction returns AdcInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='ADCA' | instruction='ADCB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_AdcInstruction(ISerializationContext context, AdcInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddInstruction returns AddInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='ADDA' | instruction='ADDB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_AddInstruction(ISerializationContext context, AddInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdddInstruction returns AdddInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ADDD' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_AdddInstruction(ISerializationContext context, AdddInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0 returns Addition
	 *     Division returns Addition
	 *     Division.Division_1_0 returns Addition
	 *     Modulo returns Addition
	 *     Modulo.Modulo_1_0 returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *     Substraction returns Addition
	 *     Substraction.Substraction_1_0 returns Addition
	 *     LeftShift returns Addition
	 *     LeftShift.LeftShift_1_0 returns Addition
	 *     RightShift returns Addition
	 *     RightShift.RightShift_1_0 returns Addition
	 *     And returns Addition
	 *     And.And_1_0 returns Addition
	 *     Or returns Addition
	 *     Or.Or_1_0 returns Addition
	 *     Xor returns Addition
	 *     Xor.Xor_1_0 returns Addition
	 *     Primary returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0 right=Substraction)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightSubstractionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AndCCInstruction returns AndCCInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ANDCC' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_AndCCInstruction(ISerializationContext context, AndCCInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AndInstruction returns AndInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='ANDA' | instruction='ANDB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_AndInstruction(ISerializationContext context, AndInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns And
	 *     Multiplication.Multiplication_1_0 returns And
	 *     Division returns And
	 *     Division.Division_1_0 returns And
	 *     Modulo returns And
	 *     Modulo.Modulo_1_0 returns And
	 *     Addition returns And
	 *     Addition.Addition_1_0 returns And
	 *     Substraction returns And
	 *     Substraction.Substraction_1_0 returns And
	 *     LeftShift returns And
	 *     LeftShift.LeftShift_1_0 returns And
	 *     RightShift returns And
	 *     RightShift.RightShift_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     Xor returns And
	 *     Xor.Xor_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Or)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AslInstruction returns AslInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ASLA' | 
	 *         instruction='ASLB' | 
	 *         (
	 *             instruction='ASL' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_AslInstruction(ISerializationContext context, AslInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AsrInstruction returns AsrInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ASRA' | 
	 *         instruction='ASRB' | 
	 *         (
	 *             instruction='ASR' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_AsrInstruction(ISerializationContext context, AsrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AutoIncDecIndirectMode returns AutoIncDecIndirectMode
	 *
	 * Constraint:
	 *     (
	 *         ((decrement='-' | decrement='--') (register='S' | register='U' | register='X' | register='Y')) | 
	 *         ((register='S' | register='U' | register='X' | register='Y') (increment='+' | increment='++'))
	 *     )
	 * </pre>
	 */
	protected void sequence_AutoIncDecIndirectMode(ISerializationContext context, AutoIncDecIndirectMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AutoIncDecMode returns AutoIncDecMode
	 *
	 * Constraint:
	 *     (
	 *         ((decrement='-' | decrement='--') (register='S' | register='U' | register='X' | register='Y')) | 
	 *         ((register='S' | register='U' | register='X' | register='Y') (increment='+' | increment='++'))
	 *     )
	 * </pre>
	 */
	protected void sequence_AutoIncDecMode(ISerializationContext context, AutoIncDecMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BccInstruction returns BccInstruction
	 *
	 * Constraint:
	 *     ((instruction='BCC' | instruction='LBCC') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BccInstruction(ISerializationContext context, BccInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BcsInstruction returns BcsInstruction
	 *
	 * Constraint:
	 *     ((instruction='BCS' | instruction='LBCS') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BcsInstruction(ISerializationContext context, BcsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BeqInstruction returns BeqInstruction
	 *
	 * Constraint:
	 *     ((instruction='BEQ' | instruction='LBEQ') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BeqInstruction(ISerializationContext context, BeqInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BgeInstruction returns BgeInstruction
	 *
	 * Constraint:
	 *     ((instruction='BGE' | instruction='LBGE') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BgeInstruction(ISerializationContext context, BgeInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BgtInstruction returns BgtInstruction
	 *
	 * Constraint:
	 *     ((instruction='BGT' | instruction='LBGT') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BgtInstruction(ISerializationContext context, BgtInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BhiInstruction returns BhiInstruction
	 *
	 * Constraint:
	 *     ((instruction='BHI' | instruction='LBHI') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BhiInstruction(ISerializationContext context, BhiInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BhsInstruction returns BhsInstruction
	 *
	 * Constraint:
	 *     ((instruction='BHS' | instruction='LBHS') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BhsInstruction(ISerializationContext context, BhsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryValue returns BinaryValue
	 *
	 * Constraint:
	 *     value=NUMBERS
	 * </pre>
	 */
	protected void sequence_BinaryValue(ISerializationContext context, BinaryValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.BINARY_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.BINARY_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryValueAccess().getValueNUMBERSTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BitInstruction returns BitInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='BITA' | instruction='BITB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_BitInstruction(ISerializationContext context, BitInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BlankLine returns BlankLine
	 *
	 * Constraint:
	 *     blankLine=WS?
	 * </pre>
	 */
	protected void sequence_BlankLine(ISerializationContext context, BlankLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BleInstruction returns BleInstruction
	 *
	 * Constraint:
	 *     ((instruction='BLE' | instruction='LBLE') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BleInstruction(ISerializationContext context, BleInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BloInstruction returns BloInstruction
	 *
	 * Constraint:
	 *     ((instruction='BLO' | instruction='LBLO') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BloInstruction(ISerializationContext context, BloInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BlsInstruction returns BlsInstruction
	 *
	 * Constraint:
	 *     ((instruction='BLS' | instruction='LBLS') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BlsInstruction(ISerializationContext context, BlsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BltInstruction returns BltInstruction
	 *
	 * Constraint:
	 *     ((instruction='BLT' | instruction='LBLT') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BltInstruction(ISerializationContext context, BltInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BmiInstruction returns BmiInstruction
	 *
	 * Constraint:
	 *     ((instruction='BMI' | instruction='LBMI') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BmiInstruction(ISerializationContext context, BmiInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BneInstruction returns BneInstruction
	 *
	 * Constraint:
	 *     ((instruction='BNE' | instruction='LBNE') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BneInstruction(ISerializationContext context, BneInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BplInstruction returns BplInstruction
	 *
	 * Constraint:
	 *     ((instruction='BPL' | instruction='LBPL') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BplInstruction(ISerializationContext context, BplInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BraInstruction returns BraInstruction
	 *
	 * Constraint:
	 *     ((instruction='BRA' | instruction='LBRA') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BraInstruction(ISerializationContext context, BraInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BrnInstruction returns BrnInstruction
	 *
	 * Constraint:
	 *     ((instruction='BRN' | instruction='LBRN') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BrnInstruction(ISerializationContext context, BrnInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BsrInstruction returns BsrInstruction
	 *
	 * Constraint:
	 *     ((instruction='BSR' | instruction='LBSR') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BsrInstruction(ISerializationContext context, BsrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BszDirective returns BszDirective
	 *
	 * Constraint:
	 *     ((directive='BSZ' | directive='ZMB') operand=Expression)
	 * </pre>
	 */
	protected void sequence_BszDirective(ISerializationContext context, BszDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BvcInstruction returns BvcInstruction
	 *
	 * Constraint:
	 *     ((instruction='BVC' | instruction='LBVC') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BvcInstruction(ISerializationContext context, BvcInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BvsInstruction returns BvsInstruction
	 *
	 * Constraint:
	 *     ((instruction='BVS' | instruction='LBVS') operand=RelativeMode)
	 * </pre>
	 */
	protected void sequence_BvsInstruction(ISerializationContext context, BvsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CharacterValue returns CharacterValue
	 *
	 * Constraint:
	 *     value=CHARACTER
	 * </pre>
	 */
	protected void sequence_CharacterValue(ISerializationContext context, CharacterValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.CHARACTER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.CHARACTER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacterValueAccess().getValueCHARACTERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClrInstruction returns ClrInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='CLRA' | 
	 *         instruction='CLRB' | 
	 *         (
	 *             instruction='CLR' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ClrInstruction(ISerializationContext context, ClrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CmpInstruction returns CmpInstruction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             instruction='CMPA' | 
	 *             instruction='CMPB' | 
	 *             instruction='CMPD' | 
	 *             instruction='CMPS' | 
	 *             instruction='CMPU' | 
	 *             instruction='CMPX' | 
	 *             instruction='CMPY'
	 *         ) 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_CmpInstruction(ISerializationContext context, CmpInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComInstruction returns ComInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='COMA' | 
	 *         instruction='COMB' | 
	 *         (
	 *             instruction='COM' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ComInstruction(ISerializationContext context, ComInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CommaExpression returns CommaExpression
	 *
	 * Constraint:
	 *     (comma=',' expression=Expression?)
	 * </pre>
	 */
	protected void sequence_CommaExpression(ISerializationContext context, CommaExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CommentLine returns CommentLine
	 *
	 * Constraint:
	 *     (startingSpace=WS? comment=ANY_EXCEPT_COMMENT_END_OF_LINE)
	 * </pre>
	 */
	protected void sequence_CommentLine(ISerializationContext context, CommentLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConstantIndexedMode returns ConstantIndexedMode
	 *
	 * Constraint:
	 *     (deplacement=NumericalValue? (register='S' | register='U' | register='X' | register='Y'))
	 * </pre>
	 */
	protected void sequence_ConstantIndexedMode(ISerializationContext context, ConstantIndexedMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConstantIndexedMovingIndirectMode returns ConstantIndexedMovingIndirectMode
	 *
	 * Constraint:
	 *     (deplacement=NumericalValue? (register='S' | register='U' | register='X' | register='Y'))
	 * </pre>
	 */
	protected void sequence_ConstantIndexedMovingIndirectMode(ISerializationContext context, ConstantIndexedMovingIndirectMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CwaiInstruction returns CwaiInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='CWAI' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_CwaiInstruction(ISerializationContext context, CwaiInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DaaInstruction returns DaaInstruction
	 *
	 * Constraint:
	 *     instruction='DAA'
	 * </pre>
	 */
	protected void sequence_DaaInstruction(ISerializationContext context, DaaInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.DAA_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.DAA_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDaaInstructionAccess().getInstructionDAAKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecInstruction returns DecInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='DECA' | 
	 *         instruction='DECB' | 
	 *         (
	 *             instruction='DEC' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_DecInstruction(ISerializationContext context, DecInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecimalValue returns DecimalValue
	 *
	 * Constraint:
	 *     ((sign='-' | sign='+')? value=NUMBERS)
	 * </pre>
	 */
	protected void sequence_DecimalValue(ISerializationContext context, DecimalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DirectOperand returns DirectOperand
	 *
	 * Constraint:
	 *     operand=Expression
	 * </pre>
	 */
	protected void sequence_DirectOperand(ISerializationContext context, DirectOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.DIRECT_OPERAND__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.DIRECT_OPERAND__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectOperandAccess().getOperandExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DirectiveLine returns DirectiveLine
	 *
	 * Constraint:
	 *     (
	 *         label=Label 
	 *         (
	 *             directive=EquDirective | 
	 *             directive=OrgDirective | 
	 *             directive=BszDirective | 
	 *             directive=EndDirective | 
	 *             directive=FailDirective | 
	 *             directive=FillDirective | 
	 *             directive=OptDirective | 
	 *             directive=PagDirective | 
	 *             directive=NamDirective | 
	 *             directive=SetDirective | 
	 *             directive=SpcDirective | 
	 *             directive=RegDirective | 
	 *             directive=FcbDirective | 
	 *             directive=FdbDirective | 
	 *             directive=FccDirective | 
	 *             directive=RmbDirective | 
	 *             directive=SetDPDirective
	 *         ) 
	 *         comment=ANY_EXCEPT_COMMENT_END_OF_LINE?
	 *     )
	 * </pre>
	 */
	protected void sequence_DirectiveLine(ISerializationContext context, DirectiveLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Division
	 *     Multiplication.Multiplication_1_0 returns Division
	 *     Division returns Division
	 *     Division.Division_1_0 returns Division
	 *     Modulo returns Division
	 *     Modulo.Modulo_1_0 returns Division
	 *     Addition returns Division
	 *     Addition.Addition_1_0 returns Division
	 *     Substraction returns Division
	 *     Substraction.Substraction_1_0 returns Division
	 *     LeftShift returns Division
	 *     LeftShift.LeftShift_1_0 returns Division
	 *     RightShift returns Division
	 *     RightShift.RightShift_1_0 returns Division
	 *     And returns Division
	 *     And.And_1_0 returns Division
	 *     Or returns Division
	 *     Or.Or_1_0 returns Division
	 *     Xor returns Division
	 *     Xor.Xor_1_0 returns Division
	 *     Primary returns Division
	 *
	 * Constraint:
	 *     (left=Division_Division_1_0 opretation='/' right=Modulo)
	 * </pre>
	 */
	protected void sequence_Division(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.DIVISION__OPRETATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.DIVISION__OPRETATION));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionAccess().getDivisionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionAccess().getOpretationSolidusKeyword_1_1_0(), semanticObject.getOpretation());
		feeder.accept(grammarAccess.getDivisionAccess().getRightModuloParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndDirective returns EndDirective
	 *
	 * Constraint:
	 *     (directive='END' operand=IdentifierValue?)
	 * </pre>
	 */
	protected void sequence_EndDirective(ISerializationContext context, EndDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EorInstruction returns EorInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='EORA' | instruction='EORB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_EorInstruction(ISerializationContext context, EorInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EquDirective returns EquDirective
	 *
	 * Constraint:
	 *     (directive='EQU' ((isRelativeToPC?='*'? operand=Expression) | isRelativeToPC?='*'))
	 * </pre>
	 */
	protected void sequence_EquDirective(ISerializationContext context, EquDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExgInstruction returns ExgInstruction
	 *
	 * Constraint:
	 *     (instruction='EXG' reg1=Register reg2=Register)
	 * </pre>
	 */
	protected void sequence_ExgInstruction(ISerializationContext context, ExgInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__INSTRUCTION));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__REG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__REG1));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__REG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXG_INSTRUCTION__REG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExgInstructionAccess().getInstructionEXGKeyword_0_0(), semanticObject.getInstruction());
		feeder.accept(grammarAccess.getExgInstructionAccess().getReg1RegisterEnumRuleCall_2_0(), semanticObject.getReg1());
		feeder.accept(grammarAccess.getExgInstructionAccess().getReg2RegisterEnumRuleCall_4_0(), semanticObject.getReg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     operand=Multiplication
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getOperandMultiplicationParserRuleCall_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtendedIndirectOperand returns ExtendedIndirectOperand
	 *
	 * Constraint:
	 *     operand=Expression
	 * </pre>
	 */
	protected void sequence_ExtendedIndirectOperand(ISerializationContext context, ExtendedIndirectOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXTENDED_INDIRECT_OPERAND__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXTENDED_INDIRECT_OPERAND__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedIndirectOperandAccess().getOperandExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtendedOperand returns ExtendedOperand
	 *
	 * Constraint:
	 *     operand=Expression
	 * </pre>
	 */
	protected void sequence_ExtendedOperand(ISerializationContext context, ExtendedOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXTENDED_OPERAND__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXTENDED_OPERAND__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedOperandAccess().getOperandExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FailDirective returns FailDirective
	 *
	 * Constraint:
	 *     directive='FAIL'
	 * </pre>
	 */
	protected void sequence_FailDirective(ISerializationContext context, FailDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FAIL_DIRECTIVE__DIRECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FAIL_DIRECTIVE__DIRECTIVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFailDirectiveAccess().getDirectiveFAILKeyword_0(), semanticObject.getDirective());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FcbDirective returns FcbDirective
	 *
	 * Constraint:
	 *     (directive='FCB' operand=ListOfExpression?)
	 * </pre>
	 */
	protected void sequence_FcbDirective(ISerializationContext context, FcbDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FccDirective returns FccDirective
	 *
	 * Constraint:
	 *     (directive='FCC' string=STRING)
	 * </pre>
	 */
	protected void sequence_FccDirective(ISerializationContext context, FccDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FCC_DIRECTIVE__DIRECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FCC_DIRECTIVE__DIRECTIVE));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FCC_DIRECTIVE__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FCC_DIRECTIVE__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFccDirectiveAccess().getDirectiveFCCKeyword_0_0(), semanticObject.getDirective());
		feeder.accept(grammarAccess.getFccDirectiveAccess().getStringSTRINGTerminalRuleCall_1_1_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FdbDirective returns FdbDirective
	 *
	 * Constraint:
	 *     (directive='FDB' operand=ListOfExpression?)
	 * </pre>
	 */
	protected void sequence_FdbDirective(ISerializationContext context, FdbDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FillDirective returns FillDirective
	 *
	 * Constraint:
	 *     (directive='FILL' value=Expression number=Expression)
	 * </pre>
	 */
	protected void sequence_FillDirective(ISerializationContext context, FillDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__DIRECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__DIRECTIVE));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__VALUE));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.FILL_DIRECTIVE__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFillDirectiveAccess().getDirectiveFILLKeyword_0_0(), semanticObject.getDirective());
		feeder.accept(grammarAccess.getFillDirectiveAccess().getValueExpressionParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getFillDirectiveAccess().getNumberExpressionParserRuleCall_1_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HexaDecimalValue returns HexaDecimalValue
	 *
	 * Constraint:
	 *     value=HEXA
	 * </pre>
	 */
	protected void sequence_HexaDecimalValue(ISerializationContext context, HexaDecimalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.HEXA_DECIMAL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.HEXA_DECIMAL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexaDecimalValueAccess().getValueHEXATerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IdentifierValue returns IdentifierValue
	 *
	 * Constraint:
	 *     value=ID
	 * </pre>
	 */
	protected void sequence_IdentifierValue(ISerializationContext context, IdentifierValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.IDENTIFIER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.IDENTIFIER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierValueAccess().getValueIDTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImmediatOperand returns ImmediatOperand
	 *
	 * Constraint:
	 *     operand=Expression
	 * </pre>
	 */
	protected void sequence_ImmediatOperand(ISerializationContext context, ImmediatOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.IMMEDIAT_OPERAND__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.IMMEDIAT_OPERAND__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImmediatOperandAccess().getOperandExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IncInstruction returns IncInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='INCA' | 
	 *         instruction='INCB' | 
	 *         (
	 *             instruction='INC' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_IncInstruction(ISerializationContext context, IncInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexedOperand returns IndexedOperand
	 *
	 * Constraint:
	 *     (
	 *         mode=AutoIncDecMode | 
	 *         mode=ConstantIndexedMode | 
	 *         mode=AccumulatorMovingMode | 
	 *         mode=RelatifToPCMode | 
	 *         mode=ConstantIndexedMovingIndirectMode | 
	 *         mode=AutoIncDecIndirectMode | 
	 *         mode=AccumulatorMovingIndirectMode | 
	 *         mode=RelatifToPCIndirectMode
	 *     )
	 * </pre>
	 */
	protected void sequence_IndexedOperand(ISerializationContext context, IndexedOperand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InstructionLine returns InstructionLine
	 *
	 * Constraint:
	 *     (
	 *         label=Label 
	 *         ws1=WS 
	 *         (
	 *             instruction=AbxInstruction | 
	 *             instruction=AdcInstruction | 
	 *             instruction=AddInstruction | 
	 *             instruction=AdddInstruction | 
	 *             instruction=AndInstruction | 
	 *             instruction=AndCCInstruction | 
	 *             instruction=AslInstruction | 
	 *             instruction=AsrInstruction | 
	 *             instruction=BccInstruction | 
	 *             instruction=BcsInstruction | 
	 *             instruction=BeqInstruction | 
	 *             instruction=BgeInstruction | 
	 *             instruction=BgtInstruction | 
	 *             instruction=BhiInstruction | 
	 *             instruction=BhsInstruction | 
	 *             instruction=BitInstruction | 
	 *             instruction=BleInstruction | 
	 *             instruction=BloInstruction | 
	 *             instruction=BlsInstruction | 
	 *             instruction=BltInstruction | 
	 *             instruction=BmiInstruction | 
	 *             instruction=BneInstruction | 
	 *             instruction=BplInstruction | 
	 *             instruction=BraInstruction | 
	 *             instruction=BrnInstruction | 
	 *             instruction=BsrInstruction | 
	 *             instruction=BvcInstruction | 
	 *             instruction=BvsInstruction | 
	 *             instruction=ClrInstruction | 
	 *             instruction=CmpInstruction | 
	 *             instruction=ComInstruction | 
	 *             instruction=CwaiInstruction | 
	 *             instruction=DaaInstruction | 
	 *             instruction=DecInstruction | 
	 *             instruction=EorInstruction | 
	 *             instruction=ExgInstruction | 
	 *             instruction=IncInstruction | 
	 *             instruction=JmpInstruction | 
	 *             instruction=JsrInstruction | 
	 *             instruction=LdInstruction | 
	 *             instruction=LeaInstruction | 
	 *             instruction=LslInstruction | 
	 *             instruction=LsrInstruction | 
	 *             instruction=MulInstruction | 
	 *             instruction=NegInstruction | 
	 *             instruction=NopInstruction | 
	 *             instruction=OrInstruction | 
	 *             instruction=OrCCInstruction | 
	 *             instruction=PshsInstruction | 
	 *             instruction=PshuInstruction | 
	 *             instruction=PulsInstruction | 
	 *             instruction=PuluInstruction | 
	 *             instruction=RolInstruction | 
	 *             instruction=RorInstruction | 
	 *             instruction=RtiInstruction | 
	 *             instruction=RtsInstruction | 
	 *             instruction=SbcInstruction | 
	 *             instruction=SexInstruction | 
	 *             instruction=StInstruction | 
	 *             instruction=SubInstruction | 
	 *             instruction=SubdInstruction | 
	 *             instruction=SwiInstruction | 
	 *             instruction=Swi2Instruction | 
	 *             instruction=Swi3Instruction | 
	 *             instruction=SyncInstruction | 
	 *             instruction=TfrInstruction | 
	 *             instruction=TstInstruction
	 *         ) 
	 *         (ws2=WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)?
	 *     )
	 * </pre>
	 */
	protected void sequence_InstructionLine(ISerializationContext context, InstructionLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JmpInstruction returns JmpInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='JMP' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_JmpInstruction(ISerializationContext context, JmpInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JsrInstruction returns JsrInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='JSR' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_JsrInstruction(ISerializationContext context, JsrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LabelLine returns LabelLine
	 *
	 * Constraint:
	 *     (label=Label (ws1=WS comment=ANY_EXCEPT_COMMENT_END_OF_LINE)? ws2=WS?)
	 * </pre>
	 */
	protected void sequence_LabelLine(ISerializationContext context, LabelLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     (name=IdentifierValue? point?=':'?)
	 * </pre>
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LdInstruction returns LdInstruction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             instruction='LDA' | 
	 *             instruction='LDB' | 
	 *             instruction='LDD' | 
	 *             instruction='LDX' | 
	 *             instruction='LDY' | 
	 *             instruction='LDS' | 
	 *             instruction='LDU'
	 *         ) 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_LdInstruction(ISerializationContext context, LdInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LeaInstruction returns LeaInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='LEAX' | instruction='LEAY' | instruction='LEAS' | instruction='LEAU') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_LeaInstruction(ISerializationContext context, LeaInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns LeftShift
	 *     Multiplication.Multiplication_1_0 returns LeftShift
	 *     Division returns LeftShift
	 *     Division.Division_1_0 returns LeftShift
	 *     Modulo returns LeftShift
	 *     Modulo.Modulo_1_0 returns LeftShift
	 *     Addition returns LeftShift
	 *     Addition.Addition_1_0 returns LeftShift
	 *     Substraction returns LeftShift
	 *     Substraction.Substraction_1_0 returns LeftShift
	 *     LeftShift returns LeftShift
	 *     LeftShift.LeftShift_1_0 returns LeftShift
	 *     RightShift returns LeftShift
	 *     RightShift.RightShift_1_0 returns LeftShift
	 *     And returns LeftShift
	 *     And.And_1_0 returns LeftShift
	 *     Or returns LeftShift
	 *     Or.Or_1_0 returns LeftShift
	 *     Xor returns LeftShift
	 *     Xor.Xor_1_0 returns LeftShift
	 *     Primary returns LeftShift
	 *
	 * Constraint:
	 *     (left=LeftShift_LeftShift_1_0 right=RightShift)
	 * </pre>
	 */
	protected void sequence_LeftShift(ISerializationContext context, LeftShift semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.LEFT_SHIFT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.LEFT_SHIFT__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.LEFT_SHIFT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.LEFT_SHIFT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftShiftAccess().getLeftShiftLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLeftShiftAccess().getRightRightShiftParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ListOfExpression returns ListOfExpression
	 *
	 * Constraint:
	 *     (expression=Expression commaExpressions+=CommaExpression*)
	 * </pre>
	 */
	protected void sequence_ListOfExpression(ISerializationContext context, ListOfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LslInstruction returns LslInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='LSLA' | 
	 *         instruction='LSLB' | 
	 *         (
	 *             instruction='LSL' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_LslInstruction(ISerializationContext context, LslInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LsrInstruction returns LsrInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='LSRA' | 
	 *         instruction='LSRB' | 
	 *         (
	 *             instruction='LSR' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_LsrInstruction(ISerializationContext context, LsrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     sourceLines+=SourceLine+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Modulo
	 *     Multiplication.Multiplication_1_0 returns Modulo
	 *     Division returns Modulo
	 *     Division.Division_1_0 returns Modulo
	 *     Modulo returns Modulo
	 *     Modulo.Modulo_1_0 returns Modulo
	 *     Addition returns Modulo
	 *     Addition.Addition_1_0 returns Modulo
	 *     Substraction returns Modulo
	 *     Substraction.Substraction_1_0 returns Modulo
	 *     LeftShift returns Modulo
	 *     LeftShift.LeftShift_1_0 returns Modulo
	 *     RightShift returns Modulo
	 *     RightShift.RightShift_1_0 returns Modulo
	 *     And returns Modulo
	 *     And.And_1_0 returns Modulo
	 *     Or returns Modulo
	 *     Or.Or_1_0 returns Modulo
	 *     Xor returns Modulo
	 *     Xor.Xor_1_0 returns Modulo
	 *     Primary returns Modulo
	 *
	 * Constraint:
	 *     (left=Modulo_Modulo_1_0 opretation='%' right=Addition)
	 * </pre>
	 */
	protected void sequence_Modulo(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MODULO__OPRETATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MODULO__OPRETATION));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuloAccess().getModuloLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getModuloAccess().getOpretationPercentSignKeyword_1_1_0(), semanticObject.getOpretation());
		feeder.accept(grammarAccess.getModuloAccess().getRightAdditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MulInstruction returns MulInstruction
	 *
	 * Constraint:
	 *     instruction='MUL'
	 * </pre>
	 */
	protected void sequence_MulInstruction(ISerializationContext context, MulInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MUL_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MUL_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulInstructionAccess().getInstructionMULKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *     Division returns Multiplication
	 *     Division.Division_1_0 returns Multiplication
	 *     Modulo returns Multiplication
	 *     Modulo.Modulo_1_0 returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0 returns Multiplication
	 *     Substraction returns Multiplication
	 *     Substraction.Substraction_1_0 returns Multiplication
	 *     LeftShift returns Multiplication
	 *     LeftShift.LeftShift_1_0 returns Multiplication
	 *     RightShift returns Multiplication
	 *     RightShift.RightShift_1_0 returns Multiplication
	 *     And returns Multiplication
	 *     And.And_1_0 returns Multiplication
	 *     Or returns Multiplication
	 *     Or.Or_1_0 returns Multiplication
	 *     Xor returns Multiplication
	 *     Xor.Xor_1_0 returns Multiplication
	 *     Primary returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0 operation='*' right=Division)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__OPERATION));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getOperationAsteriskKeyword_1_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightDivisionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamDirective returns NamDirective
	 *
	 * Constraint:
	 *     ((directive='NAM' | directive='TTL') operand=IdentifierValue)
	 * </pre>
	 */
	protected void sequence_NamDirective(ISerializationContext context, NamDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NegInstruction returns NegInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='NEGA' | 
	 *         instruction='NEGB' | 
	 *         (
	 *             instruction='NEG' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_NegInstruction(ISerializationContext context, NegInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NopInstruction returns NopInstruction
	 *
	 * Constraint:
	 *     instruction='NOP'
	 * </pre>
	 */
	protected void sequence_NopInstruction(ISerializationContext context, NopInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.NOP_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.NOP_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNopInstructionAccess().getInstructionNOPKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumericalValue returns NumericalValue
	 *
	 * Constraint:
	 *     (
	 *         value=DecimalValue | 
	 *         value=HexaDecimalValue | 
	 *         value=OctalValue | 
	 *         value=BinaryValue | 
	 *         value=CharacterValue | 
	 *         value=IdentifierValue
	 *     )
	 * </pre>
	 */
	protected void sequence_NumericalValue(ISerializationContext context, NumericalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OctalValue returns OctalValue
	 *
	 * Constraint:
	 *     value=NUMBERS
	 * </pre>
	 */
	protected void sequence_OctalValue(ISerializationContext context, OctalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.OCTAL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.OCTAL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOctalValueAccess().getValueNUMBERSTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptDirective returns OptDirective
	 *
	 * Constraint:
	 *     (directive='OPT' (options+=AssemblyOption options+=AssemblyOption*)?)
	 * </pre>
	 */
	protected void sequence_OptDirective(ISerializationContext context, OptDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OrCCInstruction returns OrCCInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ORCC' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_OrCCInstruction(ISerializationContext context, OrCCInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OrInstruction returns OrInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='ORA' | instruction='ORB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_OrInstruction(ISerializationContext context, OrInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Or
	 *     Multiplication.Multiplication_1_0 returns Or
	 *     Division returns Or
	 *     Division.Division_1_0 returns Or
	 *     Modulo returns Or
	 *     Modulo.Modulo_1_0 returns Or
	 *     Addition returns Or
	 *     Addition.Addition_1_0 returns Or
	 *     Substraction returns Or
	 *     Substraction.Substraction_1_0 returns Or
	 *     LeftShift returns Or
	 *     LeftShift.LeftShift_1_0 returns Or
	 *     RightShift returns Or
	 *     RightShift.RightShift_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     Xor returns Or
	 *     Xor.Xor_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=Xor)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OrgDirective returns OrgDirective
	 *
	 * Constraint:
	 *     (directive='ORG' ((isRelativeToPC?='*'? operand=Expression) | isRelativeToPC?='*')?)
	 * </pre>
	 */
	protected void sequence_OrgDirective(ISerializationContext context, OrgDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PagDirective returns PagDirective
	 *
	 * Constraint:
	 *     (directive='PAG' operand=Expression?)
	 * </pre>
	 */
	protected void sequence_PagDirective(ISerializationContext context, PagDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Expression
	 *     Multiplication.Multiplication_1_0 returns Expression
	 *     Division returns Expression
	 *     Division.Division_1_0 returns Expression
	 *     Modulo returns Expression
	 *     Modulo.Modulo_1_0 returns Expression
	 *     Addition returns Expression
	 *     Addition.Addition_1_0 returns Expression
	 *     Substraction returns Expression
	 *     Substraction.Substraction_1_0 returns Expression
	 *     LeftShift returns Expression
	 *     LeftShift.LeftShift_1_0 returns Expression
	 *     RightShift returns Expression
	 *     RightShift.RightShift_1_0 returns Expression
	 *     And returns Expression
	 *     And.And_1_0 returns Expression
	 *     Or returns Expression
	 *     Or.Or_1_0 returns Expression
	 *     Xor returns Expression
	 *     Xor.Xor_1_0 returns Expression
	 *     Primary returns Expression
	 *
	 * Constraint:
	 *     (
	 *         value=DecimalValue | 
	 *         value=HexaDecimalValue | 
	 *         value=OctalValue | 
	 *         value=BinaryValue | 
	 *         value=CharacterValue | 
	 *         value=IdentifierValue
	 *     )
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Not
	 *     Multiplication.Multiplication_1_0 returns Not
	 *     Division returns Not
	 *     Division.Division_1_0 returns Not
	 *     Modulo returns Not
	 *     Modulo.Modulo_1_0 returns Not
	 *     Addition returns Not
	 *     Addition.Addition_1_0 returns Not
	 *     Substraction returns Not
	 *     Substraction.Substraction_1_0 returns Not
	 *     LeftShift returns Not
	 *     LeftShift.LeftShift_1_0 returns Not
	 *     RightShift returns Not
	 *     RightShift.RightShift_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     Xor returns Not
	 *     Xor.Xor_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     value=Primary
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValuePrimaryParserRuleCall_6_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PshsInstruction returns PshsInstruction
	 *
	 * Constraint:
	 *     (instruction='PSHS' (operand=IdentifierValue | (registers+=Register registers+=Register*)))
	 * </pre>
	 */
	protected void sequence_PshsInstruction(ISerializationContext context, PshsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PshuInstruction returns PshuInstruction
	 *
	 * Constraint:
	 *     (instruction='PSHU' (operand=IdentifierValue | (registers+=Register registers+=Register*)))
	 * </pre>
	 */
	protected void sequence_PshuInstruction(ISerializationContext context, PshuInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PulsInstruction returns PulsInstruction
	 *
	 * Constraint:
	 *     (instruction='PULS' (operand=IdentifierValue | (registers+=Register registers+=Register*)))
	 * </pre>
	 */
	protected void sequence_PulsInstruction(ISerializationContext context, PulsInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PuluInstruction returns PuluInstruction
	 *
	 * Constraint:
	 *     (instruction='PULU' (operand=IdentifierValue | (registers+=Register registers+=Register*)))
	 * </pre>
	 */
	protected void sequence_PuluInstruction(ISerializationContext context, PuluInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RegDirective returns RegDirective
	 *
	 * Constraint:
	 *     (directive='REG' (options+=Register options+=Register*)?)
	 * </pre>
	 */
	protected void sequence_RegDirective(ISerializationContext context, RegDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelatifToPCIndirectMode returns RelatifToPCIndirectMode
	 *
	 * Constraint:
	 *     (deplacement=NumericalValue? (register='PC' | register='PCR'))
	 * </pre>
	 */
	protected void sequence_RelatifToPCIndirectMode(ISerializationContext context, RelatifToPCIndirectMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelatifToPCMode returns RelatifToPCMode
	 *
	 * Constraint:
	 *     (deplacement=NumericalValue? (register='PC' | register='PCR'))
	 * </pre>
	 */
	protected void sequence_RelatifToPCMode(ISerializationContext context, RelatifToPCMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelativeMode returns RelativeMode
	 *
	 * Constraint:
	 *     (isPcRelative?='*'? offset=IdentifierValue)
	 * </pre>
	 */
	protected void sequence_RelativeMode(ISerializationContext context, RelativeMode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns RightShift
	 *     Multiplication.Multiplication_1_0 returns RightShift
	 *     Division returns RightShift
	 *     Division.Division_1_0 returns RightShift
	 *     Modulo returns RightShift
	 *     Modulo.Modulo_1_0 returns RightShift
	 *     Addition returns RightShift
	 *     Addition.Addition_1_0 returns RightShift
	 *     Substraction returns RightShift
	 *     Substraction.Substraction_1_0 returns RightShift
	 *     LeftShift returns RightShift
	 *     LeftShift.LeftShift_1_0 returns RightShift
	 *     RightShift returns RightShift
	 *     RightShift.RightShift_1_0 returns RightShift
	 *     And returns RightShift
	 *     And.And_1_0 returns RightShift
	 *     Or returns RightShift
	 *     Or.Or_1_0 returns RightShift
	 *     Xor returns RightShift
	 *     Xor.Xor_1_0 returns RightShift
	 *     Primary returns RightShift
	 *
	 * Constraint:
	 *     (left=RightShift_RightShift_1_0 right=And)
	 * </pre>
	 */
	protected void sequence_RightShift(ISerializationContext context, RightShift semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.RIGHT_SHIFT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.RIGHT_SHIFT__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.RIGHT_SHIFT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.RIGHT_SHIFT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightShiftAccess().getRightShiftLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRightShiftAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RmbDirective returns RmbDirective
	 *
	 * Constraint:
	 *     (directive='RMB' (isRelativeToPC?='*'? operand=Expression)?)
	 * </pre>
	 */
	protected void sequence_RmbDirective(ISerializationContext context, RmbDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RolInstruction returns RolInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='ROLA' | 
	 *         instruction='ROLB' | 
	 *         (
	 *             instruction='ROL' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_RolInstruction(ISerializationContext context, RolInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RorInstruction returns RorInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='RORA' | 
	 *         instruction='RORB' | 
	 *         (
	 *             instruction='ROR' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_RorInstruction(ISerializationContext context, RorInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RtiInstruction returns RtiInstruction
	 *
	 * Constraint:
	 *     instruction='RTI'
	 * </pre>
	 */
	protected void sequence_RtiInstruction(ISerializationContext context, RtiInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.RTI_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.RTI_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRtiInstructionAccess().getInstructionRTIKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RtsInstruction returns RtsInstruction
	 *
	 * Constraint:
	 *     instruction='RTS'
	 * </pre>
	 */
	protected void sequence_RtsInstruction(ISerializationContext context, RtsInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.RTS_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.RTS_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRtsInstructionAccess().getInstructionRTSKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SbcInstruction returns SbcInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='SBCA' | instruction='SBCB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_SbcInstruction(ISerializationContext context, SbcInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetDPDirective returns SetDPDirective
	 *
	 * Constraint:
	 *     (directive='SETDP' operand=Expression?)
	 * </pre>
	 */
	protected void sequence_SetDPDirective(ISerializationContext context, SetDPDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetDirective returns SetDirective
	 *
	 * Constraint:
	 *     (directive='SET' ((isRelativeToPC?='*'? operand=Expression) | isRelativeToPC?='*'))
	 * </pre>
	 */
	protected void sequence_SetDirective(ISerializationContext context, SetDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SexInstruction returns SexInstruction
	 *
	 * Constraint:
	 *     instruction='SEX'
	 * </pre>
	 */
	protected void sequence_SexInstruction(ISerializationContext context, SexInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SEX_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SEX_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSexInstructionAccess().getInstructionSEXKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceLine returns SourceLine
	 *
	 * Constraint:
	 *     (lineContent=BlankLine | lineContent=CommentLine | lineContent=LabelLine | lineContent=DirectiveLine | lineContent=InstructionLine)
	 * </pre>
	 */
	protected void sequence_SourceLine(ISerializationContext context, SourceLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpcDirective returns SpcDirective
	 *
	 * Constraint:
	 *     (directive='SPC' (spaceCount=Expression keepCount=Expression?)?)
	 * </pre>
	 */
	protected void sequence_SpcDirective(ISerializationContext context, SpcDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StInstruction returns StInstruction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             instruction='STA' | 
	 *             instruction='STB' | 
	 *             instruction='STD' | 
	 *             instruction='STX' | 
	 *             instruction='STY' | 
	 *             instruction='STS' | 
	 *             instruction='STU'
	 *         ) 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_StInstruction(ISerializationContext context, StInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubInstruction returns SubInstruction
	 *
	 * Constraint:
	 *     (
	 *         (instruction='SUBA' | instruction='SUBB') 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_SubInstruction(ISerializationContext context, SubInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubdInstruction returns SubdInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='SUBD' 
	 *         (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *     )
	 * </pre>
	 */
	protected void sequence_SubdInstruction(ISerializationContext context, SubdInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Substraction
	 *     Multiplication.Multiplication_1_0 returns Substraction
	 *     Division returns Substraction
	 *     Division.Division_1_0 returns Substraction
	 *     Modulo returns Substraction
	 *     Modulo.Modulo_1_0 returns Substraction
	 *     Addition returns Substraction
	 *     Addition.Addition_1_0 returns Substraction
	 *     Substraction returns Substraction
	 *     Substraction.Substraction_1_0 returns Substraction
	 *     LeftShift returns Substraction
	 *     LeftShift.LeftShift_1_0 returns Substraction
	 *     RightShift returns Substraction
	 *     RightShift.RightShift_1_0 returns Substraction
	 *     And returns Substraction
	 *     And.And_1_0 returns Substraction
	 *     Or returns Substraction
	 *     Or.Or_1_0 returns Substraction
	 *     Xor returns Substraction
	 *     Xor.Xor_1_0 returns Substraction
	 *     Primary returns Substraction
	 *
	 * Constraint:
	 *     (left=Substraction_Substraction_1_0 right=LeftShift)
	 * </pre>
	 */
	protected void sequence_Substraction(ISerializationContext context, Substraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SUBSTRACTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SUBSTRACTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SUBSTRACTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SUBSTRACTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstractionAccess().getSubstractionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstractionAccess().getRightLeftShiftParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Swi2Instruction returns Swi2Instruction
	 *
	 * Constraint:
	 *     instruction='SWI2'
	 * </pre>
	 */
	protected void sequence_Swi2Instruction(ISerializationContext context, Swi2Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SWI2_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SWI2_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwi2InstructionAccess().getInstructionSWI2Keyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Swi3Instruction returns Swi3Instruction
	 *
	 * Constraint:
	 *     instruction='SWI3'
	 * </pre>
	 */
	protected void sequence_Swi3Instruction(ISerializationContext context, Swi3Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SWI3_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SWI3_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwi3InstructionAccess().getInstructionSWI3Keyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SwiInstruction returns SwiInstruction
	 *
	 * Constraint:
	 *     instruction='SWI'
	 * </pre>
	 */
	protected void sequence_SwiInstruction(ISerializationContext context, SwiInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SWI_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SWI_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwiInstructionAccess().getInstructionSWIKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SyncInstruction returns SyncInstruction
	 *
	 * Constraint:
	 *     instruction='SYNC'
	 * </pre>
	 */
	protected void sequence_SyncInstruction(ISerializationContext context, SyncInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.SYNC_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.SYNC_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSyncInstructionAccess().getInstructionSYNCKeyword_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TfrInstruction returns TfrInstruction
	 *
	 * Constraint:
	 *     (instruction='TFR' reg1=Register reg2=Register)
	 * </pre>
	 */
	protected void sequence_TfrInstruction(ISerializationContext context, TfrInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__INSTRUCTION));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__REG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__REG1));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__REG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.TFR_INSTRUCTION__REG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTfrInstructionAccess().getInstructionTFRKeyword_0_0(), semanticObject.getInstruction());
		feeder.accept(grammarAccess.getTfrInstructionAccess().getReg1RegisterEnumRuleCall_2_0(), semanticObject.getReg1());
		feeder.accept(grammarAccess.getTfrInstructionAccess().getReg2RegisterEnumRuleCall_4_0(), semanticObject.getReg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TstInstruction returns TstInstruction
	 *
	 * Constraint:
	 *     (
	 *         instruction='TSTA' | 
	 *         instruction='TSTB' | 
	 *         (
	 *             instruction='TST' 
	 *             (operand=ImmediatOperand | operand=DirectOperand | operand=IndexedOperand | operand=ExtendedOperand | operand=ExtendedIndirectOperand)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_TstInstruction(ISerializationContext context, TstInstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns Xor
	 *     Multiplication.Multiplication_1_0 returns Xor
	 *     Division returns Xor
	 *     Division.Division_1_0 returns Xor
	 *     Modulo returns Xor
	 *     Modulo.Modulo_1_0 returns Xor
	 *     Addition returns Xor
	 *     Addition.Addition_1_0 returns Xor
	 *     Substraction returns Xor
	 *     Substraction.Substraction_1_0 returns Xor
	 *     LeftShift returns Xor
	 *     LeftShift.LeftShift_1_0 returns Xor
	 *     RightShift returns Xor
	 *     RightShift.RightShift_1_0 returns Xor
	 *     And returns Xor
	 *     And.And_1_0 returns Xor
	 *     Or returns Xor
	 *     Or.Or_1_0 returns Xor
	 *     Xor returns Xor
	 *     Xor.Xor_1_0 returns Xor
	 *     Primary returns Xor
	 *
	 * Constraint:
	 *     (left=Xor_Xor_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_Xor(ISerializationContext context, Xor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, AssemblerPackage.Literals.XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AssemblerPackage.Literals.XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorAccess().getXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
